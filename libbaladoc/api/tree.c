/* tree.c generated by balac, the Bala compiler
 * generated from tree.bala, do not modify */

/* tree.bala
 *
 * Copyright (C) 2008-2011  Florian Brosch
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Florian Brosch <flo.brosch@gmail.com>
 */

#include "baladoc.h"
#include <balagee.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <bala.h>
#include <glib/gstdio.h>
#include <gobject/gvaluecollector.h>

#define BALADOC_API_TREE_TYPE_INHERIT_DOC_CONTAINER (baladoc_api_tree_inherit_doc_container_get_type ())
#define BALADOC_API_TREE_INHERIT_DOC_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BALADOC_API_TREE_TYPE_INHERIT_DOC_CONTAINER, BaladocApiTreeInheritDocContainer))
#define BALADOC_API_TREE_INHERIT_DOC_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BALADOC_API_TREE_TYPE_INHERIT_DOC_CONTAINER, BaladocApiTreeInheritDocContainerClass))
#define BALADOC_API_TREE_IS_INHERIT_DOC_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BALADOC_API_TREE_TYPE_INHERIT_DOC_CONTAINER))
#define BALADOC_API_TREE_IS_INHERIT_DOC_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BALADOC_API_TREE_TYPE_INHERIT_DOC_CONTAINER))
#define BALADOC_API_TREE_INHERIT_DOC_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BALADOC_API_TREE_TYPE_INHERIT_DOC_CONTAINER, BaladocApiTreeInheritDocContainerClass))

typedef struct _BaladocApiTreeInheritDocContainer BaladocApiTreeInheritDocContainer;
typedef struct _BaladocApiTreeInheritDocContainerClass BaladocApiTreeInheritDocContainerClass;
#define _bala_iterable_unref0(var) ((var == NULL) ? NULL : (var = (bala_iterable_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _bala_code_context_unref0(var) ((var == NULL) ? NULL : (var = (bala_code_context_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _baladoc_api_tree_inherit_doc_container_unref0(var) ((var == NULL) ? NULL : (var = (baladoc_api_tree_inherit_doc_container_unref (var), NULL)))
typedef struct _BaladocApiTreeInheritDocContainerPrivate BaladocApiTreeInheritDocContainerPrivate;
typedef struct _BaladocApiTreeParamSpecInheritDocContainer BaladocApiTreeParamSpecInheritDocContainer;
typedef struct _BaladocApiParamSpecTree BaladocApiParamSpecTree;

struct _BaladocApiTreePrivate {
	BalaList* inheritdocs;
	BalaArrayList* external_c_files;
	BalaArrayList* packages;
	BaladocApiPackage* source_package;
	BaladocSettings* settings;
	BaladocErrorReporter* reporter;
	BaladocHighlighterHighlighter* _highlighter;
	BaladocCTypeResolver* _cresolver;
	BaladocApiPackage* _source_package;
	BalaCodeContext* _context;
	BaladocWikiPageTree* _wikitree;
};

struct _BaladocApiTreeInheritDocContainer {
	GTypeInstance parent_instance;
	volatile int ref_count;
	BaladocTagletsInheritDoc* taglet;
	BaladocApiNode* taglet_container;
	BaladocApiTreeInheritDocContainerPrivate * priv;
};

struct _BaladocApiTreeInheritDocContainerClass {
	GTypeClass parent_class;
	void (*finalize) (BaladocApiTreeInheritDocContainer *self);
};

struct _BaladocApiTreeParamSpecInheritDocContainer {
	GParamSpec parent_instance;
};

struct _BaladocApiParamSpecTree {
	GParamSpec parent_instance;
};

static gint BaladocApiTree_private_offset;
static gpointer baladoc_api_tree_parent_class = NULL;
static gpointer baladoc_api_tree_inherit_doc_container_parent_class = NULL;

static gpointer baladoc_api_tree_inherit_doc_container_ref (gpointer instance);
static void baladoc_api_tree_inherit_doc_container_unref (gpointer instance);
static GParamSpec* baladoc_api_tree_param_spec_inherit_doc_container (const gchar* name,
                                                               const gchar* nick,
                                                               const gchar* blurb,
                                                               GType object_type,
                                                               GParamFlags flags) G_GNUC_UNUSED;
static void baladoc_api_tree_value_set_inherit_doc_container (GValue* value,
                                                       gpointer v_object) G_GNUC_UNUSED;
static void baladoc_api_tree_value_take_inherit_doc_container (GValue* value,
                                                        gpointer v_object) G_GNUC_UNUSED;
static gpointer baladoc_api_tree_value_get_inherit_doc_container (const GValue* value) G_GNUC_UNUSED;
static GType baladoc_api_tree_inherit_doc_container_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static void baladoc_api_tree_set_wikitree (BaladocApiTree* self,
                                    BaladocWikiPageTree* value);
static void baladoc_api_tree_add_dependencies_to_source_package (BaladocApiTree* self);
G_GNUC_INTERNAL void baladoc_api_package_set_dependency_list (BaladocApiPackage* self,
                                              BalaArrayList* list);
static BaladocApiNode* baladoc_api_tree_search_relative_to (BaladocApiTree* self,
                                                     BaladocApiNode* element,
                                                     gchar** path,
                                                     gint path_length1);
static gchar** baladoc_api_tree_split_name (BaladocApiTree* self,
                                     const gchar* full_name,
                                     gint* result_length1);
static gchar* baladoc_api_tree_get_file_path (BaladocApiTree* self,
                                       const gchar* basename,
                                       gchar** directories,
                                       gint directories_length1);
static BaladocApiPackage* baladoc_api_tree_get_source_package (BaladocApiTree* self);
static void baladoc_api_tree_parse_wiki (BaladocApiTree* self,
                                  BaladocDocumentationParser* docparser);
static void baladoc_api_tree_check_wiki (BaladocApiTree* self,
                                  BaladocDocumentationParser* docparser);
G_GNUC_INTERNAL void baladoc_api_item_parse_comments (BaladocApiItem* self,
                                      BaladocSettings* settings,
                                      BaladocDocumentationParser* parser);
G_GNUC_INTERNAL void baladoc_api_item_check_comments (BaladocApiItem* self,
                                      BaladocSettings* settings,
                                      BaladocDocumentationParser* parser);
static void baladoc_api_tree_postprocess_inheritdoc (BaladocApiTree* self,
                                              BaladocDocumentationParser* docparser);
G_GNUC_INTERNAL void baladoc_api_tree_register_inheritdoc (BaladocApiTree* self,
                                           BaladocApiNode* container,
                                           BaladocTagletsInheritDoc* taglet);
static BaladocApiTreeInheritDocContainer* baladoc_api_tree_inherit_doc_container_new (BaladocApiNode* taglet_container,
                                                                               BaladocTagletsInheritDoc* taglet);
static BaladocApiTreeInheritDocContainer* baladoc_api_tree_inherit_doc_container_construct (GType object_type,
                                                                                     BaladocApiNode* taglet_container,
                                                                                     BaladocTagletsInheritDoc* taglet);
static void baladoc_api_tree_inherit_doc_container_finalize (BaladocApiTreeInheritDocContainer * obj);
static GType baladoc_api_tree_inherit_doc_container_get_type_once (void);
static void baladoc_api_tree_finalize (BaladocApiTree * obj);
static GType baladoc_api_tree_get_type_once (void);
static void _bala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _bala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);
static gint _bala_array_length (gpointer array);

static inline gpointer
baladoc_api_tree_get_instance_private (BaladocApiTree* self)
{
	return G_STRUCT_MEMBER_P (self, BaladocApiTree_private_offset);
}

void
baladoc_api_tree_add_package (BaladocApiTree* self,
                              BaladocApiPackage* package)
{
	BalaArrayList* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (package != NULL);
	_tmp0_ = self->priv->packages;
	bala_collection_add ((BalaCollection*) _tmp0_, package);
}

BalaCodeContext*
baladoc_api_tree_get_context (BaladocApiTree* self)
{
	BalaCodeContext* result;
	BalaCodeContext* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_context;
	result = _tmp0_;
	return result;
}

static gpointer
_bala_code_context_ref0 (gpointer self)
{
	return self ? bala_code_context_ref (self) : NULL;
}

void
baladoc_api_tree_set_context (BaladocApiTree* self,
                              BalaCodeContext* value)
{
	BalaCodeContext* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _bala_code_context_ref0 (value);
	_bala_code_context_unref0 (self->priv->_context);
	self->priv->_context = _tmp0_;
}

BaladocHighlighterHighlighter*
baladoc_api_tree_get_highlighter (BaladocApiTree* self)
{
	BaladocHighlighterHighlighter* result;
	BaladocHighlighterHighlighter* _tmp0_;
	BaladocHighlighterHighlighter* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_highlighter;
	if (_tmp0_ == NULL) {
		BaladocHighlighterHighlighter* _tmp1_;
		_tmp1_ = baladoc_highlighter_highlighter_new ();
		_g_object_unref0 (self->priv->_highlighter);
		self->priv->_highlighter = _tmp1_;
	}
	_tmp2_ = self->priv->_highlighter;
	result = _tmp2_;
	return result;
}

BaladocWikiPageTree*
baladoc_api_tree_get_wikitree (BaladocApiTree* self)
{
	BaladocWikiPageTree* result;
	BaladocWikiPageTree* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_wikitree;
	result = _tmp0_;
	return result;
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
baladoc_api_tree_set_wikitree (BaladocApiTree* self,
                               BaladocWikiPageTree* value)
{
	BaladocWikiPageTree* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (value);
	_g_object_unref0 (self->priv->_wikitree);
	self->priv->_wikitree = _tmp0_;
}

/**
 * Returns a list of C source files.
 *
 * @return list of C source files
 */
static gpointer
_bala_iterable_ref0 (gpointer self)
{
	return self ? bala_iterable_ref (self) : NULL;
}

BalaCollection*
baladoc_api_tree_get_external_c_files (BaladocApiTree* self)
{
	BalaArrayList* _tmp0_;
	BalaCollection* _tmp1_;
	BalaCollection* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->external_c_files;
	_tmp1_ = _bala_iterable_ref0 ((BalaCollection*) _tmp0_);
	result = _tmp1_;
	return result;
}

void
baladoc_api_tree_add_external_c_files (BaladocApiTree* self,
                                       const gchar* name)
{
	BalaArrayList* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	_tmp0_ = self->priv->external_c_files;
	bala_collection_add ((BalaCollection*) _tmp0_, name);
}

/**
 * Returns a list of all packages in the tree
 *
 * @return list of all packages
 */
BalaCollection*
baladoc_api_tree_get_package_list (BaladocApiTree* self)
{
	BalaArrayList* _tmp0_;
	BalaCollection* _tmp1_;
	BalaCollection* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->packages;
	_tmp1_ = _bala_iterable_ref0 ((BalaCollection*) _tmp0_);
	result = _tmp1_;
	return result;
}

static void
baladoc_api_tree_add_dependencies_to_source_package (BaladocApiTree* self)
{
	BaladocApiPackage* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->source_package;
	if (_tmp0_ != NULL) {
		BalaArrayList* deplst = NULL;
		GEqualFunc _tmp1_;
		BalaArrayList* _tmp2_;
		BaladocApiPackage* _tmp16_;
		BalaArrayList* _tmp17_;
		_tmp1_ = g_direct_equal;
		_tmp2_ = bala_array_list_new (BALADOC_API_TYPE_PACKAGE, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, _tmp1_);
		deplst = _tmp2_;
		{
			BalaArrayList* _pkg_list = NULL;
			BalaArrayList* _tmp3_;
			BalaArrayList* _tmp4_;
			gint _pkg_size = 0;
			BalaArrayList* _tmp5_;
			gint _tmp6_;
			gint _tmp7_;
			gint _pkg_index = 0;
			_tmp3_ = self->priv->packages;
			_tmp4_ = _bala_iterable_ref0 (_tmp3_);
			_pkg_list = _tmp4_;
			_tmp5_ = _pkg_list;
			_tmp6_ = bala_collection_get_size ((BalaCollection*) _tmp5_);
			_tmp7_ = _tmp6_;
			_pkg_size = _tmp7_;
			_pkg_index = -1;
			while (TRUE) {
				gint _tmp8_;
				gint _tmp9_;
				BaladocApiPackage* pkg = NULL;
				BalaArrayList* _tmp10_;
				gpointer _tmp11_;
				BaladocApiPackage* _tmp12_;
				BaladocApiPackage* _tmp13_;
				_pkg_index = _pkg_index + 1;
				_tmp8_ = _pkg_index;
				_tmp9_ = _pkg_size;
				if (!(_tmp8_ < _tmp9_)) {
					break;
				}
				_tmp10_ = _pkg_list;
				_tmp11_ = bala_list_get ((BalaList*) _tmp10_, _pkg_index);
				pkg = (BaladocApiPackage*) _tmp11_;
				_tmp12_ = pkg;
				_tmp13_ = self->priv->source_package;
				if (_tmp12_ != _tmp13_) {
					BalaArrayList* _tmp14_;
					BaladocApiPackage* _tmp15_;
					_tmp14_ = deplst;
					_tmp15_ = pkg;
					bala_collection_add ((BalaCollection*) _tmp14_, _tmp15_);
				}
				_g_object_unref0 (pkg);
			}
			_bala_iterable_unref0 (_pkg_list);
		}
		_tmp16_ = self->priv->source_package;
		_tmp17_ = deplst;
		baladoc_api_package_set_dependency_list (_tmp16_, _tmp17_);
		_bala_iterable_unref0 (deplst);
	}
}

/**
 * Visits this node with the specified Visitor.
 *
 * @param visitor the visitor to be called while traversing
 */
void
baladoc_api_tree_accept (BaladocApiTree* self,
                         BaladocApiVisitor* visitor)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (visitor != NULL);
	baladoc_api_visitor_visit_tree (visitor, self);
}

/**
 * Visits all children of this node with the given types with the specified Visitor.
 *
 * @param visitor the visitor to be called while traversing
 */
void
baladoc_api_tree_accept_children (BaladocApiTree* self,
                                  BaladocApiVisitor* visitor)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (visitor != NULL);
	{
		BalaArrayList* _node_list = NULL;
		BalaArrayList* _tmp0_;
		BalaArrayList* _tmp1_;
		gint _node_size = 0;
		BalaArrayList* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		gint _node_index = 0;
		_tmp0_ = self->priv->packages;
		_tmp1_ = _bala_iterable_ref0 (_tmp0_);
		_node_list = _tmp1_;
		_tmp2_ = _node_list;
		_tmp3_ = bala_collection_get_size ((BalaCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_node_size = _tmp4_;
		_node_index = -1;
		while (TRUE) {
			gint _tmp5_;
			gint _tmp6_;
			BaladocApiNode* node = NULL;
			BalaArrayList* _tmp7_;
			gpointer _tmp8_;
			BaladocApiNode* _tmp9_;
			_node_index = _node_index + 1;
			_tmp5_ = _node_index;
			_tmp6_ = _node_size;
			if (!(_tmp5_ < _tmp6_)) {
				break;
			}
			_tmp7_ = _node_list;
			_tmp8_ = bala_list_get ((BalaList*) _tmp7_, _node_index);
			node = (BaladocApiNode*) ((BaladocApiPackage*) _tmp8_);
			_tmp9_ = node;
			baladoc_api_node_accept (_tmp9_, visitor);
			_g_object_unref0 (node);
		}
		_bala_iterable_unref0 (_node_list);
	}
}

static BaladocApiNode*
baladoc_api_tree_search_relative_to (BaladocApiTree* self,
                                     BaladocApiNode* element,
                                     gchar** path,
                                     gint path_length1)
{
	BaladocApiNode* node = NULL;
	BaladocApiNode* _tmp0_;
	gboolean _tmp6_ = FALSE;
	BaladocApiNode* _tmp7_;
	BaladocApiNode* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (element != NULL, NULL);
	_tmp0_ = _g_object_ref0 (element);
	node = _tmp0_;
	{
		gchar** name_collection = NULL;
		gint name_collection_length1 = 0;
		gint _name_collection_size_ = 0;
		gint name_it = 0;
		name_collection = path;
		name_collection_length1 = path_length1;
		for (name_it = 0; name_it < name_collection_length1; name_it = name_it + 1) {
			gchar* _tmp1_;
			gchar* name = NULL;
			_tmp1_ = g_strdup (name_collection[name_it]);
			name = _tmp1_;
			{
				BaladocApiNode* _tmp2_;
				const gchar* _tmp3_;
				BaladocApiNode* _tmp4_;
				BaladocApiNode* _tmp5_;
				_tmp2_ = node;
				_tmp3_ = name;
				_tmp4_ = baladoc_api_node_find_by_name (_tmp2_, _tmp3_);
				_g_object_unref0 (node);
				node = _tmp4_;
				_tmp5_ = node;
				if (_tmp5_ == NULL) {
					_g_free0 (name);
					break;
				}
				_g_free0 (name);
			}
		}
	}
	_tmp7_ = node;
	if (_tmp7_ == NULL) {
		BaladocApiItem* _tmp8_;
		BaladocApiItem* _tmp9_;
		_tmp8_ = baladoc_api_item_get_parent ((BaladocApiItem*) element);
		_tmp9_ = _tmp8_;
		_tmp6_ = _tmp9_ != NULL;
	} else {
		_tmp6_ = FALSE;
	}
	if (_tmp6_) {
		BaladocApiItem* _tmp10_;
		BaladocApiItem* _tmp11_;
		BaladocApiNode* _tmp12_;
		_tmp10_ = baladoc_api_item_get_parent ((BaladocApiItem*) element);
		_tmp11_ = _tmp10_;
		_tmp12_ = baladoc_api_tree_search_relative_to (self, G_TYPE_CHECK_INSTANCE_CAST (_tmp11_, BALADOC_API_TYPE_NODE, BaladocApiNode), path, (gint) path_length1);
		_g_object_unref0 (node);
		node = _tmp12_;
	}
	result = node;
	return result;
}

BaladocApiNode*
baladoc_api_tree_search_symbol_path (BaladocApiTree* self,
                                     BaladocApiNode* element,
                                     gchar** path,
                                     gint path_length1)
{
	BaladocApiNode* node = NULL;
	BaladocApiNode* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	node = NULL;
	if (element != NULL) {
		BaladocApiNode* _tmp0_;
		BaladocApiNode* _tmp1_;
		_tmp0_ = baladoc_api_tree_search_relative_to (self, element, path, (gint) path_length1);
		_g_object_unref0 (node);
		node = _tmp0_;
		_tmp1_ = node;
		if (_tmp1_ != NULL) {
			result = node;
			return result;
		}
	}
	{
		BalaArrayList* _package_list = NULL;
		BalaArrayList* _tmp2_;
		BalaArrayList* _tmp3_;
		gint _package_size = 0;
		BalaArrayList* _tmp4_;
		gint _tmp5_;
		gint _tmp6_;
		gint _package_index = 0;
		_tmp2_ = self->priv->packages;
		_tmp3_ = _bala_iterable_ref0 (_tmp2_);
		_package_list = _tmp3_;
		_tmp4_ = _package_list;
		_tmp5_ = bala_collection_get_size ((BalaCollection*) _tmp4_);
		_tmp6_ = _tmp5_;
		_package_size = _tmp6_;
		_package_index = -1;
		while (TRUE) {
			gint _tmp7_;
			gint _tmp8_;
			BaladocApiPackage* package = NULL;
			BalaArrayList* _tmp9_;
			gpointer _tmp10_;
			BaladocApiNode* global = NULL;
			BaladocApiPackage* _tmp11_;
			BaladocApiNode* _tmp12_;
			BaladocApiNode* _tmp13_;
			_package_index = _package_index + 1;
			_tmp7_ = _package_index;
			_tmp8_ = _package_size;
			if (!(_tmp7_ < _tmp8_)) {
				break;
			}
			_tmp9_ = _package_list;
			_tmp10_ = bala_list_get ((BalaList*) _tmp9_, _package_index);
			package = (BaladocApiPackage*) _tmp10_;
			_tmp11_ = package;
			_tmp12_ = baladoc_api_node_find_by_name ((BaladocApiNode*) _tmp11_, "");
			global = _tmp12_;
			_tmp13_ = global;
			if (_tmp13_ != NULL) {
				BaladocApiNode* _tmp14_;
				BaladocApiNode* _tmp15_;
				BaladocApiNode* _tmp16_;
				_tmp14_ = global;
				_tmp15_ = baladoc_api_tree_search_relative_to (self, _tmp14_, path, (gint) path_length1);
				_g_object_unref0 (node);
				node = _tmp15_;
				_tmp16_ = node;
				if (_tmp16_ != NULL) {
					result = node;
					_g_object_unref0 (global);
					_g_object_unref0 (package);
					_bala_iterable_unref0 (_package_list);
					return result;
				}
			}
			_g_object_unref0 (global);
			_g_object_unref0 (package);
		}
		_bala_iterable_unref0 (_package_list);
	}
	result = NULL;
	_g_object_unref0 (node);
	return result;
}

BaladocApiTypeSymbol*
baladoc_api_tree_search_symbol_type_cstr (BaladocApiTree* self,
                                          const gchar* cname)
{
	BaladocCTypeResolver* _tmp0_;
	BaladocCTypeResolver* _tmp2_;
	BaladocApiTypeSymbol* _tmp3_;
	BaladocApiTypeSymbol* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (cname != NULL, NULL);
	_tmp0_ = self->priv->_cresolver;
	if (_tmp0_ == NULL) {
		BaladocCTypeResolver* _tmp1_;
		_tmp1_ = baladoc_ctype_resolver_new (self);
		_g_object_unref0 (self->priv->_cresolver);
		self->priv->_cresolver = _tmp1_;
	}
	_tmp2_ = self->priv->_cresolver;
	_tmp3_ = baladoc_ctype_resolver_resolve_symbol_type (_tmp2_, cname);
	result = _tmp3_;
	return result;
}

BaladocApiNode*
baladoc_api_tree_search_symbol_cstr (BaladocApiTree* self,
                                     BaladocApiNode* element,
                                     const gchar* cname)
{
	BaladocCTypeResolver* _tmp0_;
	BaladocCTypeResolver* _tmp2_;
	BaladocApiNode* _tmp3_;
	BaladocApiNode* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (cname != NULL, NULL);
	_tmp0_ = self->priv->_cresolver;
	if (_tmp0_ == NULL) {
		BaladocCTypeResolver* _tmp1_;
		_tmp1_ = baladoc_ctype_resolver_new (self);
		_g_object_unref0 (self->priv->_cresolver);
		self->priv->_cresolver = _tmp1_;
	}
	_tmp2_ = self->priv->_cresolver;
	_tmp3_ = baladoc_ctype_resolver_resolve_symbol (_tmp2_, element, cname);
	result = _tmp3_;
	return result;
}

BaladocApiNode*
baladoc_api_tree_search_symbol_str (BaladocApiTree* self,
                                    BaladocApiNode* element,
                                    const gchar* symname)
{
	gchar** path = NULL;
	gint _tmp0_ = 0;
	gchar** _tmp1_;
	gint path_length1;
	gint _path_size_;
	BaladocApiNode* node = NULL;
	gchar** _tmp2_;
	gint _tmp2__length1;
	BaladocApiNode* _tmp3_;
	BaladocApiNode* _tmp4_;
	gboolean _tmp5_ = FALSE;
	gchar** _tmp6_;
	gint _tmp6__length1;
	BaladocApiNode* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (symname != NULL, NULL);
	_tmp1_ = baladoc_api_tree_split_name (self, symname, &_tmp0_);
	path = _tmp1_;
	path_length1 = _tmp0_;
	_path_size_ = path_length1;
	_tmp2_ = path;
	_tmp2__length1 = path_length1;
	_tmp3_ = baladoc_api_tree_search_symbol_path (self, element, _tmp2_, (gint) _tmp2__length1);
	node = _tmp3_;
	_tmp4_ = node;
	if (_tmp4_ != NULL) {
		result = node;
		path = (_bala_array_free (path, path_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	_tmp6_ = path;
	_tmp6__length1 = path_length1;
	if (_tmp6__length1 >= 2) {
		gchar** _tmp7_;
		gint _tmp7__length1;
		gchar** _tmp8_;
		gint _tmp8__length1;
		const gchar* _tmp9_;
		gchar** _tmp10_;
		gint _tmp10__length1;
		gchar** _tmp11_;
		gint _tmp11__length1;
		const gchar* _tmp12_;
		_tmp7_ = path;
		_tmp7__length1 = path_length1;
		_tmp8_ = path;
		_tmp8__length1 = path_length1;
		_tmp9_ = _tmp7_[_tmp8__length1 - 2];
		_tmp10_ = path;
		_tmp10__length1 = path_length1;
		_tmp11_ = path;
		_tmp11__length1 = path_length1;
		_tmp12_ = _tmp10_[_tmp11__length1 - 2];
		_tmp5_ = g_strcmp0 (_tmp9_, _tmp12_) == 0;
	} else {
		_tmp5_ = FALSE;
	}
	if (_tmp5_) {
		gchar** _tmp13_;
		gint _tmp13__length1;
		gchar** _tmp14_;
		gint _tmp14__length1;
		gchar** _tmp15_;
		gint _tmp15__length1;
		gchar** _tmp16_;
		gint _tmp16__length1;
		const gchar* _tmp17_;
		gchar* _tmp18_;
		gchar* _tmp19_;
		gchar** _tmp20_;
		gint _tmp20__length1;
		gchar** _tmp21_;
		gint _tmp21__length1;
		const gchar* _tmp22_;
		gchar* _tmp23_;
		gchar** _tmp24_;
		gint _tmp24__length1;
		gint _tmp25_;
		gchar** _tmp26_;
		gint _tmp26__length1;
		BaladocApiNode* _tmp27_;
		_tmp13_ = path;
		_tmp13__length1 = path_length1;
		_tmp14_ = path;
		_tmp14__length1 = path_length1;
		_tmp15_ = path;
		_tmp15__length1 = path_length1;
		_tmp16_ = path;
		_tmp16__length1 = path_length1;
		_tmp17_ = _tmp15_[_tmp16__length1 - 2];
		_tmp18_ = g_strconcat (_tmp17_, ".", NULL);
		_tmp19_ = _tmp18_;
		_tmp20_ = path;
		_tmp20__length1 = path_length1;
		_tmp21_ = path;
		_tmp21__length1 = path_length1;
		_tmp22_ = _tmp20_[_tmp21__length1 - 1];
		_tmp23_ = g_strconcat (_tmp19_, _tmp22_, NULL);
		_g_free0 (_tmp13_[_tmp14__length1 - 2]);
		_tmp13_[_tmp14__length1 - 2] = _tmp23_;
		_g_free0 (_tmp19_);
		_tmp24_ = path;
		_tmp24__length1 = path_length1;
		_tmp25_ = _tmp24__length1 - 1;
		path = g_renew (gchar*, path, _tmp24__length1 - 1);
		(_tmp25_ > path_length1) ? memset (path + path_length1, 0, sizeof (gchar*) * (_tmp25_ - path_length1)) : NULL;
		path_length1 = _tmp25_;
		_path_size_ = _tmp25_;
		_tmp26_ = path;
		_tmp26__length1 = path_length1;
		_tmp27_ = baladoc_api_tree_search_symbol_path (self, element, _tmp26_, (gint) _tmp26__length1);
		result = _tmp27_;
		_g_object_unref0 (node);
		path = (_bala_array_free (path, path_length1, (GDestroyNotify) g_free), NULL);
		return result;
	}
	result = NULL;
	_g_object_unref0 (node);
	path = (_bala_array_free (path, path_length1, (GDestroyNotify) g_free), NULL);
	return result;
}

static gchar**
baladoc_api_tree_split_name (BaladocApiTree* self,
                             const gchar* full_name,
                             gint* result_length1)
{
	gchar** params = NULL;
	gchar** _tmp0_;
	gchar** _tmp1_;
	gint params_length1;
	gint _params_size_;
	gint i = 0;
	gchar** _tmp5_;
	gint _tmp5__length1;
	gchar** result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (full_name != NULL, NULL);
	_tmp1_ = _tmp0_ = g_strsplit (full_name, ".", -1);
	params = _tmp1_;
	params_length1 = _bala_array_length (_tmp0_);
	_params_size_ = params_length1;
	i = 0;
	while (TRUE) {
		gchar** _tmp2_;
		gint _tmp2__length1;
		const gchar* _tmp3_;
		gint _tmp4_;
		_tmp2_ = params;
		_tmp2__length1 = params_length1;
		_tmp3_ = _tmp2_[i];
		if (!(_tmp3_ != NULL)) {
			break;
		}
		_tmp4_ = i;
		i = _tmp4_ + 1;
	}
	params_length1 = i;
	_tmp5_ = params;
	_tmp5__length1 = params_length1;
	if (result_length1) {
		*result_length1 = _tmp5__length1;
	}
	result = _tmp5_;
	return result;
}

BaladocApiTree*
baladoc_api_tree_construct (GType object_type,
                            BaladocErrorReporter* reporter,
                            BaladocSettings* settings,
                            BalaCodeContext* context)
{
	BaladocApiTree* self = NULL;
	BaladocSettings* _tmp0_;
	BaladocErrorReporter* _tmp1_;
	g_return_val_if_fail (reporter != NULL, NULL);
	g_return_val_if_fail (settings != NULL, NULL);
	g_return_val_if_fail (context != NULL, NULL);
	self = (BaladocApiTree*) g_type_create_instance (object_type);
	_tmp0_ = _g_object_ref0 (settings);
	_g_object_unref0 (self->priv->settings);
	self->priv->settings = _tmp0_;
	_tmp1_ = _g_object_ref0 (reporter);
	_g_object_unref0 (self->priv->reporter);
	self->priv->reporter = _tmp1_;
	baladoc_api_tree_set_context (self, context);
	return self;
}

BaladocApiTree*
baladoc_api_tree_new (BaladocErrorReporter* reporter,
                      BaladocSettings* settings,
                      BalaCodeContext* context)
{
	return baladoc_api_tree_construct (BALADOC_API_TYPE_TREE, reporter, settings, context);
}

static gchar*
baladoc_api_tree_get_file_path (BaladocApiTree* self,
                                const gchar* basename,
                                gchar** directories,
                                gint directories_length1)
{
	gchar* filename = NULL;
	gchar** _tmp4_;
	gchar** _tmp5_;
	gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (basename != NULL, NULL);
	filename = NULL;
	if (directories != NULL) {
		{
			gchar** dir_collection = NULL;
			gint dir_collection_length1 = 0;
			gint _dir_collection_size_ = 0;
			gint dir_it = 0;
			dir_collection = directories;
			dir_collection_length1 = directories_length1;
			for (dir_it = 0; dir_it < dir_collection_length1; dir_it = dir_it + 1) {
				gchar* _tmp0_;
				gchar* dir = NULL;
				_tmp0_ = g_strdup (dir_collection[dir_it]);
				dir = _tmp0_;
				{
					const gchar* _tmp1_;
					gchar* _tmp2_;
					const gchar* _tmp3_;
					_tmp1_ = dir;
					_tmp2_ = g_build_filename (_tmp1_, basename, NULL);
					_g_free0 (filename);
					filename = _tmp2_;
					_tmp3_ = filename;
					if (g_file_test (_tmp3_, G_FILE_TEST_EXISTS)) {
						result = filename;
						_g_free0 (dir);
						return result;
					}
					_g_free0 (dir);
				}
			}
		}
	}
	_tmp5_ = _tmp4_ = g_get_system_data_dirs ();
	{
		gchar** dir_collection = NULL;
		gint dir_collection_length1 = 0;
		gint _dir_collection_size_ = 0;
		gint dir_it = 0;
		dir_collection = _tmp5_;
		dir_collection_length1 = _bala_array_length (_tmp4_);
		for (dir_it = 0; dir_it < dir_collection_length1; dir_it = dir_it + 1) {
			gchar* _tmp6_;
			gchar* dir = NULL;
			_tmp6_ = g_strdup (dir_collection[dir_it]);
			dir = _tmp6_;
			{
				const gchar* _tmp7_;
				gchar* _tmp8_;
				const gchar* _tmp9_;
				_tmp7_ = dir;
				_tmp8_ = g_build_filename (_tmp7_, basename, NULL);
				_g_free0 (filename);
				filename = _tmp8_;
				_tmp9_ = filename;
				if (g_file_test (_tmp9_, G_FILE_TEST_EXISTS)) {
					result = filename;
					_g_free0 (dir);
					return result;
				}
				_g_free0 (dir);
			}
		}
	}
	result = NULL;
	_g_free0 (filename);
	return result;
}

gboolean
baladoc_api_tree_create_tree (BaladocApiTree* self)
{
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	baladoc_api_tree_add_dependencies_to_source_package (self);
	result = TRUE;
	return result;
}

static BaladocApiPackage*
baladoc_api_tree_get_source_package (BaladocApiTree* self)
{
	BaladocApiPackage* _tmp0_;
	BaladocApiPackage* _tmp15_;
	BaladocApiPackage* _tmp16_;
	BaladocApiPackage* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_source_package;
	if (_tmp0_ == NULL) {
		{
			BalaArrayList* _pkg_list = NULL;
			BalaArrayList* _tmp1_;
			BalaArrayList* _tmp2_;
			gint _pkg_size = 0;
			BalaArrayList* _tmp3_;
			gint _tmp4_;
			gint _tmp5_;
			gint _pkg_index = 0;
			_tmp1_ = self->priv->packages;
			_tmp2_ = _bala_iterable_ref0 (_tmp1_);
			_pkg_list = _tmp2_;
			_tmp3_ = _pkg_list;
			_tmp4_ = bala_collection_get_size ((BalaCollection*) _tmp3_);
			_tmp5_ = _tmp4_;
			_pkg_size = _tmp5_;
			_pkg_index = -1;
			while (TRUE) {
				gint _tmp6_;
				gint _tmp7_;
				BaladocApiPackage* pkg = NULL;
				BalaArrayList* _tmp8_;
				gpointer _tmp9_;
				BaladocApiPackage* _tmp10_;
				gboolean _tmp11_;
				gboolean _tmp12_;
				_pkg_index = _pkg_index + 1;
				_tmp6_ = _pkg_index;
				_tmp7_ = _pkg_size;
				if (!(_tmp6_ < _tmp7_)) {
					break;
				}
				_tmp8_ = _pkg_list;
				_tmp9_ = bala_list_get ((BalaList*) _tmp8_, _pkg_index);
				pkg = (BaladocApiPackage*) _tmp9_;
				_tmp10_ = pkg;
				_tmp11_ = baladoc_api_package_get_is_package (_tmp10_);
				_tmp12_ = _tmp11_;
				if (!_tmp12_) {
					BaladocApiPackage* _tmp13_;
					BaladocApiPackage* _tmp14_;
					_tmp13_ = pkg;
					_tmp14_ = _g_object_ref0 (_tmp13_);
					_g_object_unref0 (self->priv->_source_package);
					self->priv->_source_package = _tmp14_;
					_g_object_unref0 (pkg);
					break;
				}
				_g_object_unref0 (pkg);
			}
			_bala_iterable_unref0 (_pkg_list);
		}
	}
	_tmp15_ = self->priv->_source_package;
	_tmp16_ = _g_object_ref0 (_tmp15_);
	result = _tmp16_;
	return result;
}

static void
baladoc_api_tree_parse_wiki (BaladocApiTree* self,
                             BaladocDocumentationParser* docparser)
{
	BaladocWikiPageTree* _tmp0_;
	BaladocWikiPageTree* _tmp1_;
	BaladocApiPackage* pkg = NULL;
	BaladocApiPackage* _tmp2_;
	BaladocApiPackage* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (docparser != NULL);
	_tmp0_ = baladoc_wiki_page_tree_new ();
	_tmp1_ = _tmp0_;
	baladoc_api_tree_set_wikitree (self, _tmp1_);
	_g_object_unref0 (_tmp1_);
	_tmp2_ = baladoc_api_tree_get_source_package (self);
	pkg = _tmp2_;
	_tmp3_ = pkg;
	if (_tmp3_ != NULL) {
		BaladocWikiPageTree* _tmp4_;
		BaladocSettings* _tmp5_;
		BaladocApiPackage* _tmp6_;
		BaladocErrorReporter* _tmp7_;
		_tmp4_ = self->priv->_wikitree;
		_tmp5_ = self->priv->settings;
		_tmp6_ = pkg;
		_tmp7_ = self->priv->reporter;
		baladoc_wiki_page_tree_parse (_tmp4_, _tmp5_, docparser, _tmp6_, _tmp7_);
	}
	_g_object_unref0 (pkg);
}

static void
baladoc_api_tree_check_wiki (BaladocApiTree* self,
                             BaladocDocumentationParser* docparser)
{
	BaladocApiPackage* pkg = NULL;
	BaladocApiPackage* _tmp0_;
	BaladocApiPackage* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (docparser != NULL);
	_tmp0_ = baladoc_api_tree_get_source_package (self);
	pkg = _tmp0_;
	_tmp1_ = pkg;
	if (_tmp1_ != NULL) {
		BaladocWikiPageTree* _tmp2_;
		BaladocSettings* _tmp3_;
		BaladocApiPackage* _tmp4_;
		_tmp2_ = self->priv->_wikitree;
		_tmp3_ = self->priv->settings;
		_tmp4_ = pkg;
		baladoc_wiki_page_tree_check (_tmp2_, _tmp3_, docparser, _tmp4_);
	}
	_g_object_unref0 (pkg);
}

void
baladoc_api_tree_parse_comments (BaladocApiTree* self,
                                 BaladocDocumentationParser* docparser)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (docparser != NULL);
	baladoc_api_tree_parse_wiki (self, docparser);
	{
		BalaArrayList* _pkg_list = NULL;
		BalaArrayList* _tmp0_;
		BalaArrayList* _tmp1_;
		gint _pkg_size = 0;
		BalaArrayList* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		gint _pkg_index = 0;
		_tmp0_ = self->priv->packages;
		_tmp1_ = _bala_iterable_ref0 (_tmp0_);
		_pkg_list = _tmp1_;
		_tmp2_ = _pkg_list;
		_tmp3_ = bala_collection_get_size ((BalaCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_pkg_size = _tmp4_;
		_pkg_index = -1;
		while (TRUE) {
			gint _tmp5_;
			gint _tmp6_;
			BaladocApiPackage* pkg = NULL;
			BalaArrayList* _tmp7_;
			gpointer _tmp8_;
			BaladocApiPackage* _tmp9_;
			BaladocSettings* _tmp10_;
			_pkg_index = _pkg_index + 1;
			_tmp5_ = _pkg_index;
			_tmp6_ = _pkg_size;
			if (!(_tmp5_ < _tmp6_)) {
				break;
			}
			_tmp7_ = _pkg_list;
			_tmp8_ = bala_list_get ((BalaList*) _tmp7_, _pkg_index);
			pkg = (BaladocApiPackage*) _tmp8_;
			_tmp9_ = pkg;
			_tmp10_ = self->priv->settings;
			if (baladoc_api_node_is_browsable ((BaladocApiNode*) _tmp9_, _tmp10_)) {
				BaladocApiPackage* _tmp11_;
				BaladocSettings* _tmp12_;
				_tmp11_ = pkg;
				_tmp12_ = self->priv->settings;
				baladoc_api_item_parse_comments ((BaladocApiItem*) _tmp11_, _tmp12_, docparser);
			}
			_g_object_unref0 (pkg);
		}
		_bala_iterable_unref0 (_pkg_list);
	}
}

void
baladoc_api_tree_check_comments (BaladocApiTree* self,
                                 BaladocDocumentationParser* docparser)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (docparser != NULL);
	baladoc_api_tree_check_wiki (self, docparser);
	{
		BalaArrayList* _pkg_list = NULL;
		BalaArrayList* _tmp0_;
		BalaArrayList* _tmp1_;
		gint _pkg_size = 0;
		BalaArrayList* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		gint _pkg_index = 0;
		_tmp0_ = self->priv->packages;
		_tmp1_ = _bala_iterable_ref0 (_tmp0_);
		_pkg_list = _tmp1_;
		_tmp2_ = _pkg_list;
		_tmp3_ = bala_collection_get_size ((BalaCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_pkg_size = _tmp4_;
		_pkg_index = -1;
		while (TRUE) {
			gint _tmp5_;
			gint _tmp6_;
			BaladocApiPackage* pkg = NULL;
			BalaArrayList* _tmp7_;
			gpointer _tmp8_;
			BaladocApiPackage* _tmp9_;
			BaladocSettings* _tmp10_;
			_pkg_index = _pkg_index + 1;
			_tmp5_ = _pkg_index;
			_tmp6_ = _pkg_size;
			if (!(_tmp5_ < _tmp6_)) {
				break;
			}
			_tmp7_ = _pkg_list;
			_tmp8_ = bala_list_get ((BalaList*) _tmp7_, _pkg_index);
			pkg = (BaladocApiPackage*) _tmp8_;
			_tmp9_ = pkg;
			_tmp10_ = self->priv->settings;
			if (baladoc_api_node_is_browsable ((BaladocApiNode*) _tmp9_, _tmp10_)) {
				BaladocApiPackage* _tmp11_;
				BaladocSettings* _tmp12_;
				_tmp11_ = pkg;
				_tmp12_ = self->priv->settings;
				baladoc_api_item_check_comments ((BaladocApiItem*) _tmp11_, _tmp12_, docparser);
				baladoc_api_tree_postprocess_inheritdoc (self, docparser);
			}
			_g_object_unref0 (pkg);
		}
		_bala_iterable_unref0 (_pkg_list);
	}
}

G_GNUC_INTERNAL void
baladoc_api_tree_register_inheritdoc (BaladocApiTree* self,
                                      BaladocApiNode* container,
                                      BaladocTagletsInheritDoc* taglet)
{
	BalaList* _tmp0_;
	BaladocApiTreeInheritDocContainer* _tmp1_;
	BaladocApiTreeInheritDocContainer* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (container != NULL);
	g_return_if_fail (taglet != NULL);
	_tmp0_ = self->priv->inheritdocs;
	_tmp1_ = baladoc_api_tree_inherit_doc_container_new (container, taglet);
	_tmp2_ = _tmp1_;
	bala_collection_add ((BalaCollection*) _tmp0_, _tmp2_);
	_baladoc_api_tree_inherit_doc_container_unref0 (_tmp2_);
}

static void
baladoc_api_tree_postprocess_inheritdoc (BaladocApiTree* self,
                                         BaladocDocumentationParser* docparser)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (docparser != NULL);
	while (TRUE) {
		BalaList* _tmp0_;
		gboolean _tmp1_;
		gboolean _tmp2_;
		BaladocApiTreeInheritDocContainer* container = NULL;
		BalaList* _tmp3_;
		gpointer _tmp4_;
		BaladocApiTreeInheritDocContainer* _tmp5_;
		BaladocApiNode* _tmp6_;
		BaladocApiTreeInheritDocContainer* _tmp7_;
		BaladocTagletsInheritDoc* _tmp8_;
		_tmp0_ = self->priv->inheritdocs;
		_tmp1_ = bala_collection_get_is_empty ((BalaCollection*) _tmp0_);
		_tmp2_ = _tmp1_;
		if (!(!_tmp2_)) {
			break;
		}
		_tmp3_ = self->priv->inheritdocs;
		_tmp4_ = bala_list_remove_at (_tmp3_, 0);
		container = (BaladocApiTreeInheritDocContainer*) _tmp4_;
		_tmp5_ = container;
		_tmp6_ = _tmp5_->taglet_container;
		_tmp7_ = container;
		_tmp8_ = _tmp7_->taglet;
		baladoc_documentation_parser_transform_inheritdoc (docparser, _tmp6_, _tmp8_);
		_baladoc_api_tree_inherit_doc_container_unref0 (container);
	}
}

/**
 * Import documentation from various sources
 *
 * @param importers a list of importers
 * @param packages sources
 * @param import_directories List of directories where to find the files
 */
void
baladoc_api_tree_import_comments (BaladocApiTree* self,
                                  BaladocImporterDocumentationImporter** importers,
                                  gint importers_length1,
                                  gchar** packages,
                                  gint packages_length1,
                                  gchar** import_directories,
                                  gint import_directories_length1)
{
	BalaHashSet* processed = NULL;
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	BalaHashSet* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_direct_hash;
	_tmp1_ = g_direct_equal;
	_tmp2_ = bala_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, _tmp0_, _tmp1_);
	processed = _tmp2_;
	{
		gchar** pkg_name_collection = NULL;
		gint pkg_name_collection_length1 = 0;
		gint _pkg_name_collection_size_ = 0;
		gint pkg_name_it = 0;
		pkg_name_collection = packages;
		pkg_name_collection_length1 = packages_length1;
		for (pkg_name_it = 0; pkg_name_it < pkg_name_collection_length1; pkg_name_it = pkg_name_it + 1) {
			gchar* _tmp3_;
			gchar* pkg_name = NULL;
			_tmp3_ = g_strdup (pkg_name_collection[pkg_name_it]);
			pkg_name = _tmp3_;
			{
				gboolean imported = FALSE;
				imported = FALSE;
				{
					BaladocImporterDocumentationImporter** importer_collection = NULL;
					gint importer_collection_length1 = 0;
					gint _importer_collection_size_ = 0;
					gint importer_it = 0;
					importer_collection = importers;
					importer_collection_length1 = importers_length1;
					for (importer_it = 0; importer_it < importer_collection_length1; importer_it = importer_it + 1) {
						BaladocImporterDocumentationImporter* _tmp4_;
						BaladocImporterDocumentationImporter* importer = NULL;
						_tmp4_ = _g_object_ref0 (importer_collection[importer_it]);
						importer = _tmp4_;
						{
							gchar* path = NULL;
							const gchar* _tmp5_;
							BaladocImporterDocumentationImporter* _tmp6_;
							const gchar* _tmp7_;
							const gchar* _tmp8_;
							gchar* _tmp9_;
							gchar* _tmp10_;
							gchar* _tmp11_;
							gchar* _tmp12_;
							const gchar* _tmp13_;
							const gchar* _tmp14_;
							gchar* _tmp15_;
							BalaHashSet* _tmp16_;
							const gchar* _tmp17_;
							_tmp5_ = pkg_name;
							_tmp6_ = importer;
							_tmp7_ = baladoc_importer_documentation_importer_get_file_extension (_tmp6_);
							_tmp8_ = _tmp7_;
							_tmp9_ = g_strdup_printf ("%s.%s", _tmp5_, _tmp8_);
							_tmp10_ = _tmp9_;
							_tmp11_ = baladoc_api_tree_get_file_path (self, _tmp10_, import_directories, (gint) import_directories_length1);
							_tmp12_ = _tmp11_;
							_g_free0 (_tmp10_);
							path = _tmp12_;
							_tmp13_ = path;
							if (_tmp13_ == NULL) {
								_g_free0 (path);
								_g_object_unref0 (importer);
								continue;
							}
							_tmp14_ = path;
							_tmp15_ = bala_code_context_realpath (_tmp14_);
							_g_free0 (path);
							path = _tmp15_;
							imported = TRUE;
							_tmp16_ = processed;
							_tmp17_ = path;
							if (!bala_collection_contains ((BalaCollection*) _tmp16_, _tmp17_)) {
								BaladocImporterDocumentationImporter* _tmp18_;
								const gchar* _tmp19_;
								BalaHashSet* _tmp20_;
								const gchar* _tmp21_;
								_tmp18_ = importer;
								_tmp19_ = path;
								baladoc_importer_documentation_importer_process (_tmp18_, _tmp19_);
								_tmp20_ = processed;
								_tmp21_ = path;
								bala_collection_add ((BalaCollection*) _tmp20_, _tmp21_);
							}
							_g_free0 (path);
							_g_object_unref0 (importer);
						}
					}
				}
				if (imported == FALSE) {
					BaladocErrorReporter* _tmp22_;
					const gchar* _tmp23_;
					_tmp22_ = self->priv->reporter;
					_tmp23_ = pkg_name;
					baladoc_error_reporter_simple_error (_tmp22_, NULL, "'%s' not found in specified import directories", _tmp23_);
				}
				_g_free0 (pkg_name);
			}
		}
	}
	_bala_iterable_unref0 (processed);
}

static BaladocApiTreeInheritDocContainer*
baladoc_api_tree_inherit_doc_container_construct (GType object_type,
                                                  BaladocApiNode* taglet_container,
                                                  BaladocTagletsInheritDoc* taglet)
{
	BaladocApiTreeInheritDocContainer* self = NULL;
	g_return_val_if_fail (taglet_container != NULL, NULL);
	g_return_val_if_fail (taglet != NULL, NULL);
	self = (BaladocApiTreeInheritDocContainer*) g_type_create_instance (object_type);
	self->taglet_container = taglet_container;
	self->taglet = taglet;
	return self;
}

static BaladocApiTreeInheritDocContainer*
baladoc_api_tree_inherit_doc_container_new (BaladocApiNode* taglet_container,
                                            BaladocTagletsInheritDoc* taglet)
{
	return baladoc_api_tree_inherit_doc_container_construct (BALADOC_API_TREE_TYPE_INHERIT_DOC_CONTAINER, taglet_container, taglet);
}

static void
baladoc_api_tree_value_inherit_doc_container_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
baladoc_api_tree_value_inherit_doc_container_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		baladoc_api_tree_inherit_doc_container_unref (value->data[0].v_pointer);
	}
}

static void
baladoc_api_tree_value_inherit_doc_container_copy_value (const GValue* src_value,
                                                         GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = baladoc_api_tree_inherit_doc_container_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
baladoc_api_tree_value_inherit_doc_container_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
baladoc_api_tree_value_inherit_doc_container_collect_value (GValue* value,
                                                            guint n_collect_values,
                                                            GTypeCValue* collect_values,
                                                            guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		BaladocApiTreeInheritDocContainer * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = baladoc_api_tree_inherit_doc_container_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
baladoc_api_tree_value_inherit_doc_container_lcopy_value (const GValue* value,
                                                          guint n_collect_values,
                                                          GTypeCValue* collect_values,
                                                          guint collect_flags)
{
	BaladocApiTreeInheritDocContainer ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = baladoc_api_tree_inherit_doc_container_ref (value->data[0].v_pointer);
	}
	return NULL;
}

static GParamSpec*
baladoc_api_tree_param_spec_inherit_doc_container (const gchar* name,
                                                   const gchar* nick,
                                                   const gchar* blurb,
                                                   GType object_type,
                                                   GParamFlags flags)
{
	BaladocApiTreeParamSpecInheritDocContainer* spec;
	g_return_val_if_fail (g_type_is_a (object_type, BALADOC_API_TREE_TYPE_INHERIT_DOC_CONTAINER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

static gpointer
baladoc_api_tree_value_get_inherit_doc_container (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BALADOC_API_TREE_TYPE_INHERIT_DOC_CONTAINER), NULL);
	return value->data[0].v_pointer;
}

static void
baladoc_api_tree_value_set_inherit_doc_container (GValue* value,
                                                  gpointer v_object)
{
	BaladocApiTreeInheritDocContainer * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BALADOC_API_TREE_TYPE_INHERIT_DOC_CONTAINER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BALADOC_API_TREE_TYPE_INHERIT_DOC_CONTAINER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		baladoc_api_tree_inherit_doc_container_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		baladoc_api_tree_inherit_doc_container_unref (old);
	}
}

static void
baladoc_api_tree_value_take_inherit_doc_container (GValue* value,
                                                   gpointer v_object)
{
	BaladocApiTreeInheritDocContainer * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BALADOC_API_TREE_TYPE_INHERIT_DOC_CONTAINER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BALADOC_API_TREE_TYPE_INHERIT_DOC_CONTAINER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		baladoc_api_tree_inherit_doc_container_unref (old);
	}
}

static void
baladoc_api_tree_inherit_doc_container_class_init (BaladocApiTreeInheritDocContainerClass * klass,
                                                   gpointer klass_data)
{
	baladoc_api_tree_inherit_doc_container_parent_class = g_type_class_peek_parent (klass);
	((BaladocApiTreeInheritDocContainerClass *) klass)->finalize = baladoc_api_tree_inherit_doc_container_finalize;
}

static void
baladoc_api_tree_inherit_doc_container_instance_init (BaladocApiTreeInheritDocContainer * self,
                                                      gpointer klass)
{
	self->ref_count = 1;
}

static void
baladoc_api_tree_inherit_doc_container_finalize (BaladocApiTreeInheritDocContainer * obj)
{
	BaladocApiTreeInheritDocContainer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BALADOC_API_TREE_TYPE_INHERIT_DOC_CONTAINER, BaladocApiTreeInheritDocContainer);
	g_signal_handlers_destroy (self);
}

static GType
baladoc_api_tree_inherit_doc_container_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { baladoc_api_tree_value_inherit_doc_container_init, baladoc_api_tree_value_inherit_doc_container_free_value, baladoc_api_tree_value_inherit_doc_container_copy_value, baladoc_api_tree_value_inherit_doc_container_peek_pointer, "p", baladoc_api_tree_value_inherit_doc_container_collect_value, "p", baladoc_api_tree_value_inherit_doc_container_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (BaladocApiTreeInheritDocContainerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) baladoc_api_tree_inherit_doc_container_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BaladocApiTreeInheritDocContainer), 0, (GInstanceInitFunc) baladoc_api_tree_inherit_doc_container_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType baladoc_api_tree_inherit_doc_container_type_id;
	baladoc_api_tree_inherit_doc_container_type_id = g_type_register_fundamental (g_type_fundamental_next (), "BaladocApiTreeInheritDocContainer", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return baladoc_api_tree_inherit_doc_container_type_id;
}

static GType
baladoc_api_tree_inherit_doc_container_get_type (void)
{
	static volatile gsize baladoc_api_tree_inherit_doc_container_type_id__volatile = 0;
	if (g_once_init_enter (&baladoc_api_tree_inherit_doc_container_type_id__volatile)) {
		GType baladoc_api_tree_inherit_doc_container_type_id;
		baladoc_api_tree_inherit_doc_container_type_id = baladoc_api_tree_inherit_doc_container_get_type_once ();
		g_once_init_leave (&baladoc_api_tree_inherit_doc_container_type_id__volatile, baladoc_api_tree_inherit_doc_container_type_id);
	}
	return baladoc_api_tree_inherit_doc_container_type_id__volatile;
}

static gpointer
baladoc_api_tree_inherit_doc_container_ref (gpointer instance)
{
	BaladocApiTreeInheritDocContainer * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

static void
baladoc_api_tree_inherit_doc_container_unref (gpointer instance)
{
	BaladocApiTreeInheritDocContainer * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		BALADOC_API_TREE_INHERIT_DOC_CONTAINER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static void
baladoc_api_value_tree_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
baladoc_api_value_tree_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		baladoc_api_tree_unref (value->data[0].v_pointer);
	}
}

static void
baladoc_api_value_tree_copy_value (const GValue* src_value,
                                   GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = baladoc_api_tree_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
baladoc_api_value_tree_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
baladoc_api_value_tree_collect_value (GValue* value,
                                      guint n_collect_values,
                                      GTypeCValue* collect_values,
                                      guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		BaladocApiTree * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = baladoc_api_tree_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
baladoc_api_value_tree_lcopy_value (const GValue* value,
                                    guint n_collect_values,
                                    GTypeCValue* collect_values,
                                    guint collect_flags)
{
	BaladocApiTree ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = baladoc_api_tree_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
baladoc_api_param_spec_tree (const gchar* name,
                             const gchar* nick,
                             const gchar* blurb,
                             GType object_type,
                             GParamFlags flags)
{
	BaladocApiParamSpecTree* spec;
	g_return_val_if_fail (g_type_is_a (object_type, BALADOC_API_TYPE_TREE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
baladoc_api_value_get_tree (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BALADOC_API_TYPE_TREE), NULL);
	return value->data[0].v_pointer;
}

void
baladoc_api_value_set_tree (GValue* value,
                            gpointer v_object)
{
	BaladocApiTree * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BALADOC_API_TYPE_TREE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BALADOC_API_TYPE_TREE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		baladoc_api_tree_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		baladoc_api_tree_unref (old);
	}
}

void
baladoc_api_value_take_tree (GValue* value,
                             gpointer v_object)
{
	BaladocApiTree * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BALADOC_API_TYPE_TREE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BALADOC_API_TYPE_TREE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		baladoc_api_tree_unref (old);
	}
}

static void
baladoc_api_tree_class_init (BaladocApiTreeClass * klass,
                             gpointer klass_data)
{
	baladoc_api_tree_parent_class = g_type_class_peek_parent (klass);
	((BaladocApiTreeClass *) klass)->finalize = baladoc_api_tree_finalize;
	g_type_class_adjust_private_offset (klass, &BaladocApiTree_private_offset);
}

static void
baladoc_api_tree_instance_init (BaladocApiTree * self,
                                gpointer klass)
{
	GEqualFunc _tmp0_;
	BalaArrayList* _tmp1_;
	GEqualFunc _tmp2_;
	BalaArrayList* _tmp3_;
	GEqualFunc _tmp4_;
	BalaArrayList* _tmp5_;
	self->priv = baladoc_api_tree_get_instance_private (self);
	_tmp0_ = g_direct_equal;
	_tmp1_ = bala_array_list_new (BALADOC_API_TREE_TYPE_INHERIT_DOC_CONTAINER, (GBoxedCopyFunc) baladoc_api_tree_inherit_doc_container_ref, (GDestroyNotify) baladoc_api_tree_inherit_doc_container_unref, _tmp0_);
	self->priv->inheritdocs = (BalaList*) _tmp1_;
	_tmp2_ = g_str_equal;
	_tmp3_ = bala_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, _tmp2_);
	self->priv->external_c_files = _tmp3_;
	_tmp4_ = g_direct_equal;
	_tmp5_ = bala_array_list_new (BALADOC_API_TYPE_PACKAGE, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, _tmp4_);
	self->priv->packages = _tmp5_;
	self->priv->source_package = NULL;
	self->priv->_cresolver = NULL;
	self->ref_count = 1;
}

static void
baladoc_api_tree_finalize (BaladocApiTree * obj)
{
	BaladocApiTree * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BALADOC_API_TYPE_TREE, BaladocApiTree);
	g_signal_handlers_destroy (self);
	_bala_iterable_unref0 (self->priv->inheritdocs);
	_bala_iterable_unref0 (self->priv->external_c_files);
	_bala_iterable_unref0 (self->priv->packages);
	_g_object_unref0 (self->priv->source_package);
	_g_object_unref0 (self->priv->settings);
	_g_object_unref0 (self->priv->reporter);
	_g_object_unref0 (self->priv->_highlighter);
	_g_object_unref0 (self->priv->_cresolver);
	_g_object_unref0 (self->priv->_source_package);
	_bala_code_context_unref0 (self->priv->_context);
	_g_object_unref0 (self->priv->_wikitree);
}

/**
 * The root of the code tree.
 */
static GType
baladoc_api_tree_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { baladoc_api_value_tree_init, baladoc_api_value_tree_free_value, baladoc_api_value_tree_copy_value, baladoc_api_value_tree_peek_pointer, "p", baladoc_api_value_tree_collect_value, "p", baladoc_api_value_tree_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (BaladocApiTreeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) baladoc_api_tree_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BaladocApiTree), 0, (GInstanceInitFunc) baladoc_api_tree_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType baladoc_api_tree_type_id;
	baladoc_api_tree_type_id = g_type_register_fundamental (g_type_fundamental_next (), "BaladocApiTree", &g_define_type_info, &g_define_type_fundamental_info, 0);
	BaladocApiTree_private_offset = g_type_add_instance_private (baladoc_api_tree_type_id, sizeof (BaladocApiTreePrivate));
	return baladoc_api_tree_type_id;
}

GType
baladoc_api_tree_get_type (void)
{
	static volatile gsize baladoc_api_tree_type_id__volatile = 0;
	if (g_once_init_enter (&baladoc_api_tree_type_id__volatile)) {
		GType baladoc_api_tree_type_id;
		baladoc_api_tree_type_id = baladoc_api_tree_get_type_once ();
		g_once_init_leave (&baladoc_api_tree_type_id__volatile, baladoc_api_tree_type_id);
	}
	return baladoc_api_tree_type_id__volatile;
}

gpointer
baladoc_api_tree_ref (gpointer instance)
{
	BaladocApiTree * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
baladoc_api_tree_unref (gpointer instance)
{
	BaladocApiTree * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		BALADOC_API_TREE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static void
_bala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gint i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_bala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_bala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gint
_bala_array_length (gpointer array)
{
	gint length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

