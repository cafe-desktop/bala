/* commentscanner.c generated by balac, the Bala compiler
 * generated from commentscanner.bala, do not modify */

/* commentscanner.bala
 *
 * Copyright (C) 2008-2009 Florian Brosch, Didier Villevalois
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Didier 'Ptitjes Villevalois <ptitjes@free.fr>
 */

#include "baladoc.h"
#include <glib.h>

enum  {
	BALADOC_COMMENT_SCANNER_0_PROPERTY,
	BALADOC_COMMENT_SCANNER_NUM_PROPERTIES
};
static GParamSpec* baladoc_comment_scanner_properties[BALADOC_COMMENT_SCANNER_NUM_PROPERTIES];

struct _BaladocCommentScannerPrivate {
	gboolean in_line_start;
	gboolean past_star;
	gint start_column;
};

static gint BaladocCommentScanner_private_offset;
static gpointer baladoc_comment_scanner_parent_class = NULL;

static void baladoc_comment_scanner_real_reset (BaladocWikiScanner* base);
static gint baladoc_comment_scanner_real_get_line_start_column (BaladocWikiScanner* base);
static void baladoc_comment_scanner_real_accept (BaladocWikiScanner* base,
                                          gunichar c,
                                          GError** error);
static void baladoc_comment_scanner_finalize (GObject * obj);
static GType baladoc_comment_scanner_get_type_once (void);

static inline gpointer
baladoc_comment_scanner_get_instance_private (BaladocCommentScanner* self)
{
	return G_STRUCT_MEMBER_P (self, BaladocCommentScanner_private_offset);
}

BaladocCommentScanner*
baladoc_comment_scanner_construct (GType object_type,
                                   BaladocSettings* settings)
{
	BaladocCommentScanner * self = NULL;
	g_return_val_if_fail (settings != NULL, NULL);
	self = (BaladocCommentScanner*) baladoc_wiki_scanner_construct (object_type, settings);
	return self;
}

BaladocCommentScanner*
baladoc_comment_scanner_new (BaladocSettings* settings)
{
	return baladoc_comment_scanner_construct (BALADOC_TYPE_COMMENT_SCANNER, settings);
}

static void
baladoc_comment_scanner_real_reset (BaladocWikiScanner* base)
{
	BaladocCommentScanner * self;
	self = (BaladocCommentScanner*) base;
	BALADOC_WIKI_SCANNER_CLASS (baladoc_comment_scanner_parent_class)->reset (G_TYPE_CHECK_INSTANCE_CAST (self, BALADOC_TYPE_WIKI_SCANNER, BaladocWikiScanner));
	self->priv->in_line_start = TRUE;
	self->priv->past_star = FALSE;
	self->priv->start_column = 0;
}

static gint
baladoc_comment_scanner_real_get_line_start_column (BaladocWikiScanner* base)
{
	BaladocCommentScanner * self;
	gint result = 0;
	self = (BaladocCommentScanner*) base;
	result = self->priv->start_column;
	return result;
}

static void
baladoc_comment_scanner_real_accept (BaladocWikiScanner* base,
                                     gunichar c,
                                     GError** error)
{
	BaladocCommentScanner * self;
	GError* _inner_error0_ = NULL;
	self = (BaladocCommentScanner*) base;
	if (self->priv->in_line_start) {
		gint _tmp0_;
		_tmp0_ = self->priv->start_column;
		self->priv->start_column = _tmp0_ + 1;
		if (c == ((gunichar) '*')) {
			self->priv->past_star = TRUE;
		} else {
			if (self->priv->past_star) {
				self->priv->past_star = FALSE;
				if (c == ((gunichar) '\n')) {
					BALADOC_WIKI_SCANNER_CLASS (baladoc_comment_scanner_parent_class)->accept (G_TYPE_CHECK_INSTANCE_CAST (self, BALADOC_TYPE_WIKI_SCANNER, BaladocWikiScanner), c, &_inner_error0_);
					if (G_UNLIKELY (_inner_error0_ != NULL)) {
						if (_inner_error0_->domain == BALADOC_PARSER_ERROR) {
							g_propagate_error (error, _inner_error0_);
							return;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
							g_clear_error (&_inner_error0_);
							return;
						}
					}
					self->priv->in_line_start = TRUE;
					self->priv->start_column = 0;
				} else {
					self->priv->in_line_start = FALSE;
				}
			}
		}
	} else {
		BALADOC_WIKI_SCANNER_CLASS (baladoc_comment_scanner_parent_class)->accept (G_TYPE_CHECK_INSTANCE_CAST (self, BALADOC_TYPE_WIKI_SCANNER, BaladocWikiScanner), c, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == BALADOC_PARSER_ERROR) {
				g_propagate_error (error, _inner_error0_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
		}
		if (c == ((gunichar) '\n')) {
			self->priv->in_line_start = TRUE;
			self->priv->start_column = 0;
		}
	}
}

static void
baladoc_comment_scanner_class_init (BaladocCommentScannerClass * klass,
                                    gpointer klass_data)
{
	baladoc_comment_scanner_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &BaladocCommentScanner_private_offset);
	((BaladocWikiScannerClass *) klass)->reset = (void (*) (BaladocWikiScanner*)) baladoc_comment_scanner_real_reset;
	((BaladocWikiScannerClass *) klass)->get_line_start_column = (gint (*) (BaladocWikiScanner*)) baladoc_comment_scanner_real_get_line_start_column;
	((BaladocWikiScannerClass *) klass)->accept = (void (*) (BaladocWikiScanner*, gunichar, GError**)) baladoc_comment_scanner_real_accept;
	G_OBJECT_CLASS (klass)->finalize = baladoc_comment_scanner_finalize;
}

static void
baladoc_comment_scanner_instance_init (BaladocCommentScanner * self,
                                       gpointer klass)
{
	self->priv = baladoc_comment_scanner_get_instance_private (self);
}

static void
baladoc_comment_scanner_finalize (GObject * obj)
{
	BaladocCommentScanner * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BALADOC_TYPE_COMMENT_SCANNER, BaladocCommentScanner);
	G_OBJECT_CLASS (baladoc_comment_scanner_parent_class)->finalize (obj);
}

static GType
baladoc_comment_scanner_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (BaladocCommentScannerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) baladoc_comment_scanner_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BaladocCommentScanner), 0, (GInstanceInitFunc) baladoc_comment_scanner_instance_init, NULL };
	GType baladoc_comment_scanner_type_id;
	baladoc_comment_scanner_type_id = g_type_register_static (BALADOC_TYPE_WIKI_SCANNER, "BaladocCommentScanner", &g_define_type_info, 0);
	BaladocCommentScanner_private_offset = g_type_add_instance_private (baladoc_comment_scanner_type_id, sizeof (BaladocCommentScannerPrivate));
	return baladoc_comment_scanner_type_id;
}

GType
baladoc_comment_scanner_get_type (void)
{
	static volatile gsize baladoc_comment_scanner_type_id__volatile = 0;
	if (g_once_init_enter (&baladoc_comment_scanner_type_id__volatile)) {
		GType baladoc_comment_scanner_type_id;
		baladoc_comment_scanner_type_id = baladoc_comment_scanner_get_type_once ();
		g_once_init_leave (&baladoc_comment_scanner_type_id__volatile, baladoc_comment_scanner_type_id);
	}
	return baladoc_comment_scanner_type_id__volatile;
}

