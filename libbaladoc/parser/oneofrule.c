/* oneofrule.c generated by balac, the Bala compiler
 * generated from oneofrule.bala, do not modify */

/* oneofrule.bala
 *
 * Copyright (C) 2008-2009 Florian Brosch, Didier Villevalois
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Didier 'Ptitjes Villevalois <ptitjes@free.fr>
 */

#include "baladoc.h"
#include <glib-object.h>
#include <glib.h>
#include <stdlib.h>
#include <string.h>

#define BALADOC_TYPE_ONE_OF_RULE (baladoc_one_of_rule_get_type ())
#define BALADOC_ONE_OF_RULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BALADOC_TYPE_ONE_OF_RULE, BaladocOneOfRule))
#define BALADOC_ONE_OF_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BALADOC_TYPE_ONE_OF_RULE, BaladocOneOfRuleClass))
#define BALADOC_IS_ONE_OF_RULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BALADOC_TYPE_ONE_OF_RULE))
#define BALADOC_IS_ONE_OF_RULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BALADOC_TYPE_ONE_OF_RULE))
#define BALADOC_ONE_OF_RULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BALADOC_TYPE_ONE_OF_RULE, BaladocOneOfRuleClass))

typedef struct _BaladocOneOfRule BaladocOneOfRule;
typedef struct _BaladocOneOfRuleClass BaladocOneOfRuleClass;
typedef struct _BaladocOneOfRulePrivate BaladocOneOfRulePrivate;
enum  {
	BALADOC_ONE_OF_RULE_0_PROPERTY,
	BALADOC_ONE_OF_RULE_NUM_PROPERTIES
};
static GParamSpec* baladoc_one_of_rule_properties[BALADOC_ONE_OF_RULE_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define BALADOC_ONE_OF_RULE_TYPE_STATE (baladoc_one_of_rule_state_get_type ())
#define BALADOC_ONE_OF_RULE_STATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BALADOC_ONE_OF_RULE_TYPE_STATE, BaladocOneOfRuleState))
#define BALADOC_ONE_OF_RULE_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BALADOC_ONE_OF_RULE_TYPE_STATE, BaladocOneOfRuleStateClass))
#define BALADOC_ONE_OF_RULE_IS_STATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BALADOC_ONE_OF_RULE_TYPE_STATE))
#define BALADOC_ONE_OF_RULE_IS_STATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BALADOC_ONE_OF_RULE_TYPE_STATE))
#define BALADOC_ONE_OF_RULE_STATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BALADOC_ONE_OF_RULE_TYPE_STATE, BaladocOneOfRuleStateClass))

typedef struct _BaladocOneOfRuleState BaladocOneOfRuleState;
typedef struct _BaladocOneOfRuleStateClass BaladocOneOfRuleStateClass;
typedef struct _BaladocOneOfRuleStatePrivate BaladocOneOfRuleStatePrivate;
enum  {
	BALADOC_ONE_OF_RULE_STATE_0_PROPERTY,
	BALADOC_ONE_OF_RULE_STATE_NUM_PROPERTIES
};
static GParamSpec* baladoc_one_of_rule_state_properties[BALADOC_ONE_OF_RULE_STATE_NUM_PROPERTIES];

struct _BaladocOneOfRule {
	BaladocRule parent_instance;
	BaladocOneOfRulePrivate * priv;
};

struct _BaladocOneOfRuleClass {
	BaladocRuleClass parent_class;
};

struct _BaladocOneOfRulePrivate {
	GObject** _scheme;
	gint _scheme_length1;
	gint __scheme_size_;
};

struct _BaladocOneOfRuleState {
	GObject parent_instance;
	gint selected;
	BaladocOneOfRuleStatePrivate * priv;
};

struct _BaladocOneOfRuleStateClass {
	GObjectClass parent_class;
};

static gint BaladocOneOfRule_private_offset;
static gpointer baladoc_one_of_rule_parent_class = NULL;
static gpointer baladoc_one_of_rule_state_parent_class = NULL;

G_GNUC_INTERNAL GType baladoc_one_of_rule_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
G_GNUC_INTERNAL BaladocOneOfRule* baladoc_one_of_rule_new (GObject** scheme,
                                           gint scheme_length1);
G_GNUC_INTERNAL BaladocOneOfRule* baladoc_one_of_rule_construct (GType object_type,
                                                 GObject** scheme,
                                                 gint scheme_length1);
static GObject** _bala_array_dup2 (GObject** self,
                            gint length);
static gboolean baladoc_one_of_rule_real_is_optional (BaladocRule* base);
static gboolean baladoc_one_of_rule_real_starts_with_token (BaladocRule* base,
                                                     BaladocToken* token);
static gboolean baladoc_one_of_rule_real_accept_token (BaladocRule* base,
                                                BaladocToken* token,
                                                BaladocParserCallback* parser,
                                                BaladocRuleForward forward,
                                                GError** error);
static GType baladoc_one_of_rule_state_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static BaladocOneOfRuleState* baladoc_one_of_rule_state_new (void);
static BaladocOneOfRuleState* baladoc_one_of_rule_state_construct (GType object_type);
static gboolean baladoc_one_of_rule_real_would_accept_token (BaladocRule* base,
                                                      BaladocToken* token,
                                                      GObject* state);
static gboolean baladoc_one_of_rule_real_would_reduce (BaladocRule* base,
                                                BaladocToken* token,
                                                GObject* rule_state);
static gchar* baladoc_one_of_rule_real_to_string (BaladocRule* base,
                                           GObject* rule_state);
static void baladoc_one_of_rule_state_finalize (GObject * obj);
static GType baladoc_one_of_rule_state_get_type_once (void);
static void baladoc_one_of_rule_finalize (GObject * obj);
static GType baladoc_one_of_rule_get_type_once (void);
static void _bala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _bala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);

static inline gpointer
baladoc_one_of_rule_get_instance_private (BaladocOneOfRule* self)
{
	return G_STRUCT_MEMBER_P (self, BaladocOneOfRule_private_offset);
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static GObject**
_bala_array_dup2 (GObject** self,
                  gint length)
{
	if (length >= 0) {
		GObject** result;
		gint i;
		result = g_new0 (GObject*, length + 1);
		for (i = 0; i < length; i++) {
			GObject* _tmp0_;
			_tmp0_ = _g_object_ref0 (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

G_GNUC_INTERNAL BaladocOneOfRule*
baladoc_one_of_rule_construct (GType object_type,
                               GObject** scheme,
                               gint scheme_length1)
{
	BaladocOneOfRule * self = NULL;
	GObject** _tmp0_;
	gint _tmp0__length1;
	self = (BaladocOneOfRule*) baladoc_rule_construct (object_type);
	_tmp0_ = (scheme != NULL) ? _bala_array_dup2 (scheme, scheme_length1) : ((gpointer) scheme);
	_tmp0__length1 = scheme_length1;
	self->priv->_scheme = (_bala_array_free (self->priv->_scheme, self->priv->_scheme_length1, (GDestroyNotify) g_object_unref), NULL);
	self->priv->_scheme = _tmp0_;
	self->priv->_scheme_length1 = _tmp0__length1;
	self->priv->__scheme_size_ = self->priv->_scheme_length1;
	return self;
}

G_GNUC_INTERNAL BaladocOneOfRule*
baladoc_one_of_rule_new (GObject** scheme,
                         gint scheme_length1)
{
	return baladoc_one_of_rule_construct (BALADOC_TYPE_ONE_OF_RULE, scheme, scheme_length1);
}

static gboolean
baladoc_one_of_rule_real_is_optional (BaladocRule* base)
{
	BaladocOneOfRule * self;
	gboolean result = FALSE;
	self = (BaladocOneOfRule*) base;
	result = FALSE;
	return result;
}

static gboolean
baladoc_one_of_rule_real_starts_with_token (BaladocRule* base,
                                            BaladocToken* token)
{
	BaladocOneOfRule * self;
	GObject** _tmp0_;
	gint _tmp0__length1;
	gboolean result = FALSE;
	self = (BaladocOneOfRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	_tmp0_ = self->priv->_scheme;
	_tmp0__length1 = self->priv->_scheme_length1;
	{
		GObject** scheme_element_collection = NULL;
		gint scheme_element_collection_length1 = 0;
		gint _scheme_element_collection_size_ = 0;
		gint scheme_element_it = 0;
		scheme_element_collection = _tmp0_;
		scheme_element_collection_length1 = _tmp0__length1;
		for (scheme_element_it = 0; scheme_element_it < scheme_element_collection_length1; scheme_element_it = scheme_element_it + 1) {
			GObject* _tmp1_;
			GObject* scheme_element = NULL;
			_tmp1_ = _g_object_ref0 (scheme_element_collection[scheme_element_it]);
			scheme_element = _tmp1_;
			{
				GObject* _tmp2_;
				_tmp2_ = scheme_element;
				if (baladoc_rule_has_start_token ((BaladocRule*) self, _tmp2_, token)) {
					result = TRUE;
					_g_object_unref0 (scheme_element);
					return result;
				}
				_g_object_unref0 (scheme_element);
			}
		}
	}
	result = FALSE;
	return result;
}

static gboolean
baladoc_one_of_rule_real_accept_token (BaladocRule* base,
                                       BaladocToken* token,
                                       BaladocParserCallback* parser,
                                       BaladocRuleForward forward,
                                       GError** error)
{
	BaladocOneOfRule * self;
	BaladocOneOfRuleState* state = NULL;
	GObject* _tmp0_;
	BaladocOneOfRuleState* _tmp1_;
	BaladocOneOfRuleState* _tmp2_;
	BaladocOneOfRuleState* _tmp5_;
	GError* _inner_error0_ = NULL;
	gboolean result = FALSE;
	self = (BaladocOneOfRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	g_return_val_if_fail (parser != NULL, FALSE);
	_tmp0_ = baladoc_parser_callback_get_rule_state (parser);
	_tmp1_ = BALADOC_ONE_OF_RULE_IS_STATE (_tmp0_) ? ((BaladocOneOfRuleState*) _tmp0_) : NULL;
	if (_tmp1_ == NULL) {
		_g_object_unref0 (_tmp0_);
	}
	state = _tmp1_;
	_tmp2_ = state;
	if (_tmp2_ == NULL) {
		BaladocOneOfRuleState* _tmp3_;
		BaladocOneOfRuleState* _tmp4_;
		_tmp3_ = baladoc_one_of_rule_state_new ();
		_g_object_unref0 (state);
		state = _tmp3_;
		_tmp4_ = state;
		baladoc_parser_callback_set_rule_state (parser, (GObject*) _tmp4_);
	}
	_tmp5_ = state;
	if (_tmp5_->selected == -1) {
		gboolean handled = FALSE;
		baladoc_rule_do_start ((BaladocRule*) self, parser, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == BALADOC_PARSER_ERROR) {
				gboolean _tmp6_ = FALSE;
				g_propagate_error (error, _inner_error0_);
				_g_object_unref0 (state);
				return _tmp6_;
			} else {
				gboolean _tmp7_ = FALSE;
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return _tmp7_;
			}
		}
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp8_ = FALSE;
				_tmp8_ = TRUE;
				while (TRUE) {
					GObject** _tmp10_;
					gint _tmp10__length1;
					GObject* scheme_element = NULL;
					GObject** _tmp11_;
					gint _tmp11__length1;
					GObject* _tmp12_;
					GObject* _tmp13_;
					gboolean _tmp14_ = FALSE;
					GObject* _tmp15_;
					gboolean _tmp16_ = FALSE;
					gboolean _tmp17_;
					if (!_tmp8_) {
						gint _tmp9_;
						_tmp9_ = i;
						i = _tmp9_ + 1;
					}
					_tmp8_ = FALSE;
					_tmp10_ = self->priv->_scheme;
					_tmp10__length1 = self->priv->_scheme_length1;
					if (!(i < _tmp10__length1)) {
						break;
					}
					_tmp11_ = self->priv->_scheme;
					_tmp11__length1 = self->priv->_scheme_length1;
					_tmp12_ = _tmp11_[i];
					_tmp13_ = _g_object_ref0 (_tmp12_);
					scheme_element = _tmp13_;
					_tmp15_ = scheme_element;
					_tmp17_ = baladoc_rule_try_to_apply ((BaladocRule*) self, _tmp15_, token, parser, &_tmp16_, &_inner_error0_);
					handled = _tmp16_;
					_tmp14_ = _tmp17_;
					if (G_UNLIKELY (_inner_error0_ != NULL)) {
						if (_inner_error0_->domain == BALADOC_PARSER_ERROR) {
							gboolean _tmp18_ = FALSE;
							g_propagate_error (error, _inner_error0_);
							_g_object_unref0 (scheme_element);
							_g_object_unref0 (state);
							return _tmp18_;
						} else {
							gboolean _tmp19_ = FALSE;
							_g_object_unref0 (scheme_element);
							_g_object_unref0 (state);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
							g_clear_error (&_inner_error0_);
							return _tmp19_;
						}
					}
					if (_tmp14_) {
						BaladocOneOfRuleState* _tmp20_;
						_tmp20_ = state;
						_tmp20_->selected = i;
						result = handled;
						_g_object_unref0 (scheme_element);
						_g_object_unref0 (state);
						return result;
					}
					_g_object_unref0 (scheme_element);
				}
			}
		}
	} else {
		baladoc_rule_do_reduce ((BaladocRule*) self, parser, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == BALADOC_PARSER_ERROR) {
				gboolean _tmp21_ = FALSE;
				g_propagate_error (error, _inner_error0_);
				_g_object_unref0 (state);
				return _tmp21_;
			} else {
				gboolean _tmp22_ = FALSE;
				_g_object_unref0 (state);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return _tmp22_;
			}
		}
		result = FALSE;
		_g_object_unref0 (state);
		return result;
	}
	baladoc_parser_callback_error (parser, token, "unexpected token", &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if (_inner_error0_->domain == BALADOC_PARSER_ERROR) {
			gboolean _tmp23_ = FALSE;
			g_propagate_error (error, _inner_error0_);
			_g_object_unref0 (state);
			return _tmp23_;
		} else {
			gboolean _tmp24_ = FALSE;
			_g_object_unref0 (state);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return _tmp24_;
		}
	}
	g_assert_not_reached ();
	_g_object_unref0 (state);
}

static gboolean
baladoc_one_of_rule_real_would_accept_token (BaladocRule* base,
                                             BaladocToken* token,
                                             GObject* state)
{
	BaladocOneOfRule * self;
	gboolean result = FALSE;
	self = (BaladocOneOfRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	result = FALSE;
	return result;
}

static gboolean
baladoc_one_of_rule_real_would_reduce (BaladocRule* base,
                                       BaladocToken* token,
                                       GObject* rule_state)
{
	BaladocOneOfRule * self;
	BaladocOneOfRuleState* state = NULL;
	BaladocOneOfRuleState* _tmp0_;
	gboolean result = FALSE;
	self = (BaladocOneOfRule*) base;
	g_return_val_if_fail (token != NULL, FALSE);
	_tmp0_ = _g_object_ref0 (BALADOC_ONE_OF_RULE_IS_STATE (rule_state) ? ((BaladocOneOfRuleState*) rule_state) : NULL);
	state = _tmp0_;
	result = state->selected != -1;
	_g_object_unref0 (state);
	return result;
}

static gchar*
baladoc_one_of_rule_real_to_string (BaladocRule* base,
                                    GObject* rule_state)
{
	BaladocOneOfRule * self;
	BaladocOneOfRuleState* state = NULL;
	BaladocOneOfRuleState* _tmp0_;
	BaladocOneOfRuleState* _tmp1_;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_;
	const gchar* _tmp5_;
	BaladocOneOfRuleState* _tmp8_;
	GObject** _tmp9_;
	gint _tmp9__length1;
	gchar* _tmp10_;
	gchar* result = NULL;
	self = (BaladocOneOfRule*) base;
	_tmp0_ = _g_object_ref0 (BALADOC_ONE_OF_RULE_IS_STATE (rule_state) ? ((BaladocOneOfRuleState*) rule_state) : NULL);
	state = _tmp0_;
	_tmp1_ = state;
	if (_tmp1_ == NULL) {
		BaladocOneOfRuleState* _tmp2_;
		_tmp2_ = baladoc_one_of_rule_state_new ();
		_g_object_unref0 (state);
		state = _tmp2_;
	}
	_tmp4_ = baladoc_rule_get_name ((BaladocRule*) self);
	_tmp5_ = _tmp4_;
	if (_tmp5_ != NULL) {
		const gchar* _tmp6_;
		const gchar* _tmp7_;
		_tmp6_ = baladoc_rule_get_name ((BaladocRule*) self);
		_tmp7_ = _tmp6_;
		_tmp3_ = _tmp7_;
	} else {
		_tmp3_ = " ";
	}
	_tmp8_ = state;
	_tmp9_ = self->priv->_scheme;
	_tmp9__length1 = self->priv->_scheme_length1;
	_tmp10_ = g_strdup_printf ("%-15s%-15s(selected=%d/%d)", _tmp3_, "[one-of]", _tmp8_->selected, _tmp9__length1);
	result = _tmp10_;
	_g_object_unref0 (state);
	return result;
}

static BaladocOneOfRuleState*
baladoc_one_of_rule_state_construct (GType object_type)
{
	BaladocOneOfRuleState * self = NULL;
	self = (BaladocOneOfRuleState*) g_object_new (object_type, NULL);
	return self;
}

static BaladocOneOfRuleState*
baladoc_one_of_rule_state_new (void)
{
	return baladoc_one_of_rule_state_construct (BALADOC_ONE_OF_RULE_TYPE_STATE);
}

static void
baladoc_one_of_rule_state_class_init (BaladocOneOfRuleStateClass * klass,
                                      gpointer klass_data)
{
	baladoc_one_of_rule_state_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = baladoc_one_of_rule_state_finalize;
}

static void
baladoc_one_of_rule_state_instance_init (BaladocOneOfRuleState * self,
                                         gpointer klass)
{
	self->selected = -1;
}

static void
baladoc_one_of_rule_state_finalize (GObject * obj)
{
	BaladocOneOfRuleState * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BALADOC_ONE_OF_RULE_TYPE_STATE, BaladocOneOfRuleState);
	G_OBJECT_CLASS (baladoc_one_of_rule_state_parent_class)->finalize (obj);
}

static GType
baladoc_one_of_rule_state_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (BaladocOneOfRuleStateClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) baladoc_one_of_rule_state_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BaladocOneOfRuleState), 0, (GInstanceInitFunc) baladoc_one_of_rule_state_instance_init, NULL };
	GType baladoc_one_of_rule_state_type_id;
	baladoc_one_of_rule_state_type_id = g_type_register_static (G_TYPE_OBJECT, "BaladocOneOfRuleState", &g_define_type_info, 0);
	return baladoc_one_of_rule_state_type_id;
}

static GType
baladoc_one_of_rule_state_get_type (void)
{
	static volatile gsize baladoc_one_of_rule_state_type_id__volatile = 0;
	if (g_once_init_enter (&baladoc_one_of_rule_state_type_id__volatile)) {
		GType baladoc_one_of_rule_state_type_id;
		baladoc_one_of_rule_state_type_id = baladoc_one_of_rule_state_get_type_once ();
		g_once_init_leave (&baladoc_one_of_rule_state_type_id__volatile, baladoc_one_of_rule_state_type_id);
	}
	return baladoc_one_of_rule_state_type_id__volatile;
}

static void
baladoc_one_of_rule_class_init (BaladocOneOfRuleClass * klass,
                                gpointer klass_data)
{
	baladoc_one_of_rule_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &BaladocOneOfRule_private_offset);
	((BaladocRuleClass *) klass)->is_optional = (gboolean (*) (BaladocRule*)) baladoc_one_of_rule_real_is_optional;
	((BaladocRuleClass *) klass)->starts_with_token = (gboolean (*) (BaladocRule*, BaladocToken*)) baladoc_one_of_rule_real_starts_with_token;
	((BaladocRuleClass *) klass)->accept_token = (gboolean (*) (BaladocRule*, BaladocToken*, BaladocParserCallback*, BaladocRuleForward, GError**)) baladoc_one_of_rule_real_accept_token;
	((BaladocRuleClass *) klass)->would_accept_token = (gboolean (*) (BaladocRule*, BaladocToken*, GObject*)) baladoc_one_of_rule_real_would_accept_token;
	((BaladocRuleClass *) klass)->would_reduce = (gboolean (*) (BaladocRule*, BaladocToken*, GObject*)) baladoc_one_of_rule_real_would_reduce;
	((BaladocRuleClass *) klass)->to_string = (gchar* (*) (BaladocRule*, GObject*)) baladoc_one_of_rule_real_to_string;
	G_OBJECT_CLASS (klass)->finalize = baladoc_one_of_rule_finalize;
}

static void
baladoc_one_of_rule_instance_init (BaladocOneOfRule * self,
                                   gpointer klass)
{
	self->priv = baladoc_one_of_rule_get_instance_private (self);
}

static void
baladoc_one_of_rule_finalize (GObject * obj)
{
	BaladocOneOfRule * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BALADOC_TYPE_ONE_OF_RULE, BaladocOneOfRule);
	self->priv->_scheme = (_bala_array_free (self->priv->_scheme, self->priv->_scheme_length1, (GDestroyNotify) g_object_unref), NULL);
	G_OBJECT_CLASS (baladoc_one_of_rule_parent_class)->finalize (obj);
}

static GType
baladoc_one_of_rule_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (BaladocOneOfRuleClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) baladoc_one_of_rule_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BaladocOneOfRule), 0, (GInstanceInitFunc) baladoc_one_of_rule_instance_init, NULL };
	GType baladoc_one_of_rule_type_id;
	baladoc_one_of_rule_type_id = g_type_register_static (BALADOC_TYPE_RULE, "BaladocOneOfRule", &g_define_type_info, 0);
	BaladocOneOfRule_private_offset = g_type_add_instance_private (baladoc_one_of_rule_type_id, sizeof (BaladocOneOfRulePrivate));
	return baladoc_one_of_rule_type_id;
}

G_GNUC_INTERNAL GType
baladoc_one_of_rule_get_type (void)
{
	static volatile gsize baladoc_one_of_rule_type_id__volatile = 0;
	if (g_once_init_enter (&baladoc_one_of_rule_type_id__volatile)) {
		GType baladoc_one_of_rule_type_id;
		baladoc_one_of_rule_type_id = baladoc_one_of_rule_get_type_once ();
		g_once_init_leave (&baladoc_one_of_rule_type_id__volatile, baladoc_one_of_rule_type_id);
	}
	return baladoc_one_of_rule_type_id__volatile;
}

static void
_bala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gint i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_bala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_bala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

