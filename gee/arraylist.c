/* arraylist.c generated by balac, the Bala compiler
 * generated from arraylist.bala, do not modify */

/* arraylist.bala
 *
 * Copyright (C) 2004-2005  Novell, Inc
 * Copyright (C) 2005  David Waite
 * Copyright (C) 2007-2008  Jürg Billeter
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Jürg Billeter <j@bitron.ch>
 */

#include "balagee.h"
#include <glib.h>
#include <glib-object.h>
#include <string.h>

#define BALA_ARRAY_LIST_TYPE_ITERATOR (bala_array_list_iterator_get_type ())
#define BALA_ARRAY_LIST_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BALA_ARRAY_LIST_TYPE_ITERATOR, BalaArrayListIterator))
#define BALA_ARRAY_LIST_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BALA_ARRAY_LIST_TYPE_ITERATOR, BalaArrayListIteratorClass))
#define BALA_ARRAY_LIST_IS_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BALA_ARRAY_LIST_TYPE_ITERATOR))
#define BALA_ARRAY_LIST_IS_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BALA_ARRAY_LIST_TYPE_ITERATOR))
#define BALA_ARRAY_LIST_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BALA_ARRAY_LIST_TYPE_ITERATOR, BalaArrayListIteratorClass))

typedef struct _BalaArrayListIterator BalaArrayListIterator;
typedef struct _BalaArrayListIteratorClass BalaArrayListIteratorClass;
typedef struct _BalaArrayListIteratorPrivate BalaArrayListIteratorPrivate;
#define _bala_iterable_unref0(var) ((var == NULL) ? NULL : (var = (bala_iterable_unref (var), NULL)))
#define _bala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _bala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _bala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _bala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _BalaArrayListPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	GEqualFunc _equal_func;
	gint _stamp;
};

struct _BalaArrayListIterator {
	BalaIterator parent_instance;
	gboolean _removed;
	gint _stamp;
	BalaArrayListIteratorPrivate * priv;
};

struct _BalaArrayListIteratorClass {
	BalaIteratorClass parent_class;
};

struct _BalaArrayListIteratorPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	BalaArrayList* _list;
	gint _index;
};

static gint BalaArrayList_private_offset;
static gpointer bala_array_list_parent_class = NULL;
static gint BalaArrayListIterator_private_offset;
static gpointer bala_array_list_iterator_parent_class = NULL;

static GType bala_array_list_real_get_element_type (BalaIterable* base);
static BalaIterator* bala_array_list_real_iterator (BalaIterable* base);
static BalaArrayListIterator* bala_array_list_iterator_new (GType g_type,
                                                     GBoxedCopyFunc g_dup_func,
                                                     GDestroyNotify g_destroy_func,
                                                     BalaArrayList* list);
static BalaArrayListIterator* bala_array_list_iterator_construct (GType object_type,
                                                           GType g_type,
                                                           GBoxedCopyFunc g_dup_func,
                                                           GDestroyNotify g_destroy_func,
                                                           BalaArrayList* list);
static GType bala_array_list_iterator_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static gboolean bala_array_list_real_contains (BalaCollection* base,
                                        gconstpointer item);
static gint bala_array_list_real_index_of (BalaList* base,
                                    gconstpointer item);
static gpointer bala_array_list_real_get (BalaList* base,
                                   gint index);
static void bala_array_list_real_set (BalaList* base,
                               gint index,
                               gconstpointer item);
static gboolean bala_array_list_real_add (BalaCollection* base,
                                   gconstpointer item);
static void bala_array_list_grow_if_needed (BalaArrayList* self,
                                     gint new_count);
static void bala_array_list_real_insert (BalaList* base,
                                  gint index,
                                  gconstpointer item);
static void bala_array_list_shift (BalaArrayList* self,
                            gint start,
                            gint delta);
static gboolean bala_array_list_real_remove (BalaCollection* base,
                                      gconstpointer item);
static gpointer bala_array_list_real_remove_at (BalaList* base,
                                         gint index);
static void bala_array_list_real_clear (BalaCollection* base);
static void bala_array_list_set_capacity (BalaArrayList* self,
                                   gint value);
static void bala_array_list_iterator_set_list (BalaArrayListIterator* self,
                                        BalaArrayList* value);
static gboolean bala_array_list_iterator_real_next (BalaIterator* base);
static gboolean bala_array_list_iterator_real_has_next (BalaIterator* base);
static gpointer bala_array_list_iterator_real_get (BalaIterator* base);
static void bala_array_list_iterator_real_remove (BalaIterator* base);
static void bala_array_list_iterator_finalize (BalaIterator * obj);
static GType bala_array_list_iterator_get_type_once (void);
static void bala_array_list_finalize (BalaIterable * obj);
static GType bala_array_list_get_type_once (void);
static void _bala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _bala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);
static void _bala_array_move (gpointer array,
                       gsize element_size,
                       gint src,
                       gint dest,
                       gint length);

static inline gpointer
bala_array_list_get_instance_private (BalaArrayList* self)
{
	return G_STRUCT_MEMBER_P (self, BalaArrayList_private_offset);
}

static gint
bala_array_list_real_get_size (BalaCollection* base)
{
	gint result;
	BalaArrayList* self;
	self = (BalaArrayList*) base;
	result = self->_size;
	return result;
}

void
bala_array_list_set_equal_func (BalaArrayList* self,
                                GEqualFunc value)
{
	g_return_if_fail (self != NULL);
	self->priv->_equal_func = value;
}

BalaArrayList*
bala_array_list_construct (GType object_type,
                           GType g_type,
                           GBoxedCopyFunc g_dup_func,
                           GDestroyNotify g_destroy_func,
                           GEqualFunc equal_func)
{
	BalaArrayList* self = NULL;
	self = (BalaArrayList*) bala_list_construct (object_type, g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	bala_array_list_set_equal_func (self, equal_func);
	return self;
}

BalaArrayList*
bala_array_list_new (GType g_type,
                     GBoxedCopyFunc g_dup_func,
                     GDestroyNotify g_destroy_func,
                     GEqualFunc equal_func)
{
	return bala_array_list_construct (BALA_TYPE_ARRAY_LIST, g_type, g_dup_func, g_destroy_func, equal_func);
}

static GType
bala_array_list_real_get_element_type (BalaIterable* base)
{
	BalaArrayList * self;
	GType result = 0UL;
	self = (BalaArrayList*) base;
	result = self->priv->g_type;
	return result;
}

static BalaIterator*
bala_array_list_real_iterator (BalaIterable* base)
{
	BalaArrayList * self;
	BalaArrayListIterator* _tmp0_;
	BalaIterator* result = NULL;
	self = (BalaArrayList*) base;
	_tmp0_ = bala_array_list_iterator_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, (GDestroyNotify) self->priv->g_destroy_func, self);
	result = (BalaIterator*) _tmp0_;
	return result;
}

static gboolean
bala_array_list_real_contains (BalaCollection* base,
                               gconstpointer item)
{
	BalaArrayList * self;
	gboolean result = FALSE;
	self = (BalaArrayList*) base;
	result = bala_list_index_of ((BalaList*) self, item) != -1;
	return result;
}

static gint
bala_array_list_real_index_of (BalaList* base,
                               gconstpointer item)
{
	BalaArrayList * self;
	gint result = 0;
	self = (BalaArrayList*) base;
	{
		gint index = 0;
		index = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				GEqualFunc _tmp2_;
				gpointer* _tmp3_;
				gint _tmp3__length1;
				gconstpointer _tmp4_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = index;
					index = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				if (!(index < self->_size)) {
					break;
				}
				_tmp2_ = self->priv->_equal_func;
				_tmp3_ = self->_items;
				_tmp3__length1 = self->_items_length1;
				_tmp4_ = _tmp3_[index];
				if (_tmp2_ (_tmp4_, item)) {
					result = index;
					return result;
				}
			}
		}
	}
	result = -1;
	return result;
}

static gpointer
bala_array_list_real_get (BalaList* base,
                          gint index)
{
	BalaArrayList * self;
	gboolean _tmp0_ = FALSE;
	gpointer* _tmp1_;
	gint _tmp1__length1;
	gconstpointer _tmp2_;
	gpointer _tmp3_;
	gpointer result = NULL;
	self = (BalaArrayList*) base;
	if (index >= 0) {
		_tmp0_ = index < self->_size;
	} else {
		_tmp0_ = FALSE;
	}
	_bala_assert (_tmp0_, "index >= 0 && index < _size");
	_tmp1_ = self->_items;
	_tmp1__length1 = self->_items_length1;
	_tmp2_ = _tmp1_[index];
	_tmp3_ = ((_tmp2_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp2_) : ((gpointer) _tmp2_);
	result = _tmp3_;
	return result;
}

static void
bala_array_list_real_set (BalaList* base,
                          gint index,
                          gconstpointer item)
{
	BalaArrayList * self;
	gboolean _tmp0_ = FALSE;
	gpointer* _tmp1_;
	gint _tmp1__length1;
	gpointer _tmp2_;
	self = (BalaArrayList*) base;
	if (index >= 0) {
		_tmp0_ = index < self->_size;
	} else {
		_tmp0_ = FALSE;
	}
	_bala_assert (_tmp0_, "index >= 0 && index < _size");
	_tmp1_ = self->_items;
	_tmp1__length1 = self->_items_length1;
	_tmp2_ = ((item != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) item) : ((gpointer) item);
	((_tmp1_[index] == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (_tmp1_[index] = (self->priv->g_destroy_func (_tmp1_[index]), NULL));
	_tmp1_[index] = _tmp2_;
}

static gboolean
bala_array_list_real_add (BalaCollection* base,
                          gconstpointer item)
{
	BalaArrayList * self;
	gpointer* _tmp0_;
	gint _tmp0__length1;
	gpointer* _tmp1_;
	gint _tmp1__length1;
	gint _tmp2_;
	gconstpointer _tmp3_;
	gpointer _tmp4_;
	gint _tmp5_;
	gboolean result = FALSE;
	self = (BalaArrayList*) base;
	_tmp0_ = self->_items;
	_tmp0__length1 = self->_items_length1;
	if (self->_size == _tmp0__length1) {
		bala_array_list_grow_if_needed (self, 1);
	}
	_tmp1_ = self->_items;
	_tmp1__length1 = self->_items_length1;
	_tmp2_ = self->_size;
	self->_size = _tmp2_ + 1;
	_tmp3_ = item;
	_tmp4_ = ((_tmp3_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp3_) : ((gpointer) _tmp3_);
	((_tmp1_[_tmp2_] == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (_tmp1_[_tmp2_] = (self->priv->g_destroy_func (_tmp1_[_tmp2_]), NULL));
	_tmp1_[_tmp2_] = _tmp4_;
	_tmp5_ = self->priv->_stamp;
	self->priv->_stamp = _tmp5_ + 1;
	result = TRUE;
	return result;
}

static void
bala_array_list_real_insert (BalaList* base,
                             gint index,
                             gconstpointer item)
{
	BalaArrayList * self;
	gboolean _tmp0_ = FALSE;
	gpointer* _tmp1_;
	gint _tmp1__length1;
	gpointer* _tmp2_;
	gint _tmp2__length1;
	gpointer _tmp3_;
	gint _tmp4_;
	self = (BalaArrayList*) base;
	if (index >= 0) {
		_tmp0_ = index <= self->_size;
	} else {
		_tmp0_ = FALSE;
	}
	_bala_assert (_tmp0_, "index >= 0 && index <= _size");
	_tmp1_ = self->_items;
	_tmp1__length1 = self->_items_length1;
	if (self->_size == _tmp1__length1) {
		bala_array_list_grow_if_needed (self, 1);
	}
	bala_array_list_shift (self, index, 1);
	_tmp2_ = self->_items;
	_tmp2__length1 = self->_items_length1;
	_tmp3_ = ((item != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) item) : ((gpointer) item);
	((_tmp2_[index] == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (_tmp2_[index] = (self->priv->g_destroy_func (_tmp2_[index]), NULL));
	_tmp2_[index] = _tmp3_;
	_tmp4_ = self->priv->_stamp;
	self->priv->_stamp = _tmp4_ + 1;
}

static gboolean
bala_array_list_real_remove (BalaCollection* base,
                             gconstpointer item)
{
	BalaArrayList * self;
	gboolean result = FALSE;
	self = (BalaArrayList*) base;
	{
		gint index = 0;
		index = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				GEqualFunc _tmp2_;
				gpointer* _tmp3_;
				gint _tmp3__length1;
				gconstpointer _tmp4_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = index;
					index = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				if (!(index < self->_size)) {
					break;
				}
				_tmp2_ = self->priv->_equal_func;
				_tmp3_ = self->_items;
				_tmp3__length1 = self->_items_length1;
				_tmp4_ = _tmp3_[index];
				if (_tmp2_ (_tmp4_, item)) {
					gpointer _tmp5_;
					gpointer _tmp6_;
					_tmp5_ = bala_list_remove_at ((BalaList*) self, index);
					_tmp6_ = _tmp5_;
					((_tmp6_ == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (_tmp6_ = (self->priv->g_destroy_func (_tmp6_), NULL));
					result = TRUE;
					return result;
				}
			}
		}
	}
	result = FALSE;
	return result;
}

static gpointer
bala_array_list_real_remove_at (BalaList* base,
                                gint index)
{
	BalaArrayList * self;
	gboolean _tmp0_ = FALSE;
	gpointer item = NULL;
	gpointer* _tmp1_;
	gint _tmp1__length1;
	gconstpointer _tmp2_;
	gpointer _tmp3_;
	gpointer* _tmp4_;
	gint _tmp4__length1;
	gint _tmp5_;
	gpointer result = NULL;
	self = (BalaArrayList*) base;
	if (index >= 0) {
		_tmp0_ = index < self->_size;
	} else {
		_tmp0_ = FALSE;
	}
	_bala_assert (_tmp0_, "index >= 0 && index < _size");
	_tmp1_ = self->_items;
	_tmp1__length1 = self->_items_length1;
	_tmp2_ = _tmp1_[index];
	_tmp3_ = ((_tmp2_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp2_) : ((gpointer) _tmp2_);
	item = _tmp3_;
	_tmp4_ = self->_items;
	_tmp4__length1 = self->_items_length1;
	((_tmp4_[index] == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (_tmp4_[index] = (self->priv->g_destroy_func (_tmp4_[index]), NULL));
	_tmp4_[index] = NULL;
	bala_array_list_shift (self, index + 1, -1);
	_tmp5_ = self->priv->_stamp;
	self->priv->_stamp = _tmp5_ + 1;
	result = item;
	return result;
}

static void
bala_array_list_real_clear (BalaCollection* base)
{
	BalaArrayList * self;
	gint _tmp3_;
	self = (BalaArrayList*) base;
	{
		gint index = 0;
		index = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gpointer* _tmp2_;
				gint _tmp2__length1;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = index;
					index = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				if (!(index < self->_size)) {
					break;
				}
				_tmp2_ = self->_items;
				_tmp2__length1 = self->_items_length1;
				((_tmp2_[index] == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (_tmp2_[index] = (self->priv->g_destroy_func (_tmp2_[index]), NULL));
				_tmp2_[index] = NULL;
			}
		}
	}
	self->_size = 0;
	_tmp3_ = self->priv->_stamp;
	self->priv->_stamp = _tmp3_ + 1;
}

static void
bala_array_list_shift (BalaArrayList* self,
                       gint start,
                       gint delta)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	if (start >= 0) {
		_tmp1_ = start <= self->_size;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = start >= (-delta);
	} else {
		_tmp0_ = FALSE;
	}
	_bala_assert (_tmp0_, "start >= 0 && start <= _size && start >= -delta");
	_bala_array_move (self->_items, sizeof (gpointer), start, start + delta, self->_size - start);
	self->_size = self->_size + delta;
}

static void
bala_array_list_grow_if_needed (BalaArrayList* self,
                                gint new_count)
{
	gint minimum_size = 0;
	gpointer* _tmp0_;
	gint _tmp0__length1;
	g_return_if_fail (self != NULL);
	_bala_assert (new_count >= 0, "new_count >= 0");
	minimum_size = self->_size + new_count;
	_tmp0_ = self->_items;
	_tmp0__length1 = self->_items_length1;
	if (minimum_size > _tmp0__length1) {
		gint _tmp1_ = 0;
		gpointer* _tmp2_;
		gint _tmp2__length1;
		_tmp2_ = self->_items;
		_tmp2__length1 = self->_items_length1;
		if (new_count > _tmp2__length1) {
			_tmp1_ = minimum_size;
		} else {
			gpointer* _tmp3_;
			gint _tmp3__length1;
			_tmp3_ = self->_items;
			_tmp3__length1 = self->_items_length1;
			_tmp1_ = 2 * _tmp3__length1;
		}
		bala_array_list_set_capacity (self, _tmp1_);
	}
}

static void
bala_array_list_set_capacity (BalaArrayList* self,
                              gint value)
{
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_bala_assert (value >= self->_size, "value >= _size");
	_tmp0_ = value;
	self->_items = g_renew (gpointer, self->_items, value);
	(_tmp0_ > self->_items_length1) ? memset (self->_items + self->_items_length1, 0, sizeof (gpointer) * (_tmp0_ - self->_items_length1)) : NULL;
	self->_items_length1 = _tmp0_;
	self->__items_size_ = _tmp0_;
}

static inline gpointer
bala_array_list_iterator_get_instance_private (BalaArrayListIterator* self)
{
	return G_STRUCT_MEMBER_P (self, BalaArrayListIterator_private_offset);
}

static gpointer
_bala_iterable_ref0 (gpointer self)
{
	return self ? bala_iterable_ref (self) : NULL;
}

static void
bala_array_list_iterator_set_list (BalaArrayListIterator* self,
                                   BalaArrayList* value)
{
	BalaArrayList* _tmp0_;
	BalaArrayList* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _bala_iterable_ref0 (value);
	_bala_iterable_unref0 (self->priv->_list);
	self->priv->_list = _tmp0_;
	_tmp1_ = self->priv->_list;
	self->_stamp = _tmp1_->priv->_stamp;
}

static BalaArrayListIterator*
bala_array_list_iterator_construct (GType object_type,
                                    GType g_type,
                                    GBoxedCopyFunc g_dup_func,
                                    GDestroyNotify g_destroy_func,
                                    BalaArrayList* list)
{
	BalaArrayListIterator* self = NULL;
	g_return_val_if_fail (list != NULL, NULL);
	self = (BalaArrayListIterator*) bala_iterator_construct (object_type, g_type, (GBoxedCopyFunc) g_dup_func, (GDestroyNotify) g_destroy_func);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	bala_array_list_iterator_set_list (self, list);
	return self;
}

static BalaArrayListIterator*
bala_array_list_iterator_new (GType g_type,
                              GBoxedCopyFunc g_dup_func,
                              GDestroyNotify g_destroy_func,
                              BalaArrayList* list)
{
	return bala_array_list_iterator_construct (BALA_ARRAY_LIST_TYPE_ITERATOR, g_type, g_dup_func, g_destroy_func, list);
}

static gboolean
bala_array_list_iterator_real_next (BalaIterator* base)
{
	BalaArrayListIterator * self;
	BalaArrayList* _tmp0_;
	BalaArrayList* _tmp1_;
	BalaArrayList* _tmp3_;
	gboolean result = FALSE;
	self = (BalaArrayListIterator*) base;
	_tmp0_ = self->priv->_list;
	_bala_assert (self->_stamp == _tmp0_->priv->_stamp, "_stamp == _list._stamp");
	_tmp1_ = self->priv->_list;
	if (self->priv->_index < _tmp1_->_size) {
		gint _tmp2_;
		_tmp2_ = self->priv->_index;
		self->priv->_index = _tmp2_ + 1;
		self->_removed = FALSE;
	}
	_tmp3_ = self->priv->_list;
	result = self->priv->_index < _tmp3_->_size;
	return result;
}

static gboolean
bala_array_list_iterator_real_has_next (BalaIterator* base)
{
	BalaArrayListIterator * self;
	BalaArrayList* _tmp0_;
	BalaArrayList* _tmp1_;
	gboolean result = FALSE;
	self = (BalaArrayListIterator*) base;
	_tmp0_ = self->priv->_list;
	_bala_assert (self->_stamp == _tmp0_->priv->_stamp, "_stamp == _list._stamp");
	_tmp1_ = self->priv->_list;
	result = (self->priv->_index + 1) < _tmp1_->_size;
	return result;
}

static gpointer
bala_array_list_iterator_real_get (BalaIterator* base)
{
	BalaArrayListIterator * self;
	BalaArrayList* _tmp0_;
	gboolean _tmp1_ = FALSE;
	BalaArrayList* _tmp3_;
	gpointer _tmp4_;
	gpointer result = NULL;
	self = (BalaArrayListIterator*) base;
	_tmp0_ = self->priv->_list;
	_bala_assert (self->_stamp == _tmp0_->priv->_stamp, "_stamp == _list._stamp");
	_bala_assert (!self->_removed, "! _removed");
	if (self->priv->_index < 0) {
		_tmp1_ = TRUE;
	} else {
		BalaArrayList* _tmp2_;
		_tmp2_ = self->priv->_list;
		_tmp1_ = self->priv->_index >= _tmp2_->_size;
	}
	if (_tmp1_) {
		result = NULL;
		return result;
	}
	_tmp3_ = self->priv->_list;
	_tmp4_ = bala_list_get ((BalaList*) _tmp3_, self->priv->_index);
	result = _tmp4_;
	return result;
}

static void
bala_array_list_iterator_real_remove (BalaIterator* base)
{
	BalaArrayListIterator * self;
	BalaArrayList* _tmp0_;
	gboolean _tmp1_ = FALSE;
	BalaArrayList* _tmp2_;
	BalaArrayList* _tmp3_;
	gpointer _tmp4_;
	gpointer _tmp5_;
	gint _tmp6_;
	BalaArrayList* _tmp7_;
	self = (BalaArrayListIterator*) base;
	_tmp0_ = self->priv->_list;
	_bala_assert (self->_stamp == _tmp0_->priv->_stamp, "_stamp == _list._stamp");
	if (!self->_removed) {
		_tmp1_ = self->priv->_index >= 0;
	} else {
		_tmp1_ = FALSE;
	}
	_bala_assert (_tmp1_, "! _removed && _index >= 0");
	_tmp2_ = self->priv->_list;
	_bala_assert (self->priv->_index < _tmp2_->_size, "_index < _list._size");
	_tmp3_ = self->priv->_list;
	_tmp4_ = bala_list_remove_at ((BalaList*) _tmp3_, self->priv->_index);
	_tmp5_ = _tmp4_;
	((_tmp5_ == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (_tmp5_ = (self->priv->g_destroy_func (_tmp5_), NULL));
	_tmp6_ = self->priv->_index;
	self->priv->_index = _tmp6_ - 1;
	self->_removed = TRUE;
	_tmp7_ = self->priv->_list;
	self->_stamp = _tmp7_->priv->_stamp;
}

static gboolean
bala_array_list_iterator_real_get_valid (BalaIterator* base)
{
	gboolean result;
	BalaArrayListIterator* self;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	self = (BalaArrayListIterator*) base;
	if (self->priv->_index >= 0) {
		BalaArrayList* _tmp2_;
		_tmp2_ = self->priv->_list;
		_tmp1_ = self->priv->_index < _tmp2_->_size;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = !self->_removed;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}

static void
bala_array_list_iterator_class_init (BalaArrayListIteratorClass * klass,
                                     gpointer klass_data)
{
	bala_array_list_iterator_parent_class = g_type_class_peek_parent (klass);
	((BalaIteratorClass *) klass)->finalize = bala_array_list_iterator_finalize;
	g_type_class_adjust_private_offset (klass, &BalaArrayListIterator_private_offset);
	((BalaIteratorClass *) klass)->next = (gboolean (*) (BalaIterator*)) bala_array_list_iterator_real_next;
	((BalaIteratorClass *) klass)->has_next = (gboolean (*) (BalaIterator*)) bala_array_list_iterator_real_has_next;
	((BalaIteratorClass *) klass)->get = (gpointer (*) (BalaIterator*)) bala_array_list_iterator_real_get;
	((BalaIteratorClass *) klass)->remove = (void (*) (BalaIterator*)) bala_array_list_iterator_real_remove;
	BALA_ITERATOR_CLASS (klass)->get_valid = bala_array_list_iterator_real_get_valid;
}

static void
bala_array_list_iterator_instance_init (BalaArrayListIterator * self,
                                        gpointer klass)
{
	self->priv = bala_array_list_iterator_get_instance_private (self);
	self->priv->_index = -1;
	self->_removed = FALSE;
	self->_stamp = 0;
}

static void
bala_array_list_iterator_finalize (BalaIterator * obj)
{
	BalaArrayListIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BALA_ARRAY_LIST_TYPE_ITERATOR, BalaArrayListIterator);
	_bala_iterable_unref0 (self->priv->_list);
	BALA_ITERATOR_CLASS (bala_array_list_iterator_parent_class)->finalize (obj);
}

static GType
bala_array_list_iterator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (BalaArrayListIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bala_array_list_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BalaArrayListIterator), 0, (GInstanceInitFunc) bala_array_list_iterator_instance_init, NULL };
	GType bala_array_list_iterator_type_id;
	bala_array_list_iterator_type_id = g_type_register_static (BALA_TYPE_ITERATOR, "BalaArrayListIterator", &g_define_type_info, 0);
	BalaArrayListIterator_private_offset = g_type_add_instance_private (bala_array_list_iterator_type_id, sizeof (BalaArrayListIteratorPrivate));
	return bala_array_list_iterator_type_id;
}

static GType
bala_array_list_iterator_get_type (void)
{
	static volatile gsize bala_array_list_iterator_type_id__volatile = 0;
	if (g_once_init_enter (&bala_array_list_iterator_type_id__volatile)) {
		GType bala_array_list_iterator_type_id;
		bala_array_list_iterator_type_id = bala_array_list_iterator_get_type_once ();
		g_once_init_leave (&bala_array_list_iterator_type_id__volatile, bala_array_list_iterator_type_id);
	}
	return bala_array_list_iterator_type_id__volatile;
}

static void
bala_array_list_class_init (BalaArrayListClass * klass,
                            gpointer klass_data)
{
	bala_array_list_parent_class = g_type_class_peek_parent (klass);
	((BalaIterableClass *) klass)->finalize = bala_array_list_finalize;
	g_type_class_adjust_private_offset (klass, &BalaArrayList_private_offset);
	((BalaIterableClass *) klass)->get_element_type = (GType (*) (BalaIterable*)) bala_array_list_real_get_element_type;
	((BalaIterableClass *) klass)->iterator = (BalaIterator* (*) (BalaIterable*)) bala_array_list_real_iterator;
	((BalaCollectionClass *) klass)->contains = (gboolean (*) (BalaCollection*, gconstpointer)) bala_array_list_real_contains;
	((BalaListClass *) klass)->index_of = (gint (*) (BalaList*, gconstpointer)) bala_array_list_real_index_of;
	((BalaListClass *) klass)->get = (gpointer (*) (BalaList*, gint)) bala_array_list_real_get;
	((BalaListClass *) klass)->set = (void (*) (BalaList*, gint, gconstpointer)) bala_array_list_real_set;
	((BalaCollectionClass *) klass)->add = (gboolean (*) (BalaCollection*, gconstpointer)) bala_array_list_real_add;
	((BalaListClass *) klass)->insert = (void (*) (BalaList*, gint, gconstpointer)) bala_array_list_real_insert;
	((BalaCollectionClass *) klass)->remove = (gboolean (*) (BalaCollection*, gconstpointer)) bala_array_list_real_remove;
	((BalaListClass *) klass)->remove_at = (gpointer (*) (BalaList*, gint)) bala_array_list_real_remove_at;
	((BalaCollectionClass *) klass)->clear = (void (*) (BalaCollection*)) bala_array_list_real_clear;
	BALA_COLLECTION_CLASS (klass)->get_size = bala_array_list_real_get_size;
}

static void
bala_array_list_instance_init (BalaArrayList * self,
                               gpointer klass)
{
	gpointer* _tmp0_;
	self->priv = bala_array_list_get_instance_private (self);
	_tmp0_ = g_new0 (gpointer, 4);
	self->_items = _tmp0_;
	self->_items_length1 = 4;
	self->__items_size_ = self->_items_length1;
	self->priv->_stamp = 0;
}

static void
bala_array_list_finalize (BalaIterable * obj)
{
	BalaArrayList * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BALA_TYPE_ARRAY_LIST, BalaArrayList);
	self->_items = (_bala_array_free (self->_items, self->_items_length1, (GDestroyNotify) self->priv->g_destroy_func), NULL);
	BALA_ITERABLE_CLASS (bala_array_list_parent_class)->finalize (obj);
}

/**
 * Arrays of arbitrary elements which grow automatically as elements are added.
 */
static GType
bala_array_list_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (BalaArrayListClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bala_array_list_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BalaArrayList), 0, (GInstanceInitFunc) bala_array_list_instance_init, NULL };
	GType bala_array_list_type_id;
	bala_array_list_type_id = g_type_register_static (BALA_TYPE_LIST, "BalaArrayList", &g_define_type_info, 0);
	BalaArrayList_private_offset = g_type_add_instance_private (bala_array_list_type_id, sizeof (BalaArrayListPrivate));
	return bala_array_list_type_id;
}

GType
bala_array_list_get_type (void)
{
	static volatile gsize bala_array_list_type_id__volatile = 0;
	if (g_once_init_enter (&bala_array_list_type_id__volatile)) {
		GType bala_array_list_type_id;
		bala_array_list_type_id = bala_array_list_get_type_once ();
		g_once_init_leave (&bala_array_list_type_id__volatile, bala_array_list_type_id);
	}
	return bala_array_list_type_id__volatile;
}

static void
_bala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gint i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_bala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_bala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static void
_bala_array_move (gpointer array,
                  gsize element_size,
                  gint src,
                  gint dest,
                  gint length)
{
	memmove (((char*) array) + (dest * element_size), ((char*) array) + (src * element_size), length * element_size);
	if ((src < dest) && ((src + length) > dest)) {
		memset (((char*) array) + (src * element_size), 0, (dest - src) * element_size);
	} else if ((src > dest) && (src < (dest + length))) {
		memset (((char*) array) + ((dest + length) * element_size), 0, (src - dest) * element_size);
	} else if (src != dest) {
		memset (((char*) array) + (src * element_size), 0, length * element_size);
	}
}

