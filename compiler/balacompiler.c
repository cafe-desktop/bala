/* balacompiler.c generated by balac, the Bala compiler
 * generated from balacompiler.bala, do not modify */

/* balacompiler.bala
 *
 * Copyright (C) 2006-2012  Jürg Billeter
 * Copyright (C) 1996-2002, 2004, 2005, 2006 Free Software Foundation, Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Jürg Billeter <j@bitron.ch>
 */

#include <glib-object.h>
#include <bala.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <stdio.h>
#include <balacodegen.h>
#include <balagee.h>
#include <glib/gstdio.h>
#include <unistd.h>
#include <locale.h>
#include <config.h>
#include <gobject/gvaluecollector.h>

#define BALA_TYPE_COMPILER (bala_compiler_get_type ())
#define BALA_COMPILER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BALA_TYPE_COMPILER, BalaCompiler))
#define BALA_COMPILER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BALA_TYPE_COMPILER, BalaCompilerClass))
#define BALA_IS_COMPILER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BALA_TYPE_COMPILER))
#define BALA_IS_COMPILER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BALA_TYPE_COMPILER))
#define BALA_COMPILER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BALA_TYPE_COMPILER, BalaCompilerClass))

typedef struct _BalaCompiler BalaCompiler;
typedef struct _BalaCompilerClass BalaCompilerClass;
typedef struct _BalaCompilerPrivate BalaCompilerPrivate;
#define _bala_code_context_unref0(var) ((var == NULL) ? NULL : (var = (bala_code_context_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _bala_source_file_unref0(var) ((var == NULL) ? NULL : (var = (bala_source_file_unref (var), NULL)))
#define _bala_code_visitor_unref0(var) ((var == NULL) ? NULL : (var = (bala_code_visitor_unref (var), NULL)))
#define _bala_iterable_unref0(var) ((var == NULL) ? NULL : (var = (bala_iterable_unref (var), NULL)))
#define _bala_ccode_compiler_unref0(var) ((var == NULL) ? NULL : (var = (bala_ccode_compiler_unref (var), NULL)))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _bala_compiler_unref0(var) ((var == NULL) ? NULL : (var = (bala_compiler_unref (var), NULL)))
typedef struct _Block1Data Block1Data;
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
typedef struct _BalaParamSpecCompiler BalaParamSpecCompiler;

struct _BalaCompiler {
	GTypeInstance parent_instance;
	volatile int ref_count;
	BalaCompilerPrivate * priv;
};

struct _BalaCompilerClass {
	GTypeClass parent_class;
	void (*finalize) (BalaCompiler *self);
};

struct _BalaCompilerPrivate {
	BalaCodeContext* context;
};

struct _Block1Data {
	int _ref_count_;
	GMainLoop* loop;
	gint child_status;
};

struct _BalaParamSpecCompiler {
	GParamSpec parent_instance;
};

static gint BalaCompiler_private_offset;
static gpointer bala_compiler_parent_class = NULL;
static gchar** bala_compiler_bapi_directories;
static gchar** bala_compiler_gir_directories;
static gchar** bala_compiler_metadata_directories;
static gchar** bala_compiler_packages;
static gchar* bala_compiler_bapi_filename;
static gchar* bala_compiler_library;
static gchar* bala_compiler_shared_library;
static gchar* bala_compiler_gir;
static gchar* bala_compiler_basedir;
static gchar* bala_compiler_directory;
static gboolean bala_compiler_version;
static gboolean bala_compiler_api_version;
static gboolean bala_compiler_ccode_only;
static gchar* bala_compiler_header_filename;
static gboolean bala_compiler_use_header;
static gchar* bala_compiler_includedir;
static gchar* bala_compiler_internal_header_filename;
static gchar* bala_compiler_internal_bapi_filename;
static gchar* bala_compiler_fast_bapi_filename;
static gchar** bala_compiler_fast_bapis;
static gboolean bala_compiler_bapi_comments;
static gchar* bala_compiler_dependencies;
static gchar* bala_compiler_depfile;
static gboolean bala_compiler_list_sources;
static gchar* bala_compiler_symbols_filename;
static gboolean bala_compiler_compile_only;
static gchar* bala_compiler_output;
static gboolean bala_compiler_debug;
static gboolean bala_compiler_mem_profiler;
static gchar** bala_compiler_defines;
static gchar* bala_compiler_entry_point;
static gboolean bala_compiler_nostdpkg;
static gboolean bala_compiler_disable_assert;
static gboolean bala_compiler_enable_checking;
static gboolean bala_compiler_deprecated;
static gboolean bala_compiler_hide_internal;
static gboolean bala_compiler_experimental;
static gboolean bala_compiler_disable_warnings;
static gboolean bala_compiler_fatal_warnings;
static gboolean bala_compiler_disable_since_check;
static gboolean bala_compiler_keep_going;
static gboolean bala_compiler_experimental_non_null;
static gboolean bala_compiler_gobject_tracing;
static gchar* bala_compiler_cc_command;
static gchar** bala_compiler_cc_options;
static gchar* bala_compiler_pkg_config_command;
static gchar* bala_compiler_dump_tree;
static gboolean bala_compiler_save_temps;
static gchar* bala_compiler_profile;
static gboolean bala_compiler_quiet_mode;
static gboolean bala_compiler_verbose_mode;
static gboolean bala_compiler_disable_colored_output;
static gchar* bala_compiler_target_glib;
static gchar** bala_compiler_gresources;
static gchar** bala_compiler_gresources_directories;
static gboolean bala_compiler_enable_version_header;
static gboolean bala_compiler_disable_version_header;
static gchar* bala_compiler_run_args;
static gboolean bala_compiler_abi_stability;
static gchar** bala_compiler_sources;
static gchar* bala_compiler_basedir = NULL;
static gchar* bala_compiler_directory = NULL;
static gboolean bala_compiler_version = FALSE;
static gboolean bala_compiler_api_version = FALSE;
static gchar** bala_compiler_sources = NULL;
static gchar** bala_compiler_bapi_directories = NULL;
static gchar** bala_compiler_gir_directories = NULL;
static gchar** bala_compiler_metadata_directories = NULL;
static gchar* bala_compiler_bapi_filename = NULL;
static gchar* bala_compiler_library = NULL;
static gchar* bala_compiler_shared_library = NULL;
static gchar* bala_compiler_gir = NULL;
static gchar** bala_compiler_packages = NULL;
static gchar** bala_compiler_fast_bapis = NULL;
static gchar* bala_compiler_target_glib = NULL;
static gchar** bala_compiler_gresources = NULL;
static gchar** bala_compiler_gresources_directories = NULL;
static gboolean bala_compiler_ccode_only = FALSE;
static gboolean bala_compiler_abi_stability = FALSE;
static gchar* bala_compiler_header_filename = NULL;
static gboolean bala_compiler_use_header = FALSE;
static gchar* bala_compiler_internal_header_filename = NULL;
static gchar* bala_compiler_internal_bapi_filename = NULL;
static gchar* bala_compiler_fast_bapi_filename = NULL;
static gboolean bala_compiler_bapi_comments = FALSE;
static gchar* bala_compiler_symbols_filename = NULL;
static gchar* bala_compiler_includedir = NULL;
static gboolean bala_compiler_compile_only = FALSE;
static gchar* bala_compiler_output = NULL;
static gboolean bala_compiler_debug = FALSE;
static gboolean bala_compiler_mem_profiler = FALSE;
static gboolean bala_compiler_disable_assert = FALSE;
static gboolean bala_compiler_enable_checking = FALSE;
static gboolean bala_compiler_deprecated = FALSE;
static gboolean bala_compiler_hide_internal = FALSE;
static gboolean bala_compiler_experimental = FALSE;
static gboolean bala_compiler_experimental_non_null = FALSE;
static gboolean bala_compiler_gobject_tracing = FALSE;
static gboolean bala_compiler_disable_since_check = FALSE;
static gboolean bala_compiler_disable_warnings = FALSE;
static gboolean bala_compiler_keep_going = FALSE;
static gboolean bala_compiler_list_sources = FALSE;
static gchar* bala_compiler_cc_command = NULL;
static gchar** bala_compiler_cc_options = NULL;
static gchar* bala_compiler_pkg_config_command = NULL;
static gchar* bala_compiler_dump_tree = NULL;
static gboolean bala_compiler_save_temps = FALSE;
static gchar** bala_compiler_defines = NULL;
static gboolean bala_compiler_quiet_mode = FALSE;
static gboolean bala_compiler_verbose_mode = FALSE;
static gchar* bala_compiler_profile = NULL;
static gboolean bala_compiler_nostdpkg = FALSE;
static gboolean bala_compiler_enable_version_header = FALSE;
static gboolean bala_compiler_disable_version_header = FALSE;
static gboolean bala_compiler_fatal_warnings = FALSE;
static gboolean bala_compiler_disable_colored_output = FALSE;
static BalaReportColored bala_compiler_colored_output;
static BalaReportColored bala_compiler_colored_output = BALA_REPORT_COLORED_AUTO;
static gchar* bala_compiler_dependencies = NULL;
static gchar* bala_compiler_depfile = NULL;
static gchar* bala_compiler_entry_point = NULL;
static gboolean bala_compiler_run_output;
static gboolean bala_compiler_run_output = FALSE;
static gchar* bala_compiler_run_args = NULL;

G_GNUC_INTERNAL gpointer bala_compiler_ref (gpointer instance);
G_GNUC_INTERNAL void bala_compiler_unref (gpointer instance);
G_GNUC_INTERNAL GParamSpec* bala_param_spec_compiler (const gchar* name,
                                      const gchar* nick,
                                      const gchar* blurb,
                                      GType object_type,
                                      GParamFlags flags);
G_GNUC_INTERNAL void bala_value_set_compiler (GValue* value,
                              gpointer v_object) G_GNUC_UNUSED;
G_GNUC_INTERNAL void bala_value_take_compiler (GValue* value,
                               gpointer v_object);
G_GNUC_INTERNAL gpointer bala_value_get_compiler (const GValue* value) G_GNUC_UNUSED;
G_GNUC_INTERNAL GType bala_compiler_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (BalaCompiler, bala_compiler_unref)
#define BALA_COMPILER_DEFAULT_COLORS "error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01"
static gboolean bala_compiler_option_deprecated (const gchar* option_name,
                                          const gchar* val,
                                          void* data,
                                          GError** error);
static gboolean bala_compiler_option_parse_color (const gchar* option_name,
                                           const gchar* val,
                                           void* data,
                                           GError** error);
static gint bala_compiler_quit (BalaCompiler* self);
static gint bala_compiler_run (BalaCompiler* self);
static gint bala_compiler_run_source (gchar** args,
                               gint args_length1);
G_GNUC_INTERNAL BalaCompiler* bala_compiler_new (void);
G_GNUC_INTERNAL BalaCompiler* bala_compiler_construct (GType object_type);
static void _bala_array_add1 (gchar** * array,
                       gint* length,
                       gint* size,
                       gchar* value);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void ___lambda4_ (Block1Data* _data1_,
                  GPid pid,
                  gint status);
static void ____lambda4__gchild_watch_func (GPid pid,
                                     gint status,
                                     gpointer self);
static gint bala_compiler_main (gchar** args,
                         gint args_length1);
static void bala_compiler_finalize (BalaCompiler * obj);
static GType bala_compiler_get_type_once (void);
static void _bala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _bala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);
static gint _bala_array_length (gpointer array);

static const GOptionEntry BALA_COMPILER_options[63] = {{"bapidir", (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &bala_compiler_bapi_directories, "Look for package bindings in DIRECTORY", "DIRECTORY..."}, {"girdir", (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &bala_compiler_gir_directories, "Look for .gir files in DIRECTORY", "DIRECTORY..."}, {"metadatadir", (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &bala_compiler_metadata_directories, "Look for GIR .metadata files in DIRECTORY", "DIRECTORY..."}, {"pkg", (gchar) 0, 0, G_OPTION_ARG_STRING_ARRAY, &bala_compiler_packages, "Include binding for PACKAGE", "PACKAGE..."}, {"bapi", (gchar) 0, 0, G_OPTION_ARG_FILENAME, &bala_compiler_bapi_filename, "Output BAPI file name", "FILE"}, {"library", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_compiler_library, "Library name", "NAME"}, {"shared-library", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_compiler_shared_library, "Shared library name used in generated gir", "NAME"}, {"gir", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_compiler_gir, "GObject-Introspection repository file name", "NAME-VERSION.gir"}, {"basedir", 'b', 0, G_OPTION_ARG_FILENAME, &bala_compiler_basedir, "Base source directory", "DIRECTORY"}, {"directory", 'd', 0, G_OPTION_ARG_FILENAME, &bala_compiler_directory, "Change output directory from current working directory", "DIRECTORY"}, {"version", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_version, "Display version number", NULL}, {"api-version", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_api_version, "Display API version number", NULL}, {"ccode", 'C', 0, G_OPTION_ARG_NONE, &bala_compiler_ccode_only, "Output C code", NULL}, {"header", 'H', 0, G_OPTION_ARG_FILENAME, &bala_compiler_header_filename, "Output C header file", "FILE"}, {"use-header", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_use_header, "Use C header file", NULL}, {"includedir", (gchar) 0, 0, G_OPTION_ARG_FILENAME, &bala_compiler_includedir, "Directory used to include the C header file", "DIRECTORY"}, {"internal-header", 'h', 0, G_OPTION_ARG_FILENAME, &bala_compiler_internal_header_filename, "Output internal C header file", "FILE"}, {"internal-bapi", (gchar) 0, 0, G_OPTION_ARG_FILENAME, &bala_compiler_internal_bapi_filename, "Output bapi with internal api", "FILE"}, {"fast-bapi", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_compiler_fast_bapi_filename, "Output bapi without performing symbol resolution", NULL}, {"use-fast-bapi", (gchar) 0, 0, G_OPTION_ARG_STRING_ARRAY, &bala_compiler_fast_bapis, "Use --fast-bapi output during this compile", NULL}, {"bapi-comments", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_bapi_comments, "Include comments in generated bapi", NULL}, {"deps", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_compiler_dependencies, "Write make-style dependency information to this file", NULL}, {"depfile", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_compiler_depfile, "Write make-style external dependency information for build systems to " \
"this file", NULL}, {"list-sources", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_list_sources, "Output a list of all source and binding files which are used", NULL}, {"symbols", (gchar) 0, 0, G_OPTION_ARG_FILENAME, &bala_compiler_symbols_filename, "Output symbols file", "FILE"}, {"compile", 'c', 0, G_OPTION_ARG_NONE, &bala_compiler_compile_only, "Compile but do not link", NULL}, {"output", 'o', 0, G_OPTION_ARG_FILENAME, &bala_compiler_output, "Place output in file FILE", "FILE"}, {"debug", 'g', 0, G_OPTION_ARG_NONE, &bala_compiler_debug, "Produce debug information", NULL}, {"thread", (gchar) 0, (gint) (G_OPTION_FLAG_OPTIONAL_ARG | G_OPTION_FLAG_NO_ARG), G_OPTION_ARG_CALLBACK, (void*) bala_compiler_option_deprecated, "Enable multithreading support (DEPRECATED AND IGNORED)", NULL}, {"enable-mem-profiler", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_mem_profiler, "Enable GLib memory profiler", NULL}, {"define", 'D', 0, G_OPTION_ARG_STRING_ARRAY, &bala_compiler_defines, "Define SYMBOL", "SYMBOL..."}, {"main", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_compiler_entry_point, "Use SYMBOL as entry point", "SYMBOL..."}, {"nostdpkg", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_nostdpkg, "Do not include standard packages", NULL}, {"disable-assert", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_disable_assert, "Disable assertions", NULL}, {"enable-checking", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_enable_checking, "Enable additional run-time checks", NULL}, {"enable-deprecated", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_deprecated, "Enable deprecated features", NULL}, {"hide-internal", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_hide_internal, "Hide symbols marked as internal", NULL}, {"enable-experimental", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_experimental, "Enable experimental features", NULL}, {"disable-warnings", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_disable_warnings, "Disable warnings", NULL}, {"fatal-warnings", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_fatal_warnings, "Treat warnings as fatal", NULL}, {"disable-since-check", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_disable_since_check, "Do not check whether used symbols exist in local packages", NULL}, {"keep-going", 'k', 0, G_OPTION_ARG_NONE, &bala_compiler_keep_going, "Continue as much as possible after an error", NULL}, {"enable-experimental-non-null", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_experimental_non_null, "Enable experimental enhancements for non-null types", NULL}, {"enable-gobject-tracing", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_gobject_tracing, "Enable GObject creation tracing", NULL}, {"cc", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_compiler_cc_command, "Use COMMAND as C compiler command", "COMMAND"}, {"Xcc", 'X', 0, G_OPTION_ARG_STRING_ARRAY, &bala_compiler_cc_options, "Pass OPTION to the C compiler", "OPTION..."}, {"pkg-config", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_compiler_pkg_config_command, "Use COMMAND as pkg-config command", "COMMAND"}, {"dump-tree", (gchar) 0, 0, G_OPTION_ARG_FILENAME, &bala_compiler_dump_tree, "Write code tree to FILE", "FILE"}, {"save-temps", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_save_temps, "Keep temporary files", NULL}, {"profile", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_compiler_profile, "Use the given profile instead of the default", "PROFILE"}, {"quiet", 'q', 0, G_OPTION_ARG_NONE, &bala_compiler_quiet_mode, "Do not print messages to the console", NULL}, {"verbose", 'v', 0, G_OPTION_ARG_NONE, &bala_compiler_verbose_mode, "Print additional messages to the console", NULL}, {"no-color", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_disable_colored_output, "Disable colored output, alias for --color=never", NULL}, {"color", (gchar) 0, (gint) G_OPTION_FLAG_OPTIONAL_ARG, G_OPTION_ARG_CALLBACK, (void*) bala_compiler_option_parse_color, "Enable color output, options are 'always', 'never', or 'auto'", "WHEN"}, {"target-glib", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_compiler_target_glib, "Target version of glib for code generation", "'MAJOR.MINOR', or 'auto'"}, {"gresources", (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &bala_compiler_gresources, "XML of gresources", "FILE..."}, {"gresourcesdir", (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &bala_compiler_gresources_directories, "Look for resources in DIRECTORY", "DIRECTORY..."}, {"enable-version-header", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_enable_version_header, "Write bala build version in generated files", NULL}, {"disable-version-header", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_disable_version_header, "Do not write bala build version in generated files", NULL}, {"run-args", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_compiler_run_args, "Arguments passed to directly compiled executable", NULL}, {"abi-stability", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_compiler_abi_stability, "Enable support for ABI stability", NULL}, {G_OPTION_REMAINING, (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &bala_compiler_sources, NULL, "FILE..."}, {NULL}};

static inline gpointer
bala_compiler_get_instance_private (BalaCompiler* self)
{
	return G_STRUCT_MEMBER_P (self, BalaCompiler_private_offset);
}

static gboolean
bala_compiler_option_parse_color (const gchar* option_name,
                                  const gchar* val,
                                  void* data,
                                  GError** error)
{
	const gchar* _tmp0_;
	GQuark _tmp2_ = 0U;
	static GQuark _tmp1_label0 = 0;
	static GQuark _tmp1_label1 = 0;
	static GQuark _tmp1_label2 = 0;
	static GQuark _tmp1_label3 = 0;
	GError* _inner_error0_ = NULL;
	gboolean result = FALSE;
	g_return_val_if_fail (option_name != NULL, FALSE);
	_tmp0_ = val;
	_tmp2_ = (NULL == _tmp0_) ? 0 : g_quark_from_string (_tmp0_);
	if (_tmp2_ == ((0 != _tmp1_label0) ? _tmp1_label0 : (_tmp1_label0 = g_quark_from_static_string ("auto")))) {
		switch (0) {
			default:
			{
				bala_compiler_colored_output = BALA_REPORT_COLORED_AUTO;
				break;
			}
		}
	} else if (_tmp2_ == ((0 != _tmp1_label1) ? _tmp1_label1 : (_tmp1_label1 = g_quark_from_static_string ("never")))) {
		switch (0) {
			default:
			{
				bala_compiler_colored_output = BALA_REPORT_COLORED_NEVER;
				break;
			}
		}
	} else if ((_tmp2_ == ((0 != _tmp1_label2) ? _tmp1_label2 : (_tmp1_label2 = g_quark_from_static_string (NULL)))) || (_tmp2_ == ((0 != _tmp1_label3) ? _tmp1_label3 : (_tmp1_label3 = g_quark_from_static_string ("always"))))) {
		switch (0) {
			default:
			{
				bala_compiler_colored_output = BALA_REPORT_COLORED_ALWAYS;
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				GError* _tmp3_;
				_tmp3_ = g_error_new (G_OPTION_ERROR, G_OPTION_ERROR_FAILED, "Invalid --color argument '%s'", val);
				_inner_error0_ = _tmp3_;
				if (_inner_error0_->domain == G_OPTION_ERROR) {
					gboolean _tmp4_ = FALSE;
					g_propagate_error (error, _inner_error0_);
					return _tmp4_;
				} else {
					gboolean _tmp5_ = FALSE;
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
					g_clear_error (&_inner_error0_);
					return _tmp5_;
				}
			}
		}
	}
	result = TRUE;
	return result;
}

static gboolean
bala_compiler_option_deprecated (const gchar* option_name,
                                 const gchar* val,
                                 void* data,
                                 GError** error)
{
	FILE* _tmp0_;
	gboolean result = FALSE;
	g_return_val_if_fail (option_name != NULL, FALSE);
	_tmp0_ = stdout;
	fprintf (_tmp0_, "Command-line option `%s` is deprecated and will be ignored\n", option_name);
	result = TRUE;
	return result;
}

static gint
bala_compiler_quit (BalaCompiler* self)
{
	gboolean _tmp0_ = FALSE;
	BalaCodeContext* _tmp1_;
	BalaReport* _tmp2_;
	BalaReport* _tmp3_;
	gboolean _tmp7_ = FALSE;
	BalaCodeContext* _tmp8_;
	BalaReport* _tmp9_;
	BalaReport* _tmp10_;
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp1_ = self->priv->context;
	_tmp2_ = bala_code_context_get_report (_tmp1_);
	_tmp3_ = _tmp2_;
	if (bala_report_get_errors (_tmp3_) == 0) {
		BalaCodeContext* _tmp4_;
		BalaReport* _tmp5_;
		BalaReport* _tmp6_;
		_tmp4_ = self->priv->context;
		_tmp5_ = bala_code_context_get_report (_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp0_ = bala_report_get_warnings (_tmp6_) == 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		bala_code_context_pop ();
		result = 0;
		return result;
	}
	_tmp8_ = self->priv->context;
	_tmp9_ = bala_code_context_get_report (_tmp8_);
	_tmp10_ = _tmp9_;
	if (bala_report_get_errors (_tmp10_) == 0) {
		gboolean _tmp11_ = FALSE;
		if (!bala_compiler_fatal_warnings) {
			_tmp11_ = TRUE;
		} else {
			BalaCodeContext* _tmp12_;
			BalaReport* _tmp13_;
			BalaReport* _tmp14_;
			_tmp12_ = self->priv->context;
			_tmp13_ = bala_code_context_get_report (_tmp12_);
			_tmp14_ = _tmp13_;
			_tmp11_ = bala_report_get_warnings (_tmp14_) == 0;
		}
		_tmp7_ = _tmp11_;
	} else {
		_tmp7_ = FALSE;
	}
	if (_tmp7_) {
		if (!bala_compiler_quiet_mode) {
			FILE* _tmp15_;
			BalaCodeContext* _tmp16_;
			BalaReport* _tmp17_;
			BalaReport* _tmp18_;
			_tmp15_ = stdout;
			_tmp16_ = self->priv->context;
			_tmp17_ = bala_code_context_get_report (_tmp16_);
			_tmp18_ = _tmp17_;
			fprintf (_tmp15_, "Compilation succeeded - %d warning(s)\n", bala_report_get_warnings (_tmp18_));
		}
		bala_code_context_pop ();
		result = 0;
		return result;
	} else {
		if (!bala_compiler_quiet_mode) {
			FILE* _tmp19_;
			BalaCodeContext* _tmp20_;
			BalaReport* _tmp21_;
			BalaReport* _tmp22_;
			BalaCodeContext* _tmp23_;
			BalaReport* _tmp24_;
			BalaReport* _tmp25_;
			_tmp19_ = stdout;
			_tmp20_ = self->priv->context;
			_tmp21_ = bala_code_context_get_report (_tmp20_);
			_tmp22_ = _tmp21_;
			_tmp23_ = self->priv->context;
			_tmp24_ = bala_code_context_get_report (_tmp23_);
			_tmp25_ = _tmp24_;
			fprintf (_tmp19_, "Compilation failed: %d error(s), %d warning(s)\n", bala_report_get_errors (_tmp22_), bala_report_get_warnings (_tmp25_));
		}
		bala_code_context_pop ();
		result = 1;
		return result;
	}
}

static gint
string_last_index_of_char (const gchar* self,
                           gunichar c,
                           gint start_index)
{
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = g_utf8_strrchr (((gchar*) self) + start_index, (gssize) -1, c);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	if (_tmp1_ != NULL) {
		gchar* _tmp2_;
		_tmp2_ = _result_;
		result = (gint) (_tmp2_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}

static glong
string_strnlen (gchar* str,
                glong maxlen)
{
	gchar* end = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	glong result = 0L;
	_tmp0_ = memchr (str, 0, (gsize) maxlen);
	end = _tmp0_;
	_tmp1_ = end;
	if (_tmp1_ == NULL) {
		result = maxlen;
		return result;
	} else {
		gchar* _tmp2_;
		_tmp2_ = end;
		result = (glong) (_tmp2_ - str);
		return result;
	}
}

static gchar*
string_substring (const gchar* self,
                  glong offset,
                  glong len)
{
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	gchar* _tmp3_;
	gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	if (offset >= ((glong) 0)) {
		_tmp0_ = len >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		string_length = string_strnlen ((gchar*) self, offset + len);
	} else {
		gint _tmp1_;
		gint _tmp2_;
		_tmp1_ = strlen (self);
		_tmp2_ = _tmp1_;
		string_length = (glong) _tmp2_;
	}
	if (offset < ((glong) 0)) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= ((glong) 0), NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < ((glong) 0)) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	_tmp3_ = g_strndup (((gchar*) self) + offset, (gsize) len);
	result = _tmp3_;
	return result;
}

static gpointer
_bala_iterable_ref0 (gpointer self)
{
	return self ? bala_iterable_ref (self) : NULL;
}

static gchar
string_get (const gchar* self,
            glong index)
{
	gchar _tmp0_;
	gchar result = '\0';
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = ((gchar*) self)[index];
	result = _tmp0_;
	return result;
}

static gboolean
string_contains (const gchar* self,
                 const gchar* needle)
{
	gchar* _tmp0_;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}

static gint
bala_compiler_run (BalaCompiler* self)
{
	BalaCodeContext* _tmp0_;
	BalaCodeContext* _tmp1_;
	BalaReportColored _tmp2_;
	gboolean _tmp14_ = FALSE;
	gboolean _tmp15_ = FALSE;
	BalaCodeContext* _tmp26_;
	BalaCodeContext* _tmp27_;
	BalaCodeContext* _tmp28_;
	BalaCodeContext* _tmp29_;
	BalaCodeContext* _tmp30_;
	BalaCodeContext* _tmp31_;
	BalaCodeContext* _tmp32_;
	BalaCodeContext* _tmp33_;
	BalaCodeContext* _tmp34_;
	BalaCodeContext* _tmp35_;
	BalaReport* _tmp36_;
	BalaReport* _tmp37_;
	BalaCodeContext* _tmp38_;
	BalaReport* _tmp39_;
	BalaReport* _tmp40_;
	BalaCodeContext* _tmp41_;
	BalaCodeContext* _tmp42_;
	BalaCodeContext* _tmp43_;
	gboolean _tmp44_ = FALSE;
	BalaCodeContext* _tmp46_;
	BalaCodeContext* _tmp47_;
	BalaCodeContext* _tmp48_;
	const gchar* _tmp49_;
	gboolean _tmp50_ = FALSE;
	const gchar* _tmp51_;
	BalaCodeContext* _tmp52_;
	BalaCodeContext* _tmp53_;
	const gchar* _tmp54_;
	BalaCodeContext* _tmp55_;
	const gchar* _tmp56_;
	BalaCodeContext* _tmp57_;
	const gchar* _tmp58_;
	BalaCodeContext* _tmp59_;
	const gchar* _tmp60_;
	gboolean _tmp61_ = FALSE;
	const gchar* _tmp62_;
	const gchar* _tmp63_;
	const gchar* _tmp71_;
	BalaCodeContext* _tmp80_;
	gchar** _tmp81_;
	gint _tmp81__length1;
	BalaCodeContext* _tmp82_;
	BalaCodeContext* _tmp83_;
	gchar** _tmp84_;
	gint _tmp84__length1;
	BalaCodeContext* _tmp85_;
	gchar** _tmp86_;
	gint _tmp86__length1;
	BalaCodeContext* _tmp87_;
	BalaCodeContext* _tmp88_;
	BalaCodeContext* _tmp89_;
	gboolean _tmp90_ = FALSE;
	const gchar* _tmp91_;
	const gchar* _tmp104_;
	BalaCodeContext* _tmp105_;
	BalaCodeContext* _tmp106_;
	const gchar* _tmp107_;
	BalaCodeContext* _tmp108_;
	const gchar* _tmp109_;
	BalaCodeContext* _tmp113_;
	const gchar* _tmp114_;
	gchar** _tmp115_;
	gint _tmp115__length1;
	BalaCodeContext* _tmp120_;
	BalaProfile _tmp121_;
	BalaProfile _tmp122_;
	gchar** _tmp132_;
	gint _tmp132__length1;
	gchar** _tmp137_;
	gint _tmp137__length1;
	BalaCodeContext* _tmp148_;
	gchar** _tmp149_;
	gint _tmp149__length1;
	BalaCodeContext* _tmp150_;
	gchar** _tmp151_;
	gint _tmp151__length1;
	gboolean _tmp152_ = FALSE;
	BalaCodeContext* _tmp153_;
	BalaReport* _tmp154_;
	BalaReport* _tmp155_;
	BalaCodeContext* _tmp160_;
	BalaProfile _tmp161_;
	BalaProfile _tmp162_;
	gboolean has_c_files = FALSE;
	gboolean has_h_files = FALSE;
	gchar** _tmp169_;
	gint _tmp169__length1;
	gboolean _tmp175_ = FALSE;
	gboolean _tmp177_ = FALSE;
	BalaCodeContext* _tmp178_;
	BalaReport* _tmp179_;
	BalaReport* _tmp180_;
	BalaParser* parser = NULL;
	BalaParser* _tmp209_;
	BalaParser* _tmp210_;
	BalaCodeContext* _tmp211_;
	BalaGenieParser* genie_parser = NULL;
	BalaGenieParser* _tmp212_;
	BalaGenieParser* _tmp213_;
	BalaCodeContext* _tmp214_;
	BalaGirParser* gir_parser = NULL;
	BalaGirParser* _tmp215_;
	BalaGirParser* _tmp216_;
	BalaCodeContext* _tmp217_;
	gboolean _tmp218_ = FALSE;
	BalaCodeContext* _tmp219_;
	BalaReport* _tmp220_;
	BalaReport* _tmp221_;
	const gchar* _tmp226_;
	BalaCodeContext* _tmp231_;
	gboolean _tmp232_ = FALSE;
	BalaCodeContext* _tmp233_;
	BalaReport* _tmp234_;
	BalaReport* _tmp235_;
	gboolean _tmp240_ = FALSE;
	gboolean _tmp241_ = FALSE;
	const gchar* _tmp247_;
	gboolean _tmp252_ = FALSE;
	BalaCodeContext* _tmp253_;
	BalaReport* _tmp254_;
	BalaReport* _tmp255_;
	BalaCodeContext* _tmp260_;
	BalaCodeGenerator* _tmp261_;
	BalaCodeGenerator* _tmp262_;
	BalaCodeContext* _tmp263_;
	gboolean _tmp264_ = FALSE;
	BalaCodeContext* _tmp265_;
	BalaReport* _tmp266_;
	BalaReport* _tmp267_;
	gboolean _tmp272_ = FALSE;
	const gchar* _tmp273_;
	const gchar* _tmp277_;
	const gchar* _tmp324_;
	const gchar* _tmp337_;
	const gchar* _tmp380_;
	const gchar* _tmp383_;
	gboolean _tmp386_ = FALSE;
	BalaCodeContext* _tmp387_;
	BalaReport* _tmp388_;
	BalaReport* _tmp389_;
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = bala_code_context_new ();
	_bala_code_context_unref0 (self->priv->context);
	self->priv->context = _tmp0_;
	_tmp1_ = self->priv->context;
	bala_code_context_push (_tmp1_);
	if (bala_compiler_disable_colored_output) {
		bala_compiler_colored_output = BALA_REPORT_COLORED_NEVER;
	}
	_tmp2_ = bala_compiler_colored_output;
	if (_tmp2_ != BALA_REPORT_COLORED_NEVER) {
		const gchar* env_colors = NULL;
		const gchar* _tmp3_;
		const gchar* _tmp4_;
		_tmp3_ = g_getenv ("BALA_COLORS");
		env_colors = _tmp3_;
		_tmp4_ = env_colors;
		if (_tmp4_ != NULL) {
			BalaCodeContext* _tmp5_;
			BalaReport* _tmp6_;
			BalaReport* _tmp7_;
			const gchar* _tmp8_;
			BalaReportColored _tmp9_;
			_tmp5_ = self->priv->context;
			_tmp6_ = bala_code_context_get_report (_tmp5_);
			_tmp7_ = _tmp6_;
			_tmp8_ = env_colors;
			_tmp9_ = bala_compiler_colored_output;
			bala_report_set_colors (_tmp7_, _tmp8_, _tmp9_);
		} else {
			BalaCodeContext* _tmp10_;
			BalaReport* _tmp11_;
			BalaReport* _tmp12_;
			BalaReportColored _tmp13_;
			_tmp10_ = self->priv->context;
			_tmp11_ = bala_code_context_get_report (_tmp10_);
			_tmp12_ = _tmp11_;
			_tmp13_ = bala_compiler_colored_output;
			bala_report_set_colors (_tmp12_, BALA_COMPILER_DEFAULT_COLORS, _tmp13_);
		}
	}
	if (!bala_compiler_ccode_only) {
		_tmp15_ = !bala_compiler_compile_only;
	} else {
		_tmp15_ = FALSE;
	}
	if (_tmp15_) {
		const gchar* _tmp16_;
		_tmp16_ = bala_compiler_output;
		_tmp14_ = _tmp16_ == NULL;
	} else {
		_tmp14_ = FALSE;
	}
	if (_tmp14_) {
		gchar** _tmp17_;
		gint _tmp17__length1;
		const gchar* _tmp18_;
		_tmp17_ = bala_compiler_sources;
		_tmp17__length1 = _bala_array_length (bala_compiler_sources);
		_tmp18_ = _tmp17_[0];
		if (string_last_index_of_char (_tmp18_, (gunichar) '.', 0) != -1) {
			gint dot = 0;
			gchar** _tmp19_;
			gint _tmp19__length1;
			const gchar* _tmp20_;
			gchar** _tmp21_;
			gint _tmp21__length1;
			const gchar* _tmp22_;
			gchar* _tmp23_;
			gchar* _tmp24_;
			gchar* _tmp25_;
			_tmp19_ = bala_compiler_sources;
			_tmp19__length1 = _bala_array_length (bala_compiler_sources);
			_tmp20_ = _tmp19_[0];
			dot = string_last_index_of_char (_tmp20_, (gunichar) '.', 0);
			_tmp21_ = bala_compiler_sources;
			_tmp21__length1 = _bala_array_length (bala_compiler_sources);
			_tmp22_ = _tmp21_[0];
			_tmp23_ = string_substring (_tmp22_, (glong) 0, (glong) dot);
			_tmp24_ = _tmp23_;
			_tmp25_ = g_path_get_basename (_tmp24_);
			_g_free0 (bala_compiler_output);
			bala_compiler_output = _tmp25_;
			_g_free0 (_tmp24_);
		}
	}
	_tmp26_ = self->priv->context;
	bala_code_context_set_assert (_tmp26_, !bala_compiler_disable_assert);
	_tmp27_ = self->priv->context;
	bala_code_context_set_checking (_tmp27_, bala_compiler_enable_checking);
	_tmp28_ = self->priv->context;
	bala_code_context_set_deprecated (_tmp28_, bala_compiler_deprecated);
	_tmp29_ = self->priv->context;
	bala_code_context_set_since_check (_tmp29_, !bala_compiler_disable_since_check);
	_tmp30_ = self->priv->context;
	bala_code_context_set_hide_internal (_tmp30_, bala_compiler_hide_internal);
	_tmp31_ = self->priv->context;
	bala_code_context_set_experimental (_tmp31_, bala_compiler_experimental);
	_tmp32_ = self->priv->context;
	bala_code_context_set_experimental_non_null (_tmp32_, bala_compiler_experimental_non_null);
	_tmp33_ = self->priv->context;
	bala_code_context_set_gobject_tracing (_tmp33_, bala_compiler_gobject_tracing);
	_tmp34_ = self->priv->context;
	bala_code_context_set_keep_going (_tmp34_, bala_compiler_keep_going);
	_tmp35_ = self->priv->context;
	_tmp36_ = bala_code_context_get_report (_tmp35_);
	_tmp37_ = _tmp36_;
	bala_report_set_enable_warnings (_tmp37_, !bala_compiler_disable_warnings);
	_tmp38_ = self->priv->context;
	_tmp39_ = bala_code_context_get_report (_tmp38_);
	_tmp40_ = _tmp39_;
	bala_report_set_verbose_errors (_tmp40_, !bala_compiler_quiet_mode);
	_tmp41_ = self->priv->context;
	bala_code_context_set_verbose_mode (_tmp41_, bala_compiler_verbose_mode);
	_tmp42_ = self->priv->context;
	bala_code_context_set_version_header (_tmp42_, !bala_compiler_disable_version_header);
	_tmp43_ = self->priv->context;
	bala_code_context_set_ccode_only (_tmp43_, bala_compiler_ccode_only);
	if (bala_compiler_ccode_only) {
		gchar** _tmp45_;
		gint _tmp45__length1;
		_tmp45_ = bala_compiler_cc_options;
		_tmp45__length1 = _bala_array_length (bala_compiler_cc_options);
		_tmp44_ = _tmp45_ != NULL;
	} else {
		_tmp44_ = FALSE;
	}
	if (_tmp44_) {
		bala_report_warning (NULL, "-X has no effect when -C or --ccode is set");
	}
	_tmp46_ = self->priv->context;
	bala_code_context_set_abi_stability (_tmp46_, bala_compiler_abi_stability);
	_tmp47_ = self->priv->context;
	bala_code_context_set_compile_only (_tmp47_, bala_compiler_compile_only);
	_tmp48_ = self->priv->context;
	_tmp49_ = bala_compiler_header_filename;
	bala_code_context_set_header_filename (_tmp48_, _tmp49_);
	_tmp51_ = bala_compiler_header_filename;
	if (_tmp51_ == NULL) {
		_tmp50_ = bala_compiler_use_header;
	} else {
		_tmp50_ = FALSE;
	}
	if (_tmp50_) {
		bala_report_error (NULL, "--use-header may only be used in combination with --header");
	}
	_tmp52_ = self->priv->context;
	bala_code_context_set_use_header (_tmp52_, bala_compiler_use_header);
	_tmp53_ = self->priv->context;
	_tmp54_ = bala_compiler_internal_header_filename;
	bala_code_context_set_internal_header_filename (_tmp53_, _tmp54_);
	_tmp55_ = self->priv->context;
	_tmp56_ = bala_compiler_symbols_filename;
	bala_code_context_set_symbols_filename (_tmp55_, _tmp56_);
	_tmp57_ = self->priv->context;
	_tmp58_ = bala_compiler_includedir;
	bala_code_context_set_includedir (_tmp57_, _tmp58_);
	_tmp59_ = self->priv->context;
	_tmp60_ = bala_compiler_output;
	bala_code_context_set_output (_tmp59_, _tmp60_);
	_tmp62_ = bala_compiler_output;
	if (_tmp62_ != NULL) {
		_tmp61_ = bala_compiler_ccode_only;
	} else {
		_tmp61_ = FALSE;
	}
	if (_tmp61_) {
		bala_report_warning (NULL, "--output and -o have no effect when -C or --ccode is set");
	}
	_tmp63_ = bala_compiler_basedir;
	if (_tmp63_ == NULL) {
		BalaCodeContext* _tmp64_;
		gchar* _tmp65_;
		gchar* _tmp66_;
		_tmp64_ = self->priv->context;
		_tmp65_ = bala_code_context_realpath (".");
		_tmp66_ = _tmp65_;
		bala_code_context_set_basedir (_tmp64_, _tmp66_);
		_g_free0 (_tmp66_);
	} else {
		BalaCodeContext* _tmp67_;
		const gchar* _tmp68_;
		gchar* _tmp69_;
		gchar* _tmp70_;
		_tmp67_ = self->priv->context;
		_tmp68_ = bala_compiler_basedir;
		_tmp69_ = bala_code_context_realpath (_tmp68_);
		_tmp70_ = _tmp69_;
		bala_code_context_set_basedir (_tmp67_, _tmp70_);
		_g_free0 (_tmp70_);
	}
	_tmp71_ = bala_compiler_directory;
	if (_tmp71_ != NULL) {
		BalaCodeContext* _tmp72_;
		const gchar* _tmp73_;
		gchar* _tmp74_;
		gchar* _tmp75_;
		_tmp72_ = self->priv->context;
		_tmp73_ = bala_compiler_directory;
		_tmp74_ = bala_code_context_realpath (_tmp73_);
		_tmp75_ = _tmp74_;
		bala_code_context_set_directory (_tmp72_, _tmp75_);
		_g_free0 (_tmp75_);
	} else {
		BalaCodeContext* _tmp76_;
		BalaCodeContext* _tmp77_;
		const gchar* _tmp78_;
		const gchar* _tmp79_;
		_tmp76_ = self->priv->context;
		_tmp77_ = self->priv->context;
		_tmp78_ = bala_code_context_get_basedir (_tmp77_);
		_tmp79_ = _tmp78_;
		bala_code_context_set_directory (_tmp76_, _tmp79_);
	}
	_tmp80_ = self->priv->context;
	_tmp81_ = bala_compiler_bapi_directories;
	_tmp81__length1 = _bala_array_length (bala_compiler_bapi_directories);
	bala_code_context_set_bapi_directories (_tmp80_, _tmp81_, _tmp81__length1);
	_tmp82_ = self->priv->context;
	bala_code_context_set_bapi_comments (_tmp82_, bala_compiler_bapi_comments);
	_tmp83_ = self->priv->context;
	_tmp84_ = bala_compiler_gir_directories;
	_tmp84__length1 = _bala_array_length (bala_compiler_gir_directories);
	bala_code_context_set_gir_directories (_tmp83_, _tmp84_, _tmp84__length1);
	_tmp85_ = self->priv->context;
	_tmp86_ = bala_compiler_metadata_directories;
	_tmp86__length1 = _bala_array_length (bala_compiler_metadata_directories);
	bala_code_context_set_metadata_directories (_tmp85_, _tmp86_, _tmp86__length1);
	_tmp87_ = self->priv->context;
	bala_code_context_set_debug (_tmp87_, bala_compiler_debug);
	_tmp88_ = self->priv->context;
	bala_code_context_set_mem_profiler (_tmp88_, bala_compiler_mem_profiler);
	_tmp89_ = self->priv->context;
	bala_code_context_set_save_temps (_tmp89_, bala_compiler_save_temps);
	if (bala_compiler_ccode_only) {
		_tmp90_ = bala_compiler_save_temps;
	} else {
		_tmp90_ = FALSE;
	}
	if (_tmp90_) {
		bala_report_warning (NULL, "--save-temps has no effect when -C or --ccode is set");
	}
	_tmp91_ = bala_compiler_profile;
	if (g_strcmp0 (_tmp91_, "posix") == 0) {
		BalaCodeContext* _tmp92_;
		BalaCodeContext* _tmp93_;
		_tmp92_ = self->priv->context;
		bala_code_context_set_profile (_tmp92_, BALA_PROFILE_POSIX);
		_tmp93_ = self->priv->context;
		bala_code_context_add_define (_tmp93_, "POSIX");
	} else {
		gboolean _tmp94_ = FALSE;
		gboolean _tmp95_ = FALSE;
		const gchar* _tmp96_;
		_tmp96_ = bala_compiler_profile;
		if (g_strcmp0 (_tmp96_, "gobject-2.0") == 0) {
			_tmp95_ = TRUE;
		} else {
			const gchar* _tmp97_;
			_tmp97_ = bala_compiler_profile;
			_tmp95_ = g_strcmp0 (_tmp97_, "gobject") == 0;
		}
		if (_tmp95_) {
			_tmp94_ = TRUE;
		} else {
			const gchar* _tmp98_;
			_tmp98_ = bala_compiler_profile;
			_tmp94_ = _tmp98_ == NULL;
		}
		if (_tmp94_) {
			BalaCodeContext* _tmp99_;
			BalaCodeContext* _tmp100_;
			_tmp99_ = self->priv->context;
			bala_code_context_set_profile (_tmp99_, BALA_PROFILE_GOBJECT);
			_tmp100_ = self->priv->context;
			bala_code_context_add_define (_tmp100_, "GOBJECT");
		} else {
			const gchar* _tmp101_;
			gchar* _tmp102_;
			gchar* _tmp103_;
			_tmp101_ = bala_compiler_profile;
			_tmp102_ = g_strdup_printf ("Unknown profile %s", _tmp101_);
			_tmp103_ = _tmp102_;
			bala_report_error (NULL, _tmp103_);
			_g_free0 (_tmp103_);
		}
	}
	_tmp104_ = bala_compiler_fast_bapi_filename;
	bala_compiler_nostdpkg = bala_compiler_nostdpkg | (_tmp104_ != NULL);
	_tmp105_ = self->priv->context;
	bala_code_context_set_nostdpkg (_tmp105_, bala_compiler_nostdpkg);
	_tmp106_ = self->priv->context;
	_tmp107_ = bala_compiler_entry_point;
	bala_code_context_set_entry_point_name (_tmp106_, _tmp107_);
	_tmp108_ = self->priv->context;
	bala_code_context_set_run_output (_tmp108_, bala_compiler_run_output);
	_tmp109_ = bala_compiler_pkg_config_command;
	if (_tmp109_ == NULL) {
		const gchar* _tmp110_ = NULL;
		const gchar* _tmp111_;
		gchar* _tmp112_;
		_tmp111_ = g_getenv ("PKG_CONFIG");
		_tmp110_ = _tmp111_;
		if (_tmp110_ == NULL) {
			_tmp110_ = "pkg-config";
		}
		_tmp112_ = g_strdup (_tmp110_);
		_g_free0 (bala_compiler_pkg_config_command);
		bala_compiler_pkg_config_command = _tmp112_;
	}
	_tmp113_ = self->priv->context;
	_tmp114_ = bala_compiler_pkg_config_command;
	bala_code_context_set_pkg_config_command (_tmp113_, _tmp114_);
	_tmp115_ = bala_compiler_defines;
	_tmp115__length1 = _bala_array_length (bala_compiler_defines);
	if (_tmp115_ != NULL) {
		gchar** _tmp116_;
		gint _tmp116__length1;
		_tmp116_ = bala_compiler_defines;
		_tmp116__length1 = _bala_array_length (bala_compiler_defines);
		{
			gchar** define_collection = NULL;
			gint define_collection_length1 = 0;
			gint _define_collection_size_ = 0;
			gint define_it = 0;
			define_collection = _tmp116_;
			define_collection_length1 = _tmp116__length1;
			for (define_it = 0; define_it < define_collection_length1; define_it = define_it + 1) {
				gchar* _tmp117_;
				gchar* define = NULL;
				_tmp117_ = g_strdup (define_collection[define_it]);
				define = _tmp117_;
				{
					BalaCodeContext* _tmp118_;
					const gchar* _tmp119_;
					_tmp118_ = self->priv->context;
					_tmp119_ = define;
					bala_code_context_add_define (_tmp118_, _tmp119_);
					_g_free0 (define);
				}
			}
		}
	}
	_tmp120_ = self->priv->context;
	_tmp121_ = bala_code_context_get_profile (_tmp120_);
	_tmp122_ = _tmp121_;
	if (_tmp122_ == BALA_PROFILE_POSIX) {
		if (!bala_compiler_nostdpkg) {
			BalaCodeContext* _tmp123_;
			_tmp123_ = self->priv->context;
			bala_code_context_add_external_package (_tmp123_, "posix");
		}
	} else {
		BalaCodeContext* _tmp124_;
		BalaProfile _tmp125_;
		BalaProfile _tmp126_;
		_tmp124_ = self->priv->context;
		_tmp125_ = bala_code_context_get_profile (_tmp124_);
		_tmp126_ = _tmp125_;
		if (_tmp126_ == BALA_PROFILE_GOBJECT) {
			const gchar* _tmp127_;
			_tmp127_ = bala_compiler_target_glib;
			if (_tmp127_ != NULL) {
				BalaCodeContext* _tmp128_;
				const gchar* _tmp129_;
				_tmp128_ = self->priv->context;
				_tmp129_ = bala_compiler_target_glib;
				bala_code_context_set_target_glib_version (_tmp128_, _tmp129_);
			}
			if (!bala_compiler_nostdpkg) {
				BalaCodeContext* _tmp130_;
				BalaCodeContext* _tmp131_;
				_tmp130_ = self->priv->context;
				bala_code_context_add_external_package (_tmp130_, "glib-2.0");
				_tmp131_ = self->priv->context;
				bala_code_context_add_external_package (_tmp131_, "gobject-2.0");
			}
		}
	}
	_tmp132_ = bala_compiler_packages;
	_tmp132__length1 = _bala_array_length (bala_compiler_packages);
	if (_tmp132_ != NULL) {
		gchar** _tmp133_;
		gint _tmp133__length1;
		_tmp133_ = bala_compiler_packages;
		_tmp133__length1 = _bala_array_length (bala_compiler_packages);
		{
			gchar** package_collection = NULL;
			gint package_collection_length1 = 0;
			gint _package_collection_size_ = 0;
			gint package_it = 0;
			package_collection = _tmp133_;
			package_collection_length1 = _tmp133__length1;
			for (package_it = 0; package_it < package_collection_length1; package_it = package_it + 1) {
				gchar* _tmp134_;
				gchar* package = NULL;
				_tmp134_ = g_strdup (package_collection[package_it]);
				package = _tmp134_;
				{
					BalaCodeContext* _tmp135_;
					const gchar* _tmp136_;
					_tmp135_ = self->priv->context;
					_tmp136_ = package;
					bala_code_context_add_external_package (_tmp135_, _tmp136_);
					_g_free0 (package);
				}
			}
		}
		bala_compiler_packages = (_bala_array_free (bala_compiler_packages, _bala_array_length (bala_compiler_packages), (GDestroyNotify) g_free), NULL);
		bala_compiler_packages = NULL;
	}
	_tmp137_ = bala_compiler_fast_bapis;
	_tmp137__length1 = _bala_array_length (bala_compiler_fast_bapis);
	if (_tmp137_ != NULL) {
		gchar** _tmp138_;
		gint _tmp138__length1;
		BalaCodeContext* _tmp147_;
		_tmp138_ = bala_compiler_fast_bapis;
		_tmp138__length1 = _bala_array_length (bala_compiler_fast_bapis);
		{
			gchar** bapi_collection = NULL;
			gint bapi_collection_length1 = 0;
			gint _bapi_collection_size_ = 0;
			gint bapi_it = 0;
			bapi_collection = _tmp138_;
			bapi_collection_length1 = _tmp138__length1;
			for (bapi_it = 0; bapi_it < bapi_collection_length1; bapi_it = bapi_it + 1) {
				gchar* _tmp139_;
				gchar* bapi = NULL;
				_tmp139_ = g_strdup (bapi_collection[bapi_it]);
				bapi = _tmp139_;
				{
					gchar* rpath = NULL;
					const gchar* _tmp140_;
					gchar* _tmp141_;
					BalaSourceFile* source_file = NULL;
					BalaCodeContext* _tmp142_;
					const gchar* _tmp143_;
					BalaSourceFile* _tmp144_;
					BalaCodeContext* _tmp145_;
					BalaSourceFile* _tmp146_;
					_tmp140_ = bapi;
					_tmp141_ = bala_code_context_realpath (_tmp140_);
					rpath = _tmp141_;
					_tmp142_ = self->priv->context;
					_tmp143_ = rpath;
					_tmp144_ = bala_source_file_new (_tmp142_, BALA_SOURCE_FILE_TYPE_FAST, _tmp143_, NULL, FALSE);
					source_file = _tmp144_;
					_tmp145_ = self->priv->context;
					_tmp146_ = source_file;
					bala_code_context_add_source_file (_tmp145_, _tmp146_);
					_bala_source_file_unref0 (source_file);
					_g_free0 (rpath);
					_g_free0 (bapi);
				}
			}
		}
		_tmp147_ = self->priv->context;
		bala_code_context_set_use_fast_bapi (_tmp147_, TRUE);
	}
	_tmp148_ = self->priv->context;
	_tmp149_ = bala_compiler_gresources;
	_tmp149__length1 = _bala_array_length (bala_compiler_gresources);
	bala_code_context_set_gresources (_tmp148_, _tmp149_, _tmp149__length1);
	_tmp150_ = self->priv->context;
	_tmp151_ = bala_compiler_gresources_directories;
	_tmp151__length1 = _bala_array_length (bala_compiler_gresources_directories);
	bala_code_context_set_gresources_directories (_tmp150_, _tmp151_, _tmp151__length1);
	_tmp153_ = self->priv->context;
	_tmp154_ = bala_code_context_get_report (_tmp153_);
	_tmp155_ = _tmp154_;
	if (bala_report_get_errors (_tmp155_) > 0) {
		_tmp152_ = TRUE;
	} else {
		gboolean _tmp156_ = FALSE;
		if (bala_compiler_fatal_warnings) {
			BalaCodeContext* _tmp157_;
			BalaReport* _tmp158_;
			BalaReport* _tmp159_;
			_tmp157_ = self->priv->context;
			_tmp158_ = bala_code_context_get_report (_tmp157_);
			_tmp159_ = _tmp158_;
			_tmp156_ = bala_report_get_warnings (_tmp159_) > 0;
		} else {
			_tmp156_ = FALSE;
		}
		_tmp152_ = _tmp156_;
	}
	if (_tmp152_) {
		result = bala_compiler_quit (self);
		return result;
	}
	_tmp160_ = self->priv->context;
	_tmp161_ = bala_code_context_get_profile (_tmp160_);
	_tmp162_ = _tmp161_;
	if (_tmp162_ == BALA_PROFILE_GOBJECT) {
		BalaCodeContext* _tmp163_;
		BalaGDBusServerModule* _tmp164_;
		BalaGDBusServerModule* _tmp165_;
		_tmp163_ = self->priv->context;
		_tmp164_ = bala_gd_bus_server_module_new ();
		_tmp165_ = _tmp164_;
		bala_code_context_set_codegen (_tmp163_, (BalaCodeGenerator*) _tmp165_);
		_bala_code_visitor_unref0 (_tmp165_);
	} else {
		BalaCodeContext* _tmp166_;
		BalaCCodeDelegateModule* _tmp167_;
		BalaCCodeDelegateModule* _tmp168_;
		_tmp166_ = self->priv->context;
		_tmp167_ = bala_ccode_delegate_module_new ();
		_tmp168_ = _tmp167_;
		bala_code_context_set_codegen (_tmp166_, (BalaCodeGenerator*) _tmp168_);
		_bala_code_visitor_unref0 (_tmp168_);
	}
	has_c_files = FALSE;
	has_h_files = FALSE;
	_tmp169_ = bala_compiler_sources;
	_tmp169__length1 = _bala_array_length (bala_compiler_sources);
	{
		gchar** source_collection = NULL;
		gint source_collection_length1 = 0;
		gint _source_collection_size_ = 0;
		gint source_it = 0;
		source_collection = _tmp169_;
		source_collection_length1 = _tmp169__length1;
		for (source_it = 0; source_it < source_collection_length1; source_it = source_it + 1) {
			gchar* _tmp170_;
			gchar* source = NULL;
			_tmp170_ = g_strdup (source_collection[source_it]);
			source = _tmp170_;
			{
				BalaCodeContext* _tmp171_;
				const gchar* _tmp172_;
				_tmp171_ = self->priv->context;
				_tmp172_ = source;
				if (bala_code_context_add_source_filename (_tmp171_, _tmp172_, bala_compiler_run_output, TRUE)) {
					const gchar* _tmp173_;
					_tmp173_ = source;
					if (g_str_has_suffix (_tmp173_, ".c")) {
						has_c_files = TRUE;
					} else {
						const gchar* _tmp174_;
						_tmp174_ = source;
						if (g_str_has_suffix (_tmp174_, ".h")) {
							has_h_files = TRUE;
						}
					}
				}
				_g_free0 (source);
			}
		}
	}
	bala_compiler_sources = (_bala_array_free (bala_compiler_sources, _bala_array_length (bala_compiler_sources), (GDestroyNotify) g_free), NULL);
	bala_compiler_sources = NULL;
	if (bala_compiler_ccode_only) {
		gboolean _tmp176_ = FALSE;
		if (has_c_files) {
			_tmp176_ = TRUE;
		} else {
			_tmp176_ = has_h_files;
		}
		_tmp175_ = _tmp176_;
	} else {
		_tmp175_ = FALSE;
	}
	if (_tmp175_) {
		bala_report_warning (NULL, "C header and source files are ignored when -C or --ccode is set");
	}
	_tmp178_ = self->priv->context;
	_tmp179_ = bala_code_context_get_report (_tmp178_);
	_tmp180_ = _tmp179_;
	if (bala_report_get_errors (_tmp180_) > 0) {
		_tmp177_ = TRUE;
	} else {
		gboolean _tmp181_ = FALSE;
		if (bala_compiler_fatal_warnings) {
			BalaCodeContext* _tmp182_;
			BalaReport* _tmp183_;
			BalaReport* _tmp184_;
			_tmp182_ = self->priv->context;
			_tmp183_ = bala_code_context_get_report (_tmp182_);
			_tmp184_ = _tmp183_;
			_tmp181_ = bala_report_get_warnings (_tmp184_) > 0;
		} else {
			_tmp181_ = FALSE;
		}
		_tmp177_ = _tmp181_;
	}
	if (_tmp177_) {
		result = bala_compiler_quit (self);
		return result;
	}
	if (bala_compiler_list_sources) {
		{
			BalaList* _file_list = NULL;
			BalaCodeContext* _tmp185_;
			BalaList* _tmp186_;
			BalaList* _tmp187_;
			gint _file_size = 0;
			BalaList* _tmp188_;
			gint _tmp189_;
			gint _tmp190_;
			gint _file_index = 0;
			_tmp185_ = self->priv->context;
			_tmp186_ = bala_code_context_get_source_files (_tmp185_);
			_tmp187_ = _bala_iterable_ref0 (_tmp186_);
			_file_list = _tmp187_;
			_tmp188_ = _file_list;
			_tmp189_ = bala_collection_get_size ((BalaCollection*) _tmp188_);
			_tmp190_ = _tmp189_;
			_file_size = _tmp190_;
			_file_index = -1;
			while (TRUE) {
				gint _tmp191_;
				gint _tmp192_;
				BalaSourceFile* file = NULL;
				BalaList* _tmp193_;
				gpointer _tmp194_;
				BalaSourceFile* _tmp195_;
				const gchar* _tmp196_;
				const gchar* _tmp197_;
				_file_index = _file_index + 1;
				_tmp191_ = _file_index;
				_tmp192_ = _file_size;
				if (!(_tmp191_ < _tmp192_)) {
					break;
				}
				_tmp193_ = _file_list;
				_tmp194_ = bala_list_get (_tmp193_, _file_index);
				file = (BalaSourceFile*) _tmp194_;
				_tmp195_ = file;
				_tmp196_ = bala_source_file_get_filename (_tmp195_);
				_tmp197_ = _tmp196_;
				g_print ("%s\n", _tmp197_);
				_bala_source_file_unref0 (file);
			}
			_bala_iterable_unref0 (_file_list);
		}
		if (!bala_compiler_ccode_only) {
			{
				BalaList* _filename_list = NULL;
				BalaCodeContext* _tmp198_;
				BalaList* _tmp199_;
				BalaList* _tmp200_;
				gint _filename_size = 0;
				BalaList* _tmp201_;
				gint _tmp202_;
				gint _tmp203_;
				gint _filename_index = 0;
				_tmp198_ = self->priv->context;
				_tmp199_ = bala_code_context_get_c_source_files (_tmp198_);
				_tmp200_ = _bala_iterable_ref0 (_tmp199_);
				_filename_list = _tmp200_;
				_tmp201_ = _filename_list;
				_tmp202_ = bala_collection_get_size ((BalaCollection*) _tmp201_);
				_tmp203_ = _tmp202_;
				_filename_size = _tmp203_;
				_filename_index = -1;
				while (TRUE) {
					gint _tmp204_;
					gint _tmp205_;
					gchar* filename = NULL;
					BalaList* _tmp206_;
					gpointer _tmp207_;
					const gchar* _tmp208_;
					_filename_index = _filename_index + 1;
					_tmp204_ = _filename_index;
					_tmp205_ = _filename_size;
					if (!(_tmp204_ < _tmp205_)) {
						break;
					}
					_tmp206_ = _filename_list;
					_tmp207_ = bala_list_get (_tmp206_, _filename_index);
					filename = (gchar*) _tmp207_;
					_tmp208_ = filename;
					g_print ("%s\n", _tmp208_);
					_g_free0 (filename);
				}
				_bala_iterable_unref0 (_filename_list);
			}
		}
		result = 0;
		return result;
	}
	_tmp209_ = bala_parser_new ();
	parser = _tmp209_;
	_tmp210_ = parser;
	_tmp211_ = self->priv->context;
	bala_parser_parse (_tmp210_, _tmp211_);
	_tmp212_ = bala_genie_parser_new ();
	genie_parser = _tmp212_;
	_tmp213_ = genie_parser;
	_tmp214_ = self->priv->context;
	bala_genie_parser_parse (_tmp213_, _tmp214_);
	_tmp215_ = bala_gir_parser_new ();
	gir_parser = _tmp215_;
	_tmp216_ = gir_parser;
	_tmp217_ = self->priv->context;
	bala_gir_parser_parse (_tmp216_, _tmp217_);
	_tmp219_ = self->priv->context;
	_tmp220_ = bala_code_context_get_report (_tmp219_);
	_tmp221_ = _tmp220_;
	if (bala_report_get_errors (_tmp221_) > 0) {
		_tmp218_ = TRUE;
	} else {
		gboolean _tmp222_ = FALSE;
		if (bala_compiler_fatal_warnings) {
			BalaCodeContext* _tmp223_;
			BalaReport* _tmp224_;
			BalaReport* _tmp225_;
			_tmp223_ = self->priv->context;
			_tmp224_ = bala_code_context_get_report (_tmp223_);
			_tmp225_ = _tmp224_;
			_tmp222_ = bala_report_get_warnings (_tmp225_) > 0;
		} else {
			_tmp222_ = FALSE;
		}
		_tmp218_ = _tmp222_;
	}
	if (_tmp218_) {
		result = bala_compiler_quit (self);
		_bala_code_visitor_unref0 (gir_parser);
		_bala_code_visitor_unref0 (genie_parser);
		_bala_code_visitor_unref0 (parser);
		return result;
	}
	_tmp226_ = bala_compiler_fast_bapi_filename;
	if (_tmp226_ != NULL) {
		BalaCodeWriter* interface_writer = NULL;
		BalaCodeWriter* _tmp227_;
		BalaCodeWriter* _tmp228_;
		BalaCodeContext* _tmp229_;
		const gchar* _tmp230_;
		_tmp227_ = bala_code_writer_new (BALA_CODE_WRITER_TYPE_FAST);
		interface_writer = _tmp227_;
		_tmp228_ = interface_writer;
		_tmp229_ = self->priv->context;
		_tmp230_ = bala_compiler_fast_bapi_filename;
		bala_code_writer_write_file (_tmp228_, _tmp229_, _tmp230_);
		result = bala_compiler_quit (self);
		_bala_code_visitor_unref0 (interface_writer);
		_bala_code_visitor_unref0 (gir_parser);
		_bala_code_visitor_unref0 (genie_parser);
		_bala_code_visitor_unref0 (parser);
		return result;
	}
	_tmp231_ = self->priv->context;
	bala_code_context_check (_tmp231_);
	_tmp233_ = self->priv->context;
	_tmp234_ = bala_code_context_get_report (_tmp233_);
	_tmp235_ = _tmp234_;
	if (bala_report_get_errors (_tmp235_) > 0) {
		_tmp232_ = TRUE;
	} else {
		gboolean _tmp236_ = FALSE;
		if (bala_compiler_fatal_warnings) {
			BalaCodeContext* _tmp237_;
			BalaReport* _tmp238_;
			BalaReport* _tmp239_;
			_tmp237_ = self->priv->context;
			_tmp238_ = bala_code_context_get_report (_tmp237_);
			_tmp239_ = _tmp238_;
			_tmp236_ = bala_report_get_warnings (_tmp239_) > 0;
		} else {
			_tmp236_ = FALSE;
		}
		_tmp232_ = _tmp236_;
	}
	if (_tmp232_) {
		result = bala_compiler_quit (self);
		_bala_code_visitor_unref0 (gir_parser);
		_bala_code_visitor_unref0 (genie_parser);
		_bala_code_visitor_unref0 (parser);
		return result;
	}
	if (!bala_compiler_ccode_only) {
		_tmp241_ = !bala_compiler_compile_only;
	} else {
		_tmp241_ = FALSE;
	}
	if (_tmp241_) {
		const gchar* _tmp242_;
		_tmp242_ = bala_compiler_library;
		_tmp240_ = _tmp242_ == NULL;
	} else {
		_tmp240_ = FALSE;
	}
	if (_tmp240_) {
		gboolean _tmp243_ = FALSE;
		if (!has_c_files) {
			BalaCodeContext* _tmp244_;
			BalaMethod* _tmp245_;
			BalaMethod* _tmp246_;
			_tmp244_ = self->priv->context;
			_tmp245_ = bala_code_context_get_entry_point (_tmp244_);
			_tmp246_ = _tmp245_;
			_tmp243_ = _tmp246_ == NULL;
		} else {
			_tmp243_ = FALSE;
		}
		if (_tmp243_) {
			bala_report_error (NULL, "program does not contain a static `main' method");
		}
	}
	_tmp247_ = bala_compiler_dump_tree;
	if (_tmp247_ != NULL) {
		BalaCodeWriter* code_writer = NULL;
		BalaCodeWriter* _tmp248_;
		BalaCodeWriter* _tmp249_;
		BalaCodeContext* _tmp250_;
		const gchar* _tmp251_;
		_tmp248_ = bala_code_writer_new (BALA_CODE_WRITER_TYPE_DUMP);
		code_writer = _tmp248_;
		_tmp249_ = code_writer;
		_tmp250_ = self->priv->context;
		_tmp251_ = bala_compiler_dump_tree;
		bala_code_writer_write_file (_tmp249_, _tmp250_, _tmp251_);
		_bala_code_visitor_unref0 (code_writer);
	}
	_tmp253_ = self->priv->context;
	_tmp254_ = bala_code_context_get_report (_tmp253_);
	_tmp255_ = _tmp254_;
	if (bala_report_get_errors (_tmp255_) > 0) {
		_tmp252_ = TRUE;
	} else {
		gboolean _tmp256_ = FALSE;
		if (bala_compiler_fatal_warnings) {
			BalaCodeContext* _tmp257_;
			BalaReport* _tmp258_;
			BalaReport* _tmp259_;
			_tmp257_ = self->priv->context;
			_tmp258_ = bala_code_context_get_report (_tmp257_);
			_tmp259_ = _tmp258_;
			_tmp256_ = bala_report_get_warnings (_tmp259_) > 0;
		} else {
			_tmp256_ = FALSE;
		}
		_tmp252_ = _tmp256_;
	}
	if (_tmp252_) {
		result = bala_compiler_quit (self);
		_bala_code_visitor_unref0 (gir_parser);
		_bala_code_visitor_unref0 (genie_parser);
		_bala_code_visitor_unref0 (parser);
		return result;
	}
	_tmp260_ = self->priv->context;
	_tmp261_ = bala_code_context_get_codegen (_tmp260_);
	_tmp262_ = _tmp261_;
	_tmp263_ = self->priv->context;
	bala_code_generator_emit (_tmp262_, _tmp263_);
	_tmp265_ = self->priv->context;
	_tmp266_ = bala_code_context_get_report (_tmp265_);
	_tmp267_ = _tmp266_;
	if (bala_report_get_errors (_tmp267_) > 0) {
		_tmp264_ = TRUE;
	} else {
		gboolean _tmp268_ = FALSE;
		if (bala_compiler_fatal_warnings) {
			BalaCodeContext* _tmp269_;
			BalaReport* _tmp270_;
			BalaReport* _tmp271_;
			_tmp269_ = self->priv->context;
			_tmp270_ = bala_code_context_get_report (_tmp269_);
			_tmp271_ = _tmp270_;
			_tmp268_ = bala_report_get_warnings (_tmp271_) > 0;
		} else {
			_tmp268_ = FALSE;
		}
		_tmp264_ = _tmp268_;
	}
	if (_tmp264_) {
		result = bala_compiler_quit (self);
		_bala_code_visitor_unref0 (gir_parser);
		_bala_code_visitor_unref0 (genie_parser);
		_bala_code_visitor_unref0 (parser);
		return result;
	}
	_tmp273_ = bala_compiler_bapi_filename;
	if (_tmp273_ == NULL) {
		const gchar* _tmp274_;
		_tmp274_ = bala_compiler_library;
		_tmp272_ = _tmp274_ != NULL;
	} else {
		_tmp272_ = FALSE;
	}
	if (_tmp272_) {
		const gchar* _tmp275_;
		gchar* _tmp276_;
		_tmp275_ = bala_compiler_library;
		_tmp276_ = g_strdup_printf ("%s.bapi", _tmp275_);
		_g_free0 (bala_compiler_bapi_filename);
		bala_compiler_bapi_filename = _tmp276_;
	}
	_tmp277_ = bala_compiler_library;
	if (_tmp277_ != NULL) {
		const gchar* _tmp278_;
		_tmp278_ = bala_compiler_gir;
		if (_tmp278_ != NULL) {
			BalaCodeContext* _tmp279_;
			BalaProfile _tmp280_;
			BalaProfile _tmp281_;
			_tmp279_ = self->priv->context;
			_tmp280_ = bala_code_context_get_profile (_tmp279_);
			_tmp281_ = _tmp280_;
			if (_tmp281_ == BALA_PROFILE_GOBJECT) {
				gchar* gir_base = NULL;
				const gchar* _tmp282_;
				gchar* _tmp283_;
				glong gir_len = 0L;
				const gchar* _tmp284_;
				gint _tmp285_;
				gint _tmp286_;
				gint last_hyphen = 0;
				const gchar* _tmp287_;
				gboolean _tmp288_ = FALSE;
				_tmp282_ = bala_compiler_gir;
				_tmp283_ = g_path_get_basename (_tmp282_);
				gir_base = _tmp283_;
				_tmp284_ = gir_base;
				_tmp285_ = strlen (_tmp284_);
				_tmp286_ = _tmp285_;
				gir_len = (glong) _tmp286_;
				_tmp287_ = gir_base;
				last_hyphen = string_last_index_of_char (_tmp287_, (gunichar) '-', 0);
				if (last_hyphen == -1) {
					_tmp288_ = TRUE;
				} else {
					const gchar* _tmp289_;
					_tmp289_ = gir_base;
					_tmp288_ = !g_str_has_suffix (_tmp289_, ".gir");
				}
				if (_tmp288_) {
					const gchar* _tmp290_;
					gchar* _tmp291_;
					gchar* _tmp292_;
					_tmp290_ = bala_compiler_gir;
					_tmp291_ = g_strdup_printf ("GIR file name `%s' is not well-formed, expected NAME-VERSION.gir", _tmp290_);
					_tmp292_ = _tmp291_;
					bala_report_error (NULL, _tmp292_);
					_g_free0 (_tmp292_);
				} else {
					gchar* gir_namespace = NULL;
					const gchar* _tmp293_;
					gchar* _tmp294_;
					gchar* gir_version = NULL;
					const gchar* _tmp295_;
					gchar* _tmp296_;
					const gchar* _tmp297_;
					gboolean _tmp298_ = FALSE;
					gboolean _tmp299_ = FALSE;
					gboolean _tmp300_ = FALSE;
					const gchar* _tmp301_;
					_tmp293_ = gir_base;
					_tmp294_ = string_substring (_tmp293_, (glong) 0, (glong) last_hyphen);
					gir_namespace = _tmp294_;
					_tmp295_ = gir_base;
					_tmp296_ = string_substring (_tmp295_, (glong) (last_hyphen + 1), (gir_len - last_hyphen) - 5);
					gir_version = _tmp296_;
					_tmp297_ = gir_version;
					g_strcanon (_tmp297_, "0123456789.", '?');
					_tmp301_ = gir_namespace;
					if (g_strcmp0 (_tmp301_, "") == 0) {
						_tmp300_ = TRUE;
					} else {
						const gchar* _tmp302_;
						_tmp302_ = gir_version;
						_tmp300_ = g_strcmp0 (_tmp302_, "") == 0;
					}
					if (_tmp300_) {
						_tmp299_ = TRUE;
					} else {
						const gchar* _tmp303_;
						_tmp303_ = gir_version;
						_tmp299_ = !g_ascii_isdigit (string_get (_tmp303_, (glong) 0));
					}
					if (_tmp299_) {
						_tmp298_ = TRUE;
					} else {
						const gchar* _tmp304_;
						_tmp304_ = gir_version;
						_tmp298_ = string_contains (_tmp304_, "?");
					}
					if (_tmp298_) {
						const gchar* _tmp305_;
						gchar* _tmp306_;
						gchar* _tmp307_;
						_tmp305_ = bala_compiler_gir;
						_tmp306_ = g_strdup_printf ("GIR file name `%s' is not well-formed, expected NAME-VERSION.gir", _tmp305_);
						_tmp307_ = _tmp306_;
						bala_report_error (NULL, _tmp307_);
						_g_free0 (_tmp307_);
					} else {
						BalaGIRWriter* gir_writer = NULL;
						BalaGIRWriter* _tmp308_;
						gchar* gir_directory = NULL;
						gchar* _tmp309_;
						const gchar* _tmp310_;
						BalaGIRWriter* _tmp315_;
						BalaCodeContext* _tmp316_;
						const gchar* _tmp317_;
						const gchar* _tmp318_;
						const gchar* _tmp319_;
						const gchar* _tmp320_;
						const gchar* _tmp321_;
						const gchar* _tmp322_;
						_tmp308_ = bala_gir_writer_new ();
						gir_writer = _tmp308_;
						_tmp309_ = g_strdup (".");
						gir_directory = _tmp309_;
						_tmp310_ = bala_compiler_directory;
						if (_tmp310_ != NULL) {
							BalaCodeContext* _tmp311_;
							const gchar* _tmp312_;
							const gchar* _tmp313_;
							gchar* _tmp314_;
							_tmp311_ = self->priv->context;
							_tmp312_ = bala_code_context_get_directory (_tmp311_);
							_tmp313_ = _tmp312_;
							_tmp314_ = g_strdup (_tmp313_);
							_g_free0 (gir_directory);
							gir_directory = _tmp314_;
						}
						_tmp315_ = gir_writer;
						_tmp316_ = self->priv->context;
						_tmp317_ = gir_directory;
						_tmp318_ = bala_compiler_gir;
						_tmp319_ = gir_namespace;
						_tmp320_ = gir_version;
						_tmp321_ = bala_compiler_library;
						_tmp322_ = bala_compiler_shared_library;
						bala_gir_writer_write_file (_tmp315_, _tmp316_, _tmp317_, _tmp318_, _tmp319_, _tmp320_, _tmp321_, _tmp322_);
						_g_free0 (gir_directory);
						_bala_code_visitor_unref0 (gir_writer);
					}
					_g_free0 (gir_version);
					_g_free0 (gir_namespace);
				}
				_g_free0 (gir_base);
			}
			_g_free0 (bala_compiler_gir);
			bala_compiler_gir = NULL;
		}
		_g_free0 (bala_compiler_library);
		bala_compiler_library = NULL;
	} else {
		const gchar* _tmp323_;
		_tmp323_ = bala_compiler_gir;
		if (_tmp323_ != NULL) {
			bala_report_warning (NULL, "--gir has no effect without --library");
			_g_free0 (bala_compiler_gir);
			bala_compiler_gir = NULL;
		}
	}
	_tmp324_ = bala_compiler_bapi_filename;
	if (_tmp324_ != NULL) {
		BalaCodeWriter* interface_writer = NULL;
		BalaCodeWriter* _tmp325_;
		gboolean _tmp326_ = FALSE;
		const gchar* _tmp327_;
		BalaCodeWriter* _tmp334_;
		BalaCodeContext* _tmp335_;
		const gchar* _tmp336_;
		_tmp325_ = bala_code_writer_new (BALA_CODE_WRITER_TYPE_EXTERNAL);
		interface_writer = _tmp325_;
		_tmp327_ = bala_compiler_directory;
		if (_tmp327_ != NULL) {
			const gchar* _tmp328_;
			_tmp328_ = bala_compiler_bapi_filename;
			_tmp326_ = !g_path_is_absolute (_tmp328_);
		} else {
			_tmp326_ = FALSE;
		}
		if (_tmp326_) {
			BalaCodeContext* _tmp329_;
			const gchar* _tmp330_;
			const gchar* _tmp331_;
			const gchar* _tmp332_;
			gchar* _tmp333_;
			_tmp329_ = self->priv->context;
			_tmp330_ = bala_code_context_get_directory (_tmp329_);
			_tmp331_ = _tmp330_;
			_tmp332_ = bala_compiler_bapi_filename;
			_tmp333_ = g_strdup_printf ("%s%c%s", _tmp331_, (gint) G_DIR_SEPARATOR, _tmp332_);
			_g_free0 (bala_compiler_bapi_filename);
			bala_compiler_bapi_filename = _tmp333_;
		}
		_tmp334_ = interface_writer;
		_tmp335_ = self->priv->context;
		_tmp336_ = bala_compiler_bapi_filename;
		bala_code_writer_write_file (_tmp334_, _tmp335_, _tmp336_);
		_bala_code_visitor_unref0 (interface_writer);
	}
	_tmp337_ = bala_compiler_internal_bapi_filename;
	if (_tmp337_ != NULL) {
		gboolean _tmp338_ = FALSE;
		const gchar* _tmp339_;
		BalaCodeWriter* interface_writer = NULL;
		BalaCodeWriter* _tmp341_;
		BalaCodeContext* _tmp342_;
		const gchar* _tmp343_;
		const gchar* _tmp344_;
		gchar* bapi_filename = NULL;
		const gchar* _tmp367_;
		gchar* _tmp368_;
		gboolean _tmp369_ = FALSE;
		const gchar* _tmp370_;
		BalaCodeWriter* _tmp377_;
		BalaCodeContext* _tmp378_;
		const gchar* _tmp379_;
		_tmp339_ = bala_compiler_internal_header_filename;
		if (_tmp339_ == NULL) {
			_tmp338_ = TRUE;
		} else {
			const gchar* _tmp340_;
			_tmp340_ = bala_compiler_header_filename;
			_tmp338_ = _tmp340_ == NULL;
		}
		if (_tmp338_) {
			bala_report_error (NULL, "--internal-bapi may only be used in combination with --header and --in" \
"ternal-header");
			result = bala_compiler_quit (self);
			_bala_code_visitor_unref0 (gir_parser);
			_bala_code_visitor_unref0 (genie_parser);
			_bala_code_visitor_unref0 (parser);
			return result;
		}
		_tmp341_ = bala_code_writer_new (BALA_CODE_WRITER_TYPE_INTERNAL);
		interface_writer = _tmp341_;
		_tmp342_ = self->priv->context;
		_tmp343_ = bala_code_context_get_includedir (_tmp342_);
		_tmp344_ = _tmp343_;
		if (_tmp344_ != NULL) {
			gchar* prefixed_header_filename = NULL;
			BalaCodeContext* _tmp345_;
			const gchar* _tmp346_;
			const gchar* _tmp347_;
			const gchar* _tmp348_;
			gchar* _tmp349_;
			gchar* _tmp350_;
			gchar* _tmp351_;
			gchar* _tmp352_;
			gchar* prefixed_internal_header_filename = NULL;
			BalaCodeContext* _tmp353_;
			const gchar* _tmp354_;
			const gchar* _tmp355_;
			const gchar* _tmp356_;
			gchar* _tmp357_;
			gchar* _tmp358_;
			gchar* _tmp359_;
			gchar* _tmp360_;
			BalaCodeWriter* _tmp361_;
			const gchar* _tmp362_;
			const gchar* _tmp363_;
			_tmp345_ = self->priv->context;
			_tmp346_ = bala_code_context_get_includedir (_tmp345_);
			_tmp347_ = _tmp346_;
			_tmp348_ = bala_compiler_header_filename;
			_tmp349_ = g_path_get_basename (_tmp348_);
			_tmp350_ = _tmp349_;
			_tmp351_ = g_build_path ("/", _tmp347_, _tmp350_, NULL);
			_tmp352_ = _tmp351_;
			_g_free0 (_tmp350_);
			prefixed_header_filename = _tmp352_;
			_tmp353_ = self->priv->context;
			_tmp354_ = bala_code_context_get_includedir (_tmp353_);
			_tmp355_ = _tmp354_;
			_tmp356_ = bala_compiler_internal_header_filename;
			_tmp357_ = g_path_get_basename (_tmp356_);
			_tmp358_ = _tmp357_;
			_tmp359_ = g_build_path ("/", _tmp355_, _tmp358_, NULL);
			_tmp360_ = _tmp359_;
			_g_free0 (_tmp358_);
			prefixed_internal_header_filename = _tmp360_;
			_tmp361_ = interface_writer;
			_tmp362_ = prefixed_header_filename;
			_tmp363_ = prefixed_internal_header_filename;
			bala_code_writer_set_cheader_override (_tmp361_, _tmp362_, _tmp363_);
			_g_free0 (prefixed_internal_header_filename);
			_g_free0 (prefixed_header_filename);
		} else {
			BalaCodeWriter* _tmp364_;
			const gchar* _tmp365_;
			const gchar* _tmp366_;
			_tmp364_ = interface_writer;
			_tmp365_ = bala_compiler_header_filename;
			_tmp366_ = bala_compiler_internal_header_filename;
			bala_code_writer_set_cheader_override (_tmp364_, _tmp365_, _tmp366_);
		}
		_tmp367_ = bala_compiler_internal_bapi_filename;
		_tmp368_ = g_strdup (_tmp367_);
		bapi_filename = _tmp368_;
		_tmp370_ = bala_compiler_directory;
		if (_tmp370_ != NULL) {
			const gchar* _tmp371_;
			_tmp371_ = bapi_filename;
			_tmp369_ = !g_path_is_absolute (_tmp371_);
		} else {
			_tmp369_ = FALSE;
		}
		if (_tmp369_) {
			BalaCodeContext* _tmp372_;
			const gchar* _tmp373_;
			const gchar* _tmp374_;
			const gchar* _tmp375_;
			gchar* _tmp376_;
			_tmp372_ = self->priv->context;
			_tmp373_ = bala_code_context_get_directory (_tmp372_);
			_tmp374_ = _tmp373_;
			_tmp375_ = bapi_filename;
			_tmp376_ = g_strdup_printf ("%s%c%s", _tmp374_, (gint) G_DIR_SEPARATOR, _tmp375_);
			_g_free0 (bapi_filename);
			bapi_filename = _tmp376_;
		}
		_tmp377_ = interface_writer;
		_tmp378_ = self->priv->context;
		_tmp379_ = bapi_filename;
		bala_code_writer_write_file (_tmp377_, _tmp378_, _tmp379_);
		_g_free0 (bala_compiler_internal_bapi_filename);
		bala_compiler_internal_bapi_filename = NULL;
		_g_free0 (bapi_filename);
		_bala_code_visitor_unref0 (interface_writer);
	}
	_tmp380_ = bala_compiler_dependencies;
	if (_tmp380_ != NULL) {
		BalaCodeContext* _tmp381_;
		const gchar* _tmp382_;
		_tmp381_ = self->priv->context;
		_tmp382_ = bala_compiler_dependencies;
		bala_code_context_write_dependencies (_tmp381_, _tmp382_);
	}
	_tmp383_ = bala_compiler_depfile;
	if (_tmp383_ != NULL) {
		BalaCodeContext* _tmp384_;
		const gchar* _tmp385_;
		_tmp384_ = self->priv->context;
		_tmp385_ = bala_compiler_depfile;
		bala_code_context_write_external_dependencies (_tmp384_, _tmp385_);
	}
	_tmp387_ = self->priv->context;
	_tmp388_ = bala_code_context_get_report (_tmp387_);
	_tmp389_ = _tmp388_;
	if (bala_report_get_errors (_tmp389_) > 0) {
		_tmp386_ = TRUE;
	} else {
		gboolean _tmp390_ = FALSE;
		if (bala_compiler_fatal_warnings) {
			BalaCodeContext* _tmp391_;
			BalaReport* _tmp392_;
			BalaReport* _tmp393_;
			_tmp391_ = self->priv->context;
			_tmp392_ = bala_code_context_get_report (_tmp391_);
			_tmp393_ = _tmp392_;
			_tmp390_ = bala_report_get_warnings (_tmp393_) > 0;
		} else {
			_tmp390_ = FALSE;
		}
		_tmp386_ = _tmp390_;
	}
	if (_tmp386_) {
		result = bala_compiler_quit (self);
		_bala_code_visitor_unref0 (gir_parser);
		_bala_code_visitor_unref0 (genie_parser);
		_bala_code_visitor_unref0 (parser);
		return result;
	}
	if (!bala_compiler_ccode_only) {
		BalaCCodeCompiler* ccompiler = NULL;
		BalaCCodeCompiler* _tmp394_;
		gboolean _tmp395_ = FALSE;
		const gchar* _tmp396_;
		gchar** _tmp400_;
		gint _tmp400__length1;
		_tmp394_ = bala_ccode_compiler_new ();
		ccompiler = _tmp394_;
		_tmp396_ = bala_compiler_cc_command;
		if (_tmp396_ == NULL) {
			const gchar* _tmp397_;
			_tmp397_ = g_getenv ("CC");
			_tmp395_ = _tmp397_ != NULL;
		} else {
			_tmp395_ = FALSE;
		}
		if (_tmp395_) {
			const gchar* _tmp398_;
			gchar* _tmp399_;
			_tmp398_ = g_getenv ("CC");
			_tmp399_ = g_strdup (_tmp398_);
			_g_free0 (bala_compiler_cc_command);
			bala_compiler_cc_command = _tmp399_;
		}
		_tmp400_ = bala_compiler_cc_options;
		_tmp400__length1 = _bala_array_length (bala_compiler_cc_options);
		if (_tmp400_ == NULL) {
			BalaCCodeCompiler* _tmp401_;
			BalaCodeContext* _tmp402_;
			const gchar* _tmp403_;
			gchar** _tmp404_;
			gchar** _tmp405_;
			gint _tmp405__length1;
			_tmp401_ = ccompiler;
			_tmp402_ = self->priv->context;
			_tmp403_ = bala_compiler_cc_command;
			_tmp404_ = g_new0 (gchar*, 0 + 1);
			_tmp405_ = _tmp404_;
			_tmp405__length1 = 0;
			bala_ccode_compiler_compile (_tmp401_, _tmp402_, _tmp403_, _tmp405_, (gint) 0);
			_tmp405_ = (_bala_array_free (_tmp405_, _tmp405__length1, (GDestroyNotify) g_free), NULL);
		} else {
			BalaCCodeCompiler* _tmp406_;
			BalaCodeContext* _tmp407_;
			const gchar* _tmp408_;
			gchar** _tmp409_;
			gint _tmp409__length1;
			_tmp406_ = ccompiler;
			_tmp407_ = self->priv->context;
			_tmp408_ = bala_compiler_cc_command;
			_tmp409_ = bala_compiler_cc_options;
			_tmp409__length1 = _bala_array_length (bala_compiler_cc_options);
			bala_ccode_compiler_compile (_tmp406_, _tmp407_, _tmp408_, _tmp409_, (gint) _tmp409__length1);
		}
		_bala_ccode_compiler_unref0 (ccompiler);
	}
	result = bala_compiler_quit (self);
	_bala_code_visitor_unref0 (gir_parser);
	_bala_code_visitor_unref0 (genie_parser);
	_bala_code_visitor_unref0 (parser);
	return result;
}

static void
_bala_array_add1 (gchar** * array,
                  gint* length,
                  gint* size,
                  gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

static Block1Data*
block1_data_ref (Block1Data* _data1_)
{
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}

static void
block1_data_unref (void * _userdata_)
{
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		_g_main_loop_unref0 (_data1_->loop);
		g_slice_free (Block1Data, _data1_);
	}
}

static void
___lambda4_ (Block1Data* _data1_,
             GPid pid,
             gint status)
{
	GMainLoop* _tmp0_;
	_data1_->child_status = (status & 0xff00) >> 8;
	_tmp0_ = _data1_->loop;
	g_main_loop_quit (_tmp0_);
}

static void
____lambda4__gchild_watch_func (GPid pid,
                                gint status,
                                gpointer self)
{
	___lambda4_ (self, pid, status);
}

static gint
bala_compiler_run_source (gchar** args,
                          gint args_length1)
{
	gchar** _tmp13_;
	gint _tmp13__length1;
	const gchar* _tmp15_;
	gchar** _tmp16_;
	gint _tmp16__length1;
	const gchar* _tmp17_;
	gchar* _tmp18_;
	gchar* _tmp19_;
	gchar* _tmp20_;
	gint outputfd = 0;
	const gchar* _tmp21_;
	BalaCompiler* compiler = NULL;
	BalaCompiler* _tmp22_;
	gint ret = 0;
	BalaCompiler* _tmp23_;
	const gchar* _tmp24_;
	gchar** target_args = NULL;
	const gchar* _tmp26_;
	gchar* _tmp27_;
	gchar** _tmp28_;
	gint target_args_length1;
	gint _target_args_size_;
	const gchar* _tmp29_;
	gint _tmp46_ = -1;
	GError* _inner_error0_ = NULL;
	gint result = 0;
	{
		GOptionContext* opt_context = NULL;
		GOptionContext* _tmp0_;
		GOptionContext* _tmp1_;
		GOptionContext* _tmp2_;
		GOptionContext* _tmp3_;
		_tmp0_ = g_option_context_new ("- Bala Interpreter");
		opt_context = _tmp0_;
		_tmp1_ = opt_context;
		g_option_context_set_help_enabled (_tmp1_, TRUE);
		_tmp2_ = opt_context;
		g_option_context_add_main_entries (_tmp2_, BALA_COMPILER_options, NULL);
		_tmp3_ = opt_context;
		g_option_context_parse (_tmp3_, (gint*) (&args_length1), &args, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			gint _tmp4_ = -1;
			_g_option_context_free0 (opt_context);
			if (_inner_error0_->domain == G_OPTION_ERROR) {
				goto __catch0_g_option_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return _tmp4_;
		}
		_g_option_context_free0 (opt_context);
	}
	goto __finally0;
	__catch0_g_option_error:
	{
		GError* e = NULL;
		FILE* _tmp5_;
		GError* _tmp6_;
		const gchar* _tmp7_;
		FILE* _tmp8_;
		const gchar* _tmp9_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp5_ = stdout;
		_tmp6_ = e;
		_tmp7_ = _tmp6_->message;
		fprintf (_tmp5_, "%s\n", _tmp7_);
		_tmp8_ = stdout;
		_tmp9_ = args[0];
		fprintf (_tmp8_, "Run '%s --help' to see a full list of available command line options.\n", _tmp9_);
		result = 1;
		_g_error_free0 (e);
		return result;
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gint _tmp10_ = -1;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return _tmp10_;
	}
	if (bala_compiler_version) {
		FILE* _tmp11_;
		_tmp11_ = stdout;
		fprintf (_tmp11_, "Bala %s\n", BALA_BUILD_VERSION);
		result = 0;
		return result;
	} else {
		if (bala_compiler_api_version) {
			FILE* _tmp12_;
			_tmp12_ = stdout;
			fprintf (_tmp12_, "%s\n", BALA_API_VERSION);
			result = 0;
			return result;
		}
	}
	_tmp13_ = bala_compiler_sources;
	_tmp13__length1 = _bala_array_length (bala_compiler_sources);
	if (_tmp13_ == NULL) {
		FILE* _tmp14_;
		_tmp14_ = stderr;
		fprintf (_tmp14_, "No source file specified.\n");
		result = 1;
		return result;
	}
	_tmp15_ = g_get_tmp_dir ();
	_tmp16_ = bala_compiler_sources;
	_tmp16__length1 = _bala_array_length (bala_compiler_sources);
	_tmp17_ = _tmp16_[0];
	_tmp18_ = g_path_get_basename (_tmp17_);
	_tmp19_ = _tmp18_;
	_tmp20_ = g_strdup_printf ("%s/%s.XXXXXX", _tmp15_, _tmp19_);
	_g_free0 (bala_compiler_output);
	bala_compiler_output = _tmp20_;
	_g_free0 (_tmp19_);
	_tmp21_ = bala_compiler_output;
	outputfd = g_mkstemp (_tmp21_);
	if (outputfd < 0) {
		result = 1;
		return result;
	}
	bala_compiler_ccode_only = FALSE;
	bala_compiler_compile_only = FALSE;
	bala_compiler_run_output = TRUE;
	bala_compiler_disable_warnings = TRUE;
	bala_compiler_quiet_mode = TRUE;
	_g_free0 (bala_compiler_library);
	bala_compiler_library = NULL;
	_g_free0 (bala_compiler_shared_library);
	bala_compiler_shared_library = NULL;
	_tmp22_ = bala_compiler_new ();
	compiler = _tmp22_;
	_tmp23_ = compiler;
	ret = bala_compiler_run (_tmp23_);
	if (ret != 0) {
		result = ret;
		_bala_compiler_unref0 (compiler);
		return result;
	}
	close (outputfd);
	_tmp24_ = bala_compiler_output;
	if (g_chmod (_tmp24_, 0700) != 0) {
		const gchar* _tmp25_;
		_tmp25_ = bala_compiler_output;
		g_unlink (_tmp25_);
		result = 1;
		_bala_compiler_unref0 (compiler);
		return result;
	}
	_tmp26_ = bala_compiler_output;
	_tmp27_ = g_strdup (_tmp26_);
	_tmp28_ = g_new0 (gchar*, 1 + 1);
	_tmp28_[0] = _tmp27_;
	target_args = _tmp28_;
	target_args_length1 = 1;
	_target_args_size_ = target_args_length1;
	_tmp29_ = bala_compiler_run_args;
	if (_tmp29_ != NULL) {
		gchar** target_run_args = NULL;
		const gchar* _tmp30_;
		gchar** _tmp31_;
		gchar** _tmp32_;
		gint target_run_args_length1;
		gint _target_run_args_size_;
		gchar** _tmp33_;
		gint _tmp33__length1;
		_tmp30_ = bala_compiler_run_args;
		_tmp32_ = _tmp31_ = g_strsplit (_tmp30_, " ", 0);
		target_run_args = _tmp32_;
		target_run_args_length1 = _bala_array_length (_tmp31_);
		_target_run_args_size_ = target_run_args_length1;
		_tmp33_ = target_run_args;
		_tmp33__length1 = target_run_args_length1;
		{
			gchar** arg_collection = NULL;
			gint arg_collection_length1 = 0;
			gint _arg_collection_size_ = 0;
			gint arg_it = 0;
			arg_collection = _tmp33_;
			arg_collection_length1 = _tmp33__length1;
			for (arg_it = 0; arg_it < arg_collection_length1; arg_it = arg_it + 1) {
				gchar* _tmp34_;
				gchar* arg = NULL;
				_tmp34_ = g_strdup (arg_collection[arg_it]);
				arg = _tmp34_;
				{
					const gchar* _tmp35_;
					gchar* _tmp36_;
					_tmp35_ = arg;
					_tmp36_ = g_strdup (_tmp35_);
					_bala_array_add1 (&target_args, &target_args_length1, &_target_args_size_, _tmp36_);
					_g_free0 (arg);
				}
			}
		}
		target_run_args = (_bala_array_free (target_run_args, target_run_args_length1, (GDestroyNotify) g_free), NULL);
	}
	{
		Block1Data* _data1_;
		GPid pid = 0;
		GMainLoop* _tmp37_;
		gchar** _tmp38_;
		gint _tmp38__length1;
		GPid _tmp39_ = 0;
		const gchar* _tmp41_;
		GMainLoop* _tmp42_;
		_data1_ = g_slice_new0 (Block1Data);
		_data1_->_ref_count_ = 1;
		_tmp37_ = g_main_loop_new (NULL, FALSE);
		_data1_->loop = _tmp37_;
		_data1_->child_status = 0;
		_tmp38_ = target_args;
		_tmp38__length1 = target_args_length1;
		g_spawn_async (NULL, _tmp38_, NULL, G_SPAWN_CHILD_INHERITS_STDIN | G_SPAWN_DO_NOT_REAP_CHILD, NULL, NULL, &_tmp39_, &_inner_error0_);
		pid = _tmp39_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			gint _tmp40_ = -1;
			block1_data_unref (_data1_);
			_data1_ = NULL;
			if (_inner_error0_->domain == G_SPAWN_ERROR) {
				goto __catch1_g_spawn_error;
			}
			target_args = (_bala_array_free (target_args, target_args_length1, (GDestroyNotify) g_free), NULL);
			_bala_compiler_unref0 (compiler);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return _tmp40_;
		}
		_tmp41_ = bala_compiler_output;
		g_unlink (_tmp41_);
		g_child_watch_add_full (G_PRIORITY_DEFAULT_IDLE, pid, ____lambda4__gchild_watch_func, block1_data_ref (_data1_), block1_data_unref);
		_tmp42_ = _data1_->loop;
		g_main_loop_run (_tmp42_);
		result = _data1_->child_status;
		block1_data_unref (_data1_);
		_data1_ = NULL;
		target_args = (_bala_array_free (target_args, target_args_length1, (GDestroyNotify) g_free), NULL);
		_bala_compiler_unref0 (compiler);
		return result;
	}
	goto __finally1;
	__catch1_g_spawn_error:
	{
		GError* e = NULL;
		FILE* _tmp43_;
		GError* _tmp44_;
		const gchar* _tmp45_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp43_ = stdout;
		_tmp44_ = e;
		_tmp45_ = _tmp44_->message;
		fprintf (_tmp43_, "%s\n", _tmp45_);
		result = 1;
		_g_error_free0 (e);
		target_args = (_bala_array_free (target_args, target_args_length1, (GDestroyNotify) g_free), NULL);
		_bala_compiler_unref0 (compiler);
		return result;
	}
	__finally1:
	target_args = (_bala_array_free (target_args, target_args_length1, (GDestroyNotify) g_free), NULL);
	_bala_compiler_unref0 (compiler);
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
	g_clear_error (&_inner_error0_);
	return _tmp46_;
}

static gint
bala_compiler_main (gchar** args,
                    gint args_length1)
{
	gboolean _tmp0_ = FALSE;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp21_ = FALSE;
	gchar** _tmp22_;
	gint _tmp22__length1;
	BalaCompiler* compiler = NULL;
	BalaCompiler* _tmp25_;
	BalaCompiler* _tmp26_;
	GError* _inner_error0_ = NULL;
	gint result = 0;
	setlocale (LC_ALL, "");
	_tmp1_ = args[0];
	_tmp2_ = g_path_get_basename (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strcmp0 (_tmp3_, "bala") == 0;
	_g_free0 (_tmp3_);
	if (_tmp4_) {
		_tmp0_ = TRUE;
	} else {
		const gchar* _tmp5_;
		gchar* _tmp6_;
		gchar* _tmp7_;
		_tmp5_ = args[0];
		_tmp6_ = g_path_get_basename (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp0_ = g_strcmp0 (_tmp7_, "bala" PACKAGE_SUFFIX) == 0;
		_g_free0 (_tmp7_);
	}
	if (_tmp0_) {
		result = bala_compiler_run_source (args, (gint) args_length1);
		return result;
	}
	{
		GOptionContext* opt_context = NULL;
		GOptionContext* _tmp8_;
		GOptionContext* _tmp9_;
		GOptionContext* _tmp10_;
		GOptionContext* _tmp11_;
		_tmp8_ = g_option_context_new ("- Bala Compiler");
		opt_context = _tmp8_;
		_tmp9_ = opt_context;
		g_option_context_set_help_enabled (_tmp9_, TRUE);
		_tmp10_ = opt_context;
		g_option_context_add_main_entries (_tmp10_, BALA_COMPILER_options, NULL);
		_tmp11_ = opt_context;
		g_option_context_parse (_tmp11_, (gint*) (&args_length1), &args, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			gint _tmp12_ = -1;
			_g_option_context_free0 (opt_context);
			if (_inner_error0_->domain == G_OPTION_ERROR) {
				goto __catch0_g_option_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return _tmp12_;
		}
		_g_option_context_free0 (opt_context);
	}
	goto __finally0;
	__catch0_g_option_error:
	{
		GError* e = NULL;
		FILE* _tmp13_;
		GError* _tmp14_;
		const gchar* _tmp15_;
		FILE* _tmp16_;
		const gchar* _tmp17_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp13_ = stdout;
		_tmp14_ = e;
		_tmp15_ = _tmp14_->message;
		fprintf (_tmp13_, "%s\n", _tmp15_);
		_tmp16_ = stdout;
		_tmp17_ = args[0];
		fprintf (_tmp16_, "Run '%s --help' to see a full list of available command line options.\n", _tmp17_);
		result = 1;
		_g_error_free0 (e);
		return result;
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gint _tmp18_ = -1;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return _tmp18_;
	}
	if (bala_compiler_version) {
		FILE* _tmp19_;
		_tmp19_ = stdout;
		fprintf (_tmp19_, "Bala %s\n", BALA_BUILD_VERSION);
		result = 0;
		return result;
	} else {
		if (bala_compiler_api_version) {
			FILE* _tmp20_;
			_tmp20_ = stdout;
			fprintf (_tmp20_, "%s\n", BALA_API_VERSION);
			result = 0;
			return result;
		}
	}
	_tmp22_ = bala_compiler_sources;
	_tmp22__length1 = _bala_array_length (bala_compiler_sources);
	if (_tmp22_ == NULL) {
		gchar** _tmp23_;
		gint _tmp23__length1;
		_tmp23_ = bala_compiler_fast_bapis;
		_tmp23__length1 = _bala_array_length (bala_compiler_fast_bapis);
		_tmp21_ = _tmp23_ == NULL;
	} else {
		_tmp21_ = FALSE;
	}
	if (_tmp21_) {
		FILE* _tmp24_;
		_tmp24_ = stderr;
		fprintf (_tmp24_, "No source file specified.\n");
		result = 1;
		return result;
	}
	_tmp25_ = bala_compiler_new ();
	compiler = _tmp25_;
	_tmp26_ = compiler;
	result = bala_compiler_run (_tmp26_);
	_bala_compiler_unref0 (compiler);
	return result;
}

int
main (int argc,
      char ** argv)
{
	return bala_compiler_main (argv, argc);
}

G_GNUC_INTERNAL BalaCompiler*
bala_compiler_construct (GType object_type)
{
	BalaCompiler* self = NULL;
	self = (BalaCompiler*) g_type_create_instance (object_type);
	return self;
}

G_GNUC_INTERNAL BalaCompiler*
bala_compiler_new (void)
{
	return bala_compiler_construct (BALA_TYPE_COMPILER);
}

static void
bala_value_compiler_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
bala_value_compiler_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		bala_compiler_unref (value->data[0].v_pointer);
	}
}

static void
bala_value_compiler_copy_value (const GValue* src_value,
                                GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = bala_compiler_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
bala_value_compiler_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
bala_value_compiler_collect_value (GValue* value,
                                   guint n_collect_values,
                                   GTypeCValue* collect_values,
                                   guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		BalaCompiler * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = bala_compiler_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
bala_value_compiler_lcopy_value (const GValue* value,
                                 guint n_collect_values,
                                 GTypeCValue* collect_values,
                                 guint collect_flags)
{
	BalaCompiler ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = bala_compiler_ref (value->data[0].v_pointer);
	}
	return NULL;
}

G_GNUC_INTERNAL GParamSpec*
bala_param_spec_compiler (const gchar* name,
                          const gchar* nick,
                          const gchar* blurb,
                          GType object_type,
                          GParamFlags flags)
{
	BalaParamSpecCompiler* spec;
	g_return_val_if_fail (g_type_is_a (object_type, BALA_TYPE_COMPILER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

G_GNUC_INTERNAL gpointer
bala_value_get_compiler (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BALA_TYPE_COMPILER), NULL);
	return value->data[0].v_pointer;
}

G_GNUC_INTERNAL void
bala_value_set_compiler (GValue* value,
                         gpointer v_object)
{
	BalaCompiler * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BALA_TYPE_COMPILER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BALA_TYPE_COMPILER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		bala_compiler_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		bala_compiler_unref (old);
	}
}

G_GNUC_INTERNAL void
bala_value_take_compiler (GValue* value,
                          gpointer v_object)
{
	BalaCompiler * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, BALA_TYPE_COMPILER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, BALA_TYPE_COMPILER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		bala_compiler_unref (old);
	}
}

static void
bala_compiler_class_init (BalaCompilerClass * klass,
                          gpointer klass_data)
{
	bala_compiler_parent_class = g_type_class_peek_parent (klass);
	((BalaCompilerClass *) klass)->finalize = bala_compiler_finalize;
	g_type_class_adjust_private_offset (klass, &BalaCompiler_private_offset);
}

static void
bala_compiler_instance_init (BalaCompiler * self,
                             gpointer klass)
{
	self->priv = bala_compiler_get_instance_private (self);
	self->ref_count = 1;
}

static void
bala_compiler_finalize (BalaCompiler * obj)
{
	BalaCompiler * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BALA_TYPE_COMPILER, BalaCompiler);
	g_signal_handlers_destroy (self);
	_bala_code_context_unref0 (self->priv->context);
}

static GType
bala_compiler_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { bala_value_compiler_init, bala_value_compiler_free_value, bala_value_compiler_copy_value, bala_value_compiler_peek_pointer, "p", bala_value_compiler_collect_value, "p", bala_value_compiler_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (BalaCompilerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bala_compiler_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BalaCompiler), 0, (GInstanceInitFunc) bala_compiler_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType bala_compiler_type_id;
	bala_compiler_type_id = g_type_register_fundamental (g_type_fundamental_next (), "BalaCompiler", &g_define_type_info, &g_define_type_fundamental_info, 0);
	BalaCompiler_private_offset = g_type_add_instance_private (bala_compiler_type_id, sizeof (BalaCompilerPrivate));
	return bala_compiler_type_id;
}

G_GNUC_INTERNAL GType
bala_compiler_get_type (void)
{
	static volatile gsize bala_compiler_type_id__volatile = 0;
	if (g_once_init_enter (&bala_compiler_type_id__volatile)) {
		GType bala_compiler_type_id;
		bala_compiler_type_id = bala_compiler_get_type_once ();
		g_once_init_leave (&bala_compiler_type_id__volatile, bala_compiler_type_id);
	}
	return bala_compiler_type_id__volatile;
}

G_GNUC_INTERNAL gpointer
bala_compiler_ref (gpointer instance)
{
	BalaCompiler * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

G_GNUC_INTERNAL void
bala_compiler_unref (gpointer instance)
{
	BalaCompiler * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		BALA_COMPILER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static void
_bala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gint i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_bala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_bala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gint
_bala_array_length (gpointer array)
{
	gint length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

