/* balausedattr.c generated by balac, the Vala compiler
 * generated from balausedattr.bala, do not modify */

/* balaunusedattr.bala
 *
 * Copyright (C) 2014-2015  JÃ¼rg Billeter
 * Copyright (C) 2014-2015  Luca Bruno
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Luca Bruno <lucabru@src.gnome.org>
 */

#include "bala.h"
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <balagee.h>
#include <glib-object.h>

#define _bala_map_unref0(var) ((var == NULL) ? NULL : (var = (bala_map_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _bala_iterable_unref0(var) ((var == NULL) ? NULL : (var = (bala_iterable_unref (var), NULL)))
#define _bala_iterator_unref0(var) ((var == NULL) ? NULL : (var = (bala_iterator_unref (var), NULL)))

static gpointer bala_used_attr_parent_class = NULL;

static void bala_used_attr_check_unused_attr (ValaUsedAttr* self,
                                       ValaSymbol* sym);
static void bala_used_attr_real_visit_namespace (ValaCodeVisitor* base,
                                          ValaNamespace* ns);
static void bala_used_attr_real_visit_class (ValaCodeVisitor* base,
                                      ValaClass* cl);
static void bala_used_attr_real_visit_struct (ValaCodeVisitor* base,
                                       ValaStruct* st);
static void bala_used_attr_real_visit_interface (ValaCodeVisitor* base,
                                          ValaInterface* iface);
static void bala_used_attr_real_visit_enum (ValaCodeVisitor* base,
                                     ValaEnum* en);
static void bala_used_attr_real_visit_error_domain (ValaCodeVisitor* base,
                                             ValaErrorDomain* ed);
static void bala_used_attr_real_visit_delegate (ValaCodeVisitor* base,
                                         ValaDelegate* cb);
static void bala_used_attr_real_visit_constant (ValaCodeVisitor* base,
                                         ValaConstant* c);
static void bala_used_attr_real_visit_field (ValaCodeVisitor* base,
                                      ValaField* f);
static void bala_used_attr_real_visit_method (ValaCodeVisitor* base,
                                       ValaMethod* m);
static void bala_used_attr_real_visit_creation_method (ValaCodeVisitor* base,
                                                ValaCreationMethod* m);
static void bala_used_attr_real_visit_formal_parameter (ValaCodeVisitor* base,
                                                 ValaParameter* p);
static void bala_used_attr_real_visit_property (ValaCodeVisitor* base,
                                         ValaProperty* prop);
static void bala_used_attr_real_visit_signal (ValaCodeVisitor* base,
                                       ValaSignal* sig);
static void bala_used_attr_finalize (ValaCodeVisitor * obj);
static GType bala_used_attr_get_type_once (void);

static const gchar* BALA_USED_ATTR_balac_default_attrs[188] = {"CCode", "type_signature", "default_value", "set_value_function", "type_id", "cprefix", "cheader_filename", "marshaller_type_name", "get_value_function", "cname", "destroy_function", "lvalue_access", "has_type_id", "instance_pos", "const_cname", "take_value_function", "copy_function", "free_function", "param_spec_function", "has_target", "has_typedef", "type_cname", "ref_function", "ref_function_void", "unref_function", "type", "has_construct_function", "returns_floating_reference", "gir_namespace", "gir_version", "construct_function", "lower_case_cprefix", "simple_generics", "sentinel", "scope", "has_destroy_function", "ordering", "type_check_function", "type_get_function", "has_copy_function", "lower_case_csuffix", "ref_sink_function", "dup_function", "finish_function", "generic_type_pos", "array_length_type", "array_length", "array_length_cname", "array_length_cexpr", "array_null_terminated", "vfunc_name", "finish_vfunc_name", "finish_name", "free_function_address_of", "pos", "delegate_target", "delegate_target_cname", "array_length_pos", "delegate_target_pos", "destroy_notify_pos", "ctype", "has_new_function", "notify", "finish_instance", "use_inplace", "feature_test_macro", "default_value_on_error", "async_result_pos", "error_pos", "destroy_notify_cname", "", "Immutable", "", "SingleInstance", "", "Compact", "", "NoWrapper", "", "NoThrow", "", "DestroysInstance", "", "Flags", "", "Experimental", "", "NoReturn", "", "NoArrayLength", "", "Assert", "", "ErrorBase", "", "GenericAccessors", "", "Diagnostics", "", "NoAccessorMethod", "", "ConcreteAccessor", "", "HasEmitter", "", "ReturnsModifiedPointer", "", "Deprecated", "since", "replacement", "", "Version", "since", "replacement", "deprecated", "deprecated_since", "experimental", "experimental_until", "", "Signal", "detailed", "run", "no_recurse", "action", "no_hooks", "", "Description", "nick", "blurb", "", "IntegerType", "rank", "min", "max", "signed", "width", "", "FloatingType", "rank", "decimal", "width", "", "BooleanType", "", "SimpleType", "", "PointerType", "", "Print", "", "PrintfFormat", "", "ScanfFormat", "", "FormatArg", "", "Source", "filename", "line", "column", "", "GtkChild", "name", "internal", "", "GtkTemplate", "ui", "", "GtkCallback", "name", "", "ModuleInit", "", "DBus", "name", "no_reply", "result", "use_string_marshalling", "value", "signature", "visible", "timeout", "", "GIR", "fullname", "name", "visible", ""};

ValaUsedAttr*
bala_used_attr_construct (GType object_type)
{
	ValaUsedAttr* self = NULL;
	gchar* curattr = NULL;
	gchar* _tmp0_;
	self = (ValaUsedAttr*) bala_code_visitor_construct (object_type);
	_tmp0_ = g_strdup ("");
	curattr = _tmp0_;
	{
		const gchar** val_collection = NULL;
		gint val_collection_length1 = 0;
		gint _val_collection_size_ = 0;
		gint val_it = 0;
		val_collection = BALA_USED_ATTR_balac_default_attrs;
		val_collection_length1 = G_N_ELEMENTS (BALA_USED_ATTR_balac_default_attrs);
		for (val_it = 0; val_it < val_collection_length1; val_it = val_it + 1) {
			const gchar* val = NULL;
			val = val_collection[val_it];
			{
				const gchar* _tmp1_;
				_tmp1_ = val;
				if (g_strcmp0 (_tmp1_, "") == 0) {
					gchar* _tmp2_;
					_tmp2_ = g_strdup ("");
					_g_free0 (curattr);
					curattr = _tmp2_;
				} else {
					const gchar* _tmp3_;
					_tmp3_ = curattr;
					if (g_strcmp0 (_tmp3_, "") == 0) {
						const gchar* _tmp4_;
						gchar* _tmp5_;
						const gchar* _tmp6_;
						_tmp4_ = val;
						_tmp5_ = g_strdup (_tmp4_);
						_g_free0 (curattr);
						curattr = _tmp5_;
						_tmp6_ = curattr;
						bala_used_attr_mark (self, _tmp6_, NULL);
					} else {
						const gchar* _tmp7_;
						const gchar* _tmp8_;
						_tmp7_ = curattr;
						_tmp8_ = val;
						bala_used_attr_mark (self, _tmp7_, _tmp8_);
					}
				}
			}
		}
	}
	_g_free0 (curattr);
	return self;
}

ValaUsedAttr*
bala_used_attr_new (void)
{
	return bala_used_attr_construct (BALA_TYPE_USED_ATTR);
}

/**
 * Mark the attribute or attribute argument as used by the compiler
 */
void
bala_used_attr_mark (ValaUsedAttr* self,
                     const gchar* attribute,
                     const gchar* argument)
{
	ValaSet* set = NULL;
	ValaMap* _tmp0_;
	gpointer _tmp1_;
	ValaSet* _tmp2_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (attribute != NULL);
	_tmp0_ = self->marked;
	_tmp1_ = bala_map_get (_tmp0_, attribute);
	set = (ValaSet*) _tmp1_;
	_tmp2_ = set;
	if (_tmp2_ == NULL) {
		GHashFunc _tmp3_;
		GEqualFunc _tmp4_;
		ValaHashSet* _tmp5_;
		ValaMap* _tmp6_;
		ValaSet* _tmp7_;
		_tmp3_ = g_str_hash;
		_tmp4_ = g_str_equal;
		_tmp5_ = bala_hash_set_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, _tmp3_, _tmp4_);
		_bala_iterable_unref0 (set);
		set = (ValaSet*) _tmp5_;
		_tmp6_ = self->marked;
		_tmp7_ = set;
		bala_map_set (_tmp6_, attribute, _tmp7_);
	}
	if (argument != NULL) {
		ValaSet* _tmp8_;
		_tmp8_ = set;
		bala_collection_add ((ValaCollection*) _tmp8_, argument);
	}
	_bala_iterable_unref0 (set);
}

/**
 * Traverse the code tree and warn about unused attributes.
 *
 * @param context a code context
 */
void
bala_used_attr_check_unused (ValaUsedAttr* self,
                             ValaCodeContext* context)
{
	ValaNamespace* _tmp0_;
	ValaNamespace* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	_tmp0_ = bala_code_context_get_root (context);
	_tmp1_ = _tmp0_;
	bala_code_node_accept ((ValaCodeNode*) _tmp1_, (ValaCodeVisitor*) self);
}

static void
bala_used_attr_check_unused_attr (ValaUsedAttr* self,
                                  ValaSymbol* sym)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sym != NULL);
	_tmp0_ = bala_symbol_get_used (sym);
	_tmp1_ = _tmp0_;
	if (_tmp1_) {
		GList* _tmp2_;
		_tmp2_ = ((ValaCodeNode*) sym)->attributes;
		{
			GList* attr_collection = NULL;
			GList* attr_it = NULL;
			attr_collection = _tmp2_;
			for (attr_it = attr_collection; attr_it != NULL; attr_it = attr_it->next) {
				ValaAttribute* attr = NULL;
				attr = (ValaAttribute*) attr_it->data;
				{
					ValaSet* set = NULL;
					ValaMap* _tmp3_;
					ValaAttribute* _tmp4_;
					const gchar* _tmp5_;
					const gchar* _tmp6_;
					gpointer _tmp7_;
					ValaSet* _tmp8_;
					_tmp3_ = self->marked;
					_tmp4_ = attr;
					_tmp5_ = bala_attribute_get_name (_tmp4_);
					_tmp6_ = _tmp5_;
					_tmp7_ = bala_map_get (_tmp3_, _tmp6_);
					set = (ValaSet*) _tmp7_;
					_tmp8_ = set;
					if (_tmp8_ == NULL) {
						ValaAttribute* _tmp9_;
						ValaSourceReference* _tmp10_;
						ValaSourceReference* _tmp11_;
						ValaAttribute* _tmp12_;
						const gchar* _tmp13_;
						const gchar* _tmp14_;
						gchar* _tmp15_;
						gchar* _tmp16_;
						_tmp9_ = attr;
						_tmp10_ = bala_code_node_get_source_reference ((ValaCodeNode*) _tmp9_);
						_tmp11_ = _tmp10_;
						_tmp12_ = attr;
						_tmp13_ = bala_attribute_get_name (_tmp12_);
						_tmp14_ = _tmp13_;
						_tmp15_ = g_strdup_printf ("attribute `%s' never used", _tmp14_);
						_tmp16_ = _tmp15_;
						bala_report_warning (_tmp11_, _tmp16_);
						_g_free0 (_tmp16_);
					} else {
						{
							ValaIterator* _arg_it = NULL;
							ValaAttribute* _tmp17_;
							ValaMap* _tmp18_;
							ValaMap* _tmp19_;
							ValaSet* _tmp20_;
							ValaSet* _tmp21_;
							ValaIterator* _tmp22_;
							ValaIterator* _tmp23_;
							_tmp17_ = attr;
							_tmp18_ = bala_attribute_get_args (_tmp17_);
							_tmp19_ = _tmp18_;
							_tmp20_ = bala_map_get_keys (_tmp19_);
							_tmp21_ = _tmp20_;
							_tmp22_ = bala_iterable_iterator ((ValaIterable*) _tmp21_);
							_tmp23_ = _tmp22_;
							_bala_iterable_unref0 (_tmp21_);
							_arg_it = _tmp23_;
							while (TRUE) {
								ValaIterator* _tmp24_;
								gchar* arg = NULL;
								ValaIterator* _tmp25_;
								gpointer _tmp26_;
								ValaSet* _tmp27_;
								const gchar* _tmp28_;
								_tmp24_ = _arg_it;
								if (!bala_iterator_next (_tmp24_)) {
									break;
								}
								_tmp25_ = _arg_it;
								_tmp26_ = bala_iterator_get (_tmp25_);
								arg = (gchar*) _tmp26_;
								_tmp27_ = set;
								_tmp28_ = arg;
								if (!bala_collection_contains ((ValaCollection*) _tmp27_, _tmp28_)) {
									ValaAttribute* _tmp29_;
									ValaSourceReference* _tmp30_;
									ValaSourceReference* _tmp31_;
									const gchar* _tmp32_;
									gchar* _tmp33_;
									gchar* _tmp34_;
									_tmp29_ = attr;
									_tmp30_ = bala_code_node_get_source_reference ((ValaCodeNode*) _tmp29_);
									_tmp31_ = _tmp30_;
									_tmp32_ = arg;
									_tmp33_ = g_strdup_printf ("argument `%s' never used", _tmp32_);
									_tmp34_ = _tmp33_;
									bala_report_warning (_tmp31_, _tmp34_);
									_g_free0 (_tmp34_);
								}
								_g_free0 (arg);
							}
							_bala_iterator_unref0 (_arg_it);
						}
					}
					_bala_iterable_unref0 (set);
				}
			}
		}
	}
}

static void
bala_used_attr_real_visit_namespace (ValaCodeVisitor* base,
                                     ValaNamespace* ns)
{
	ValaUsedAttr * self;
	self = (ValaUsedAttr*) base;
	g_return_if_fail (ns != NULL);
	bala_used_attr_check_unused_attr (self, (ValaSymbol*) ns);
	bala_code_node_accept_children ((ValaCodeNode*) ns, (ValaCodeVisitor*) self);
}

static void
bala_used_attr_real_visit_class (ValaCodeVisitor* base,
                                 ValaClass* cl)
{
	ValaUsedAttr * self;
	self = (ValaUsedAttr*) base;
	g_return_if_fail (cl != NULL);
	bala_used_attr_check_unused_attr (self, (ValaSymbol*) cl);
	bala_code_node_accept_children ((ValaCodeNode*) cl, (ValaCodeVisitor*) self);
}

static void
bala_used_attr_real_visit_struct (ValaCodeVisitor* base,
                                  ValaStruct* st)
{
	ValaUsedAttr * self;
	self = (ValaUsedAttr*) base;
	g_return_if_fail (st != NULL);
	bala_used_attr_check_unused_attr (self, (ValaSymbol*) st);
	bala_code_node_accept_children ((ValaCodeNode*) st, (ValaCodeVisitor*) self);
}

static void
bala_used_attr_real_visit_interface (ValaCodeVisitor* base,
                                     ValaInterface* iface)
{
	ValaUsedAttr * self;
	self = (ValaUsedAttr*) base;
	g_return_if_fail (iface != NULL);
	bala_used_attr_check_unused_attr (self, (ValaSymbol*) iface);
	bala_code_node_accept_children ((ValaCodeNode*) iface, (ValaCodeVisitor*) self);
}

static void
bala_used_attr_real_visit_enum (ValaCodeVisitor* base,
                                ValaEnum* en)
{
	ValaUsedAttr * self;
	self = (ValaUsedAttr*) base;
	g_return_if_fail (en != NULL);
	bala_used_attr_check_unused_attr (self, (ValaSymbol*) en);
	bala_code_node_accept_children ((ValaCodeNode*) en, (ValaCodeVisitor*) self);
}

static void
bala_used_attr_real_visit_error_domain (ValaCodeVisitor* base,
                                        ValaErrorDomain* ed)
{
	ValaUsedAttr * self;
	self = (ValaUsedAttr*) base;
	g_return_if_fail (ed != NULL);
	bala_used_attr_check_unused_attr (self, (ValaSymbol*) ed);
	bala_code_node_accept_children ((ValaCodeNode*) ed, (ValaCodeVisitor*) self);
}

static void
bala_used_attr_real_visit_delegate (ValaCodeVisitor* base,
                                    ValaDelegate* cb)
{
	ValaUsedAttr * self;
	self = (ValaUsedAttr*) base;
	g_return_if_fail (cb != NULL);
	bala_used_attr_check_unused_attr (self, (ValaSymbol*) cb);
	bala_code_node_accept_children ((ValaCodeNode*) cb, (ValaCodeVisitor*) self);
}

static void
bala_used_attr_real_visit_constant (ValaCodeVisitor* base,
                                    ValaConstant* c)
{
	ValaUsedAttr * self;
	self = (ValaUsedAttr*) base;
	g_return_if_fail (c != NULL);
	bala_used_attr_check_unused_attr (self, (ValaSymbol*) c);
}

static void
bala_used_attr_real_visit_field (ValaCodeVisitor* base,
                                 ValaField* f)
{
	ValaUsedAttr * self;
	self = (ValaUsedAttr*) base;
	g_return_if_fail (f != NULL);
	bala_used_attr_check_unused_attr (self, (ValaSymbol*) f);
}

static void
bala_used_attr_real_visit_method (ValaCodeVisitor* base,
                                  ValaMethod* m)
{
	ValaUsedAttr * self;
	self = (ValaUsedAttr*) base;
	g_return_if_fail (m != NULL);
	bala_used_attr_check_unused_attr (self, (ValaSymbol*) m);
	bala_code_node_accept_children ((ValaCodeNode*) m, (ValaCodeVisitor*) self);
}

static void
bala_used_attr_real_visit_creation_method (ValaCodeVisitor* base,
                                           ValaCreationMethod* m)
{
	ValaUsedAttr * self;
	self = (ValaUsedAttr*) base;
	g_return_if_fail (m != NULL);
	bala_used_attr_check_unused_attr (self, (ValaSymbol*) m);
	bala_code_node_accept_children ((ValaCodeNode*) m, (ValaCodeVisitor*) self);
}

static void
bala_used_attr_real_visit_formal_parameter (ValaCodeVisitor* base,
                                            ValaParameter* p)
{
	ValaUsedAttr * self;
	self = (ValaUsedAttr*) base;
	g_return_if_fail (p != NULL);
	bala_used_attr_check_unused_attr (self, (ValaSymbol*) p);
}

static void
bala_used_attr_real_visit_property (ValaCodeVisitor* base,
                                    ValaProperty* prop)
{
	ValaUsedAttr * self;
	self = (ValaUsedAttr*) base;
	g_return_if_fail (prop != NULL);
	bala_used_attr_check_unused_attr (self, (ValaSymbol*) prop);
}

static void
bala_used_attr_real_visit_signal (ValaCodeVisitor* base,
                                  ValaSignal* sig)
{
	ValaUsedAttr * self;
	self = (ValaUsedAttr*) base;
	g_return_if_fail (sig != NULL);
	bala_used_attr_check_unused_attr (self, (ValaSymbol*) sig);
	bala_code_node_accept_children ((ValaCodeNode*) sig, (ValaCodeVisitor*) self);
}

static void
bala_used_attr_class_init (ValaUsedAttrClass * klass,
                           gpointer klass_data)
{
	bala_used_attr_parent_class = g_type_class_peek_parent (klass);
	((ValaCodeVisitorClass *) klass)->finalize = bala_used_attr_finalize;
	((ValaCodeVisitorClass *) klass)->visit_namespace = (void (*) (ValaCodeVisitor*, ValaNamespace*)) bala_used_attr_real_visit_namespace;
	((ValaCodeVisitorClass *) klass)->visit_class = (void (*) (ValaCodeVisitor*, ValaClass*)) bala_used_attr_real_visit_class;
	((ValaCodeVisitorClass *) klass)->visit_struct = (void (*) (ValaCodeVisitor*, ValaStruct*)) bala_used_attr_real_visit_struct;
	((ValaCodeVisitorClass *) klass)->visit_interface = (void (*) (ValaCodeVisitor*, ValaInterface*)) bala_used_attr_real_visit_interface;
	((ValaCodeVisitorClass *) klass)->visit_enum = (void (*) (ValaCodeVisitor*, ValaEnum*)) bala_used_attr_real_visit_enum;
	((ValaCodeVisitorClass *) klass)->visit_error_domain = (void (*) (ValaCodeVisitor*, ValaErrorDomain*)) bala_used_attr_real_visit_error_domain;
	((ValaCodeVisitorClass *) klass)->visit_delegate = (void (*) (ValaCodeVisitor*, ValaDelegate*)) bala_used_attr_real_visit_delegate;
	((ValaCodeVisitorClass *) klass)->visit_constant = (void (*) (ValaCodeVisitor*, ValaConstant*)) bala_used_attr_real_visit_constant;
	((ValaCodeVisitorClass *) klass)->visit_field = (void (*) (ValaCodeVisitor*, ValaField*)) bala_used_attr_real_visit_field;
	((ValaCodeVisitorClass *) klass)->visit_method = (void (*) (ValaCodeVisitor*, ValaMethod*)) bala_used_attr_real_visit_method;
	((ValaCodeVisitorClass *) klass)->visit_creation_method = (void (*) (ValaCodeVisitor*, ValaCreationMethod*)) bala_used_attr_real_visit_creation_method;
	((ValaCodeVisitorClass *) klass)->visit_formal_parameter = (void (*) (ValaCodeVisitor*, ValaParameter*)) bala_used_attr_real_visit_formal_parameter;
	((ValaCodeVisitorClass *) klass)->visit_property = (void (*) (ValaCodeVisitor*, ValaProperty*)) bala_used_attr_real_visit_property;
	((ValaCodeVisitorClass *) klass)->visit_signal = (void (*) (ValaCodeVisitor*, ValaSignal*)) bala_used_attr_real_visit_signal;
}

static void
bala_used_attr_instance_init (ValaUsedAttr * self,
                              gpointer klass)
{
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GEqualFunc _tmp2_;
	ValaHashMap* _tmp3_;
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_direct_equal;
	_tmp3_ = bala_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, BALA_TYPE_SET, (GBoxedCopyFunc) bala_iterable_ref, (GDestroyNotify) bala_iterable_unref, _tmp0_, _tmp1_, _tmp2_);
	self->marked = (ValaMap*) _tmp3_;
}

static void
bala_used_attr_finalize (ValaCodeVisitor * obj)
{
	ValaUsedAttr * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BALA_TYPE_USED_ATTR, ValaUsedAttr);
	_bala_map_unref0 (self->marked);
	BALA_CODE_VISITOR_CLASS (bala_used_attr_parent_class)->finalize (obj);
}

/**
 * Code visitor to warn about unused attributes
 */
static GType
bala_used_attr_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (ValaUsedAttrClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bala_used_attr_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValaUsedAttr), 0, (GInstanceInitFunc) bala_used_attr_instance_init, NULL };
	GType bala_used_attr_type_id;
	bala_used_attr_type_id = g_type_register_static (BALA_TYPE_CODE_VISITOR, "ValaUsedAttr", &g_define_type_info, 0);
	return bala_used_attr_type_id;
}

GType
bala_used_attr_get_type (void)
{
	static volatile gsize bala_used_attr_type_id__volatile = 0;
	if (g_once_init_enter (&bala_used_attr_type_id__volatile)) {
		GType bala_used_attr_type_id;
		bala_used_attr_type_id = bala_used_attr_get_type_once ();
		g_once_init_leave (&bala_used_attr_type_id__volatile, bala_used_attr_type_id);
	}
	return bala_used_attr_type_id__volatile;
}

