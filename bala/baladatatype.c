/* baladatatype.c generated by balac, the Bala compiler
 * generated from baladatatype.bala, do not modify */

/* baladatatype.bala
 *
 * Copyright (C) 2006-2010  Jürg Billeter
 * Copyright (C) 2006-2008  Raffaele Sandrini
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Jürg Billeter <j@bitron.ch>
 *	Raffaele Sandrini <raffaele@sandrini.ch>
 */

#include "bala.h"
#include <glib.h>
#include <balagee.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>

#define _bala_iterable_unref0(var) ((var == NULL) ? NULL : (var = (bala_iterable_unref (var), NULL)))
#define _bala_code_node_unref0(var) ((var == NULL) ? NULL : (var = (bala_code_node_unref (var), NULL)))
#define _bala_scope_unref0(var) ((var == NULL) ? NULL : (var = (bala_scope_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _bala_code_context_unref0(var) ((var == NULL) ? NULL : (var = (bala_code_context_unref (var), NULL)))
#define _bala_iterator_unref0(var) ((var == NULL) ? NULL : (var = (bala_iterator_unref (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))

struct _BalaDataTypePrivate {
	gboolean _value_owned;
	gboolean _nullable;
	BalaSymbol* _symbol;
	gboolean _floating_reference;
	gboolean _is_dynamic;
	BalaList* type_argument_list;
};

static gint BalaDataType_private_offset;
static gpointer bala_data_type_parent_class = NULL;
static BalaList* bala_data_type__empty_type_list;
static BalaList* bala_data_type__empty_type_list = NULL;

static void bala_data_type_set_symbol (BalaDataType* self,
                                BalaSymbol* value);
static void bala_data_type_real_accept (BalaCodeNode* base,
                                 BalaCodeVisitor* visitor);
static void bala_data_type_real_accept_children (BalaCodeNode* base,
                                          BalaCodeVisitor* visitor);
static gchar* bala_data_type_real_to_string (BalaCodeNode* base);
static gchar* bala_data_type_real_to_qualified_string (BalaDataType* self,
                                                BalaScope* scope);
static BalaDataType* bala_data_type_real_copy (BalaDataType* self);
static gboolean bala_data_type_real_equals (BalaDataType* self,
                                     BalaDataType* type2);
static gboolean bala_data_type_real_stricter (BalaDataType* self,
                                       BalaDataType* type2);
static void bala_data_type_real_replace_type (BalaCodeNode* base,
                                       BalaDataType* old_type,
                                       BalaDataType* new_type);
static gboolean bala_data_type_real_compatible (BalaDataType* self,
                                         BalaDataType* target_type);
G_GNUC_INTERNAL BalaDataType* bala_semantic_analyzer_get_instance_base_type_for_member (BalaDataType* derived_instance_type,
                                                                        BalaTypeSymbol* type_symbol,
                                                                        BalaCodeNode* node_reference);
static gboolean bala_data_type_real_is_invokable (BalaDataType* self);
static BalaDataType* bala_data_type_real_get_return_type (BalaDataType* self);
static BalaList* bala_data_type_real_get_parameters (BalaDataType* self);
static gboolean bala_data_type_real_is_reference_type_or_type_parameter (BalaDataType* self);
static gboolean bala_data_type_real_is_accessible (BalaDataType* self,
                                            BalaSymbol* sym);
static BalaSymbol* bala_data_type_real_get_member (BalaDataType* self,
                                            const gchar* member_name);
static BalaSymbol* bala_data_type_real_get_pointer_member (BalaDataType* self,
                                                    const gchar* member_name);
static gboolean bala_data_type_real_is_real_struct_type (BalaDataType* self);
static gboolean bala_data_type_real_is_disposable (BalaDataType* self);
static BalaDataType* bala_data_type_real_get_actual_type (BalaDataType* self,
                                                   BalaDataType* derived_instance_type,
                                                   BalaList* method_type_arguments,
                                                   BalaCodeNode* node_reference);
static BalaDataType* bala_data_type_real_infer_type_argument (BalaDataType* self,
                                                       BalaTypeParameter* type_param,
                                                       BalaDataType* value_type);
static gchar* bala_data_type_real_to_prototype_string (BalaDataType* self,
                                                const gchar* override_name);
static void bala_data_type_finalize (BalaCodeNode * obj);
static GType bala_data_type_get_type_once (void);

static inline gpointer
bala_data_type_get_instance_private (BalaDataType* self)
{
	return G_STRUCT_MEMBER_P (self, BalaDataType_private_offset);
}

gboolean
bala_data_type_get_value_owned (BalaDataType* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_value_owned;
	return result;
}

void
bala_data_type_set_value_owned (BalaDataType* self,
                                gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_value_owned = value;
}

gboolean
bala_data_type_get_nullable (BalaDataType* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_nullable;
	return result;
}

void
bala_data_type_set_nullable (BalaDataType* self,
                             gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_nullable = value;
}

BalaSymbol*
bala_data_type_get_symbol (BalaDataType* self)
{
	BalaSymbol* result;
	BalaSymbol* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_symbol;
	result = _tmp0_;
	return result;
}

static void
bala_data_type_set_symbol (BalaDataType* self,
                           BalaSymbol* value)
{
	g_return_if_fail (self != NULL);
	self->priv->_symbol = value;
}

BalaTypeSymbol*
bala_data_type_get_type_symbol (BalaDataType* self)
{
	BalaTypeSymbol* result;
	BalaSymbol* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_symbol;
	result = BALA_IS_TYPESYMBOL (_tmp0_) ? ((BalaTypeSymbol*) _tmp0_) : NULL;
	return result;
}

gboolean
bala_data_type_get_floating_reference (BalaDataType* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_floating_reference;
	return result;
}

void
bala_data_type_set_floating_reference (BalaDataType* self,
                                       gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_floating_reference = value;
}

gboolean
bala_data_type_get_is_dynamic (BalaDataType* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_is_dynamic;
	return result;
}

void
bala_data_type_set_is_dynamic (BalaDataType* self,
                               gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_is_dynamic = value;
}

BalaDataType*
bala_data_type_construct_with_symbol (GType object_type,
                                      BalaSymbol* symbol)
{
	BalaDataType* self = NULL;
	self = (BalaDataType*) bala_code_node_construct (object_type);
	bala_data_type_set_symbol (self, symbol);
	return self;
}

/**
 * Appends the specified type as generic type argument.
 *
 * @param arg a type reference
 */
void
bala_data_type_add_type_argument (BalaDataType* self,
                                  BalaDataType* arg)
{
	BalaList* _tmp0_;
	BalaList* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (arg != NULL);
	_tmp0_ = self->priv->type_argument_list;
	if (_tmp0_ == NULL) {
		GEqualFunc _tmp1_;
		BalaArrayList* _tmp2_;
		_tmp1_ = g_direct_equal;
		_tmp2_ = bala_array_list_new (BALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) bala_code_node_ref, (GDestroyNotify) bala_code_node_unref, _tmp1_);
		_bala_iterable_unref0 (self->priv->type_argument_list);
		self->priv->type_argument_list = (BalaList*) _tmp2_;
	}
	_tmp3_ = self->priv->type_argument_list;
	bala_collection_add ((BalaCollection*) _tmp3_, arg);
	bala_code_node_set_parent_node ((BalaCodeNode*) arg, (BalaCodeNode*) self);
}

/**
 * Returns the list of generic type arguments.
 *
 * @return type argument list
 */
BalaList*
bala_data_type_get_type_arguments (BalaDataType* self)
{
	BalaList* _tmp0_;
	BalaList* _tmp2_;
	BalaList* _tmp5_;
	BalaList* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->type_argument_list;
	if (_tmp0_ != NULL) {
		BalaList* _tmp1_;
		_tmp1_ = self->priv->type_argument_list;
		result = _tmp1_;
		return result;
	}
	_tmp2_ = bala_data_type__empty_type_list;
	if (_tmp2_ == NULL) {
		GEqualFunc _tmp3_;
		BalaArrayList* _tmp4_;
		_tmp3_ = g_direct_equal;
		_tmp4_ = bala_array_list_new (BALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) bala_code_node_ref, (GDestroyNotify) bala_code_node_unref, _tmp3_);
		_bala_iterable_unref0 (bala_data_type__empty_type_list);
		bala_data_type__empty_type_list = (BalaList*) _tmp4_;
	}
	_tmp5_ = bala_data_type__empty_type_list;
	result = _tmp5_;
	return result;
}

gboolean
bala_data_type_has_type_arguments (BalaDataType* self)
{
	BalaList* _tmp0_;
	BalaList* _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->type_argument_list;
	if (_tmp0_ == NULL) {
		result = FALSE;
		return result;
	}
	_tmp1_ = self->priv->type_argument_list;
	_tmp2_ = bala_collection_get_size ((BalaCollection*) _tmp1_);
	_tmp3_ = _tmp2_;
	result = _tmp3_ > 0;
	return result;
}

/**
 * Removes all generic type arguments.
 */
void
bala_data_type_remove_all_type_arguments (BalaDataType* self)
{
	g_return_if_fail (self != NULL);
	_bala_iterable_unref0 (self->priv->type_argument_list);
	self->priv->type_argument_list = NULL;
}

static void
bala_data_type_real_accept (BalaCodeNode* base,
                            BalaCodeVisitor* visitor)
{
	BalaDataType * self;
	self = (BalaDataType*) base;
	g_return_if_fail (visitor != NULL);
	bala_code_visitor_visit_data_type (visitor, self);
}

static gpointer
_bala_iterable_ref0 (gpointer self)
{
	return self ? bala_iterable_ref (self) : NULL;
}

static void
bala_data_type_real_accept_children (BalaCodeNode* base,
                                     BalaCodeVisitor* visitor)
{
	BalaDataType * self;
	gboolean _tmp0_ = FALSE;
	BalaList* _tmp1_;
	self = (BalaDataType*) base;
	g_return_if_fail (visitor != NULL);
	_tmp1_ = self->priv->type_argument_list;
	if (_tmp1_ != NULL) {
		BalaList* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		_tmp2_ = self->priv->type_argument_list;
		_tmp3_ = bala_collection_get_size ((BalaCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_tmp0_ = _tmp4_ > 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		{
			BalaList* _type_arg_list = NULL;
			BalaList* _tmp5_;
			BalaList* _tmp6_;
			gint _type_arg_size = 0;
			BalaList* _tmp7_;
			gint _tmp8_;
			gint _tmp9_;
			gint _type_arg_index = 0;
			_tmp5_ = self->priv->type_argument_list;
			_tmp6_ = _bala_iterable_ref0 (_tmp5_);
			_type_arg_list = _tmp6_;
			_tmp7_ = _type_arg_list;
			_tmp8_ = bala_collection_get_size ((BalaCollection*) _tmp7_);
			_tmp9_ = _tmp8_;
			_type_arg_size = _tmp9_;
			_type_arg_index = -1;
			while (TRUE) {
				gint _tmp10_;
				gint _tmp11_;
				BalaDataType* type_arg = NULL;
				BalaList* _tmp12_;
				gpointer _tmp13_;
				BalaDataType* _tmp14_;
				_type_arg_index = _type_arg_index + 1;
				_tmp10_ = _type_arg_index;
				_tmp11_ = _type_arg_size;
				if (!(_tmp10_ < _tmp11_)) {
					break;
				}
				_tmp12_ = _type_arg_list;
				_tmp13_ = bala_list_get (_tmp12_, _type_arg_index);
				type_arg = (BalaDataType*) _tmp13_;
				_tmp14_ = type_arg;
				bala_code_node_accept ((BalaCodeNode*) _tmp14_, visitor);
				_bala_code_node_unref0 (type_arg);
			}
			_bala_iterable_unref0 (_type_arg_list);
		}
	}
}

static gchar*
bala_data_type_real_to_string (BalaCodeNode* base)
{
	BalaDataType * self;
	gchar* _tmp0_;
	gchar* result = NULL;
	self = (BalaDataType*) base;
	_tmp0_ = bala_data_type_to_qualified_string (self, NULL);
	result = _tmp0_;
	return result;
}

static gpointer
_bala_code_node_ref0 (gpointer self)
{
	return self ? bala_code_node_ref (self) : NULL;
}

static gpointer
_bala_scope_ref0 (gpointer self)
{
	return self ? bala_scope_ref (self) : NULL;
}

static gchar*
bala_data_type_real_to_qualified_string (BalaDataType* self,
                                         BalaScope* scope)
{
	gchar* s = NULL;
	BalaTypeSymbol* _tmp0_;
	BalaTypeSymbol* _tmp1_;
	BalaList* type_args = NULL;
	BalaList* _tmp44_;
	BalaList* _tmp45_;
	BalaList* _tmp46_;
	gint _tmp47_;
	gint _tmp48_;
	gboolean _tmp72_;
	gchar* result = NULL;
	_tmp0_ = bala_data_type_get_type_symbol (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ != NULL) {
		BalaSymbol* global_symbol = NULL;
		BalaTypeSymbol* _tmp2_;
		BalaTypeSymbol* _tmp3_;
		BalaSymbol* _tmp4_;
		BalaSymbol* sym = NULL;
		BalaScope* parent_scope = NULL;
		BalaScope* _tmp18_;
		gboolean _tmp31_ = FALSE;
		BalaSymbol* _tmp32_;
		_tmp2_ = bala_data_type_get_type_symbol (self);
		_tmp3_ = _tmp2_;
		_tmp4_ = _bala_code_node_ref0 ((BalaSymbol*) _tmp3_);
		global_symbol = _tmp4_;
		while (TRUE) {
			gboolean _tmp5_ = FALSE;
			BalaSymbol* _tmp6_;
			BalaSymbol* _tmp7_;
			BalaSymbol* _tmp8_;
			BalaSymbol* _tmp14_;
			BalaSymbol* _tmp15_;
			BalaSymbol* _tmp16_;
			BalaSymbol* _tmp17_;
			_tmp6_ = global_symbol;
			_tmp7_ = bala_symbol_get_parent_symbol (_tmp6_);
			_tmp8_ = _tmp7_;
			if (_tmp8_ != NULL) {
				BalaSymbol* _tmp9_;
				BalaSymbol* _tmp10_;
				BalaSymbol* _tmp11_;
				const gchar* _tmp12_;
				const gchar* _tmp13_;
				_tmp9_ = global_symbol;
				_tmp10_ = bala_symbol_get_parent_symbol (_tmp9_);
				_tmp11_ = _tmp10_;
				_tmp12_ = bala_symbol_get_name (_tmp11_);
				_tmp13_ = _tmp12_;
				_tmp5_ = _tmp13_ != NULL;
			} else {
				_tmp5_ = FALSE;
			}
			if (!_tmp5_) {
				break;
			}
			_tmp14_ = global_symbol;
			_tmp15_ = bala_symbol_get_parent_symbol (_tmp14_);
			_tmp16_ = _tmp15_;
			_tmp17_ = _bala_code_node_ref0 (_tmp16_);
			_bala_code_node_unref0 (global_symbol);
			global_symbol = _tmp17_;
		}
		sym = NULL;
		_tmp18_ = _bala_scope_ref0 (scope);
		parent_scope = _tmp18_;
		while (TRUE) {
			gboolean _tmp19_ = FALSE;
			BalaSymbol* _tmp20_;
			BalaScope* _tmp22_;
			BalaSymbol* _tmp23_;
			const gchar* _tmp24_;
			const gchar* _tmp25_;
			BalaSymbol* _tmp26_;
			BalaScope* _tmp27_;
			BalaScope* _tmp28_;
			BalaScope* _tmp29_;
			BalaScope* _tmp30_;
			_tmp20_ = sym;
			if (_tmp20_ == NULL) {
				BalaScope* _tmp21_;
				_tmp21_ = parent_scope;
				_tmp19_ = _tmp21_ != NULL;
			} else {
				_tmp19_ = FALSE;
			}
			if (!_tmp19_) {
				break;
			}
			_tmp22_ = parent_scope;
			_tmp23_ = global_symbol;
			_tmp24_ = bala_symbol_get_name (_tmp23_);
			_tmp25_ = _tmp24_;
			_tmp26_ = bala_scope_lookup (_tmp22_, _tmp25_);
			_bala_code_node_unref0 (sym);
			sym = _tmp26_;
			_tmp27_ = parent_scope;
			_tmp28_ = bala_scope_get_parent_scope (_tmp27_);
			_tmp29_ = _tmp28_;
			_tmp30_ = _bala_scope_ref0 (_tmp29_);
			_bala_scope_unref0 (parent_scope);
			parent_scope = _tmp30_;
		}
		_tmp32_ = sym;
		if (_tmp32_ != NULL) {
			BalaSymbol* _tmp33_;
			BalaSymbol* _tmp34_;
			_tmp33_ = global_symbol;
			_tmp34_ = sym;
			_tmp31_ = _tmp33_ != _tmp34_;
		} else {
			_tmp31_ = FALSE;
		}
		if (_tmp31_) {
			BalaTypeSymbol* _tmp35_;
			BalaTypeSymbol* _tmp36_;
			gchar* _tmp37_;
			gchar* _tmp38_;
			gchar* _tmp39_;
			_tmp35_ = bala_data_type_get_type_symbol (self);
			_tmp36_ = _tmp35_;
			_tmp37_ = bala_symbol_get_full_name ((BalaSymbol*) _tmp36_);
			_tmp38_ = _tmp37_;
			_tmp39_ = g_strconcat ("global::", _tmp38_, NULL);
			_g_free0 (s);
			s = _tmp39_;
			_g_free0 (_tmp38_);
		} else {
			BalaTypeSymbol* _tmp40_;
			BalaTypeSymbol* _tmp41_;
			gchar* _tmp42_;
			_tmp40_ = bala_data_type_get_type_symbol (self);
			_tmp41_ = _tmp40_;
			_tmp42_ = bala_symbol_get_full_name ((BalaSymbol*) _tmp41_);
			_g_free0 (s);
			s = _tmp42_;
		}
		_bala_scope_unref0 (parent_scope);
		_bala_code_node_unref0 (sym);
		_bala_code_node_unref0 (global_symbol);
	} else {
		gchar* _tmp43_;
		_tmp43_ = g_strdup ("null");
		_g_free0 (s);
		s = _tmp43_;
	}
	_tmp44_ = bala_data_type_get_type_arguments (self);
	_tmp45_ = _bala_iterable_ref0 (_tmp44_);
	type_args = _tmp45_;
	_tmp46_ = type_args;
	_tmp47_ = bala_collection_get_size ((BalaCollection*) _tmp46_);
	_tmp48_ = _tmp47_;
	if (_tmp48_ > 0) {
		const gchar* _tmp49_;
		gchar* _tmp50_;
		gboolean first = FALSE;
		const gchar* _tmp70_;
		gchar* _tmp71_;
		_tmp49_ = s;
		_tmp50_ = g_strconcat (_tmp49_, "<", NULL);
		_g_free0 (s);
		s = _tmp50_;
		first = TRUE;
		{
			BalaList* _type_arg_list = NULL;
			BalaList* _tmp51_;
			BalaList* _tmp52_;
			gint _type_arg_size = 0;
			BalaList* _tmp53_;
			gint _tmp54_;
			gint _tmp55_;
			gint _type_arg_index = 0;
			_tmp51_ = type_args;
			_tmp52_ = _bala_iterable_ref0 (_tmp51_);
			_type_arg_list = _tmp52_;
			_tmp53_ = _type_arg_list;
			_tmp54_ = bala_collection_get_size ((BalaCollection*) _tmp53_);
			_tmp55_ = _tmp54_;
			_type_arg_size = _tmp55_;
			_type_arg_index = -1;
			while (TRUE) {
				gint _tmp56_;
				gint _tmp57_;
				BalaDataType* type_arg = NULL;
				BalaList* _tmp58_;
				gpointer _tmp59_;
				BalaDataType* _tmp62_;
				const gchar* _tmp65_;
				BalaDataType* _tmp66_;
				gchar* _tmp67_;
				gchar* _tmp68_;
				gchar* _tmp69_;
				_type_arg_index = _type_arg_index + 1;
				_tmp56_ = _type_arg_index;
				_tmp57_ = _type_arg_size;
				if (!(_tmp56_ < _tmp57_)) {
					break;
				}
				_tmp58_ = _type_arg_list;
				_tmp59_ = bala_list_get (_tmp58_, _type_arg_index);
				type_arg = (BalaDataType*) _tmp59_;
				if (!first) {
					const gchar* _tmp60_;
					gchar* _tmp61_;
					_tmp60_ = s;
					_tmp61_ = g_strconcat (_tmp60_, ",", NULL);
					_g_free0 (s);
					s = _tmp61_;
				} else {
					first = FALSE;
				}
				_tmp62_ = type_arg;
				if (bala_data_type_is_weak (_tmp62_)) {
					const gchar* _tmp63_;
					gchar* _tmp64_;
					_tmp63_ = s;
					_tmp64_ = g_strconcat (_tmp63_, "weak ", NULL);
					_g_free0 (s);
					s = _tmp64_;
				}
				_tmp65_ = s;
				_tmp66_ = type_arg;
				_tmp67_ = bala_data_type_to_qualified_string (_tmp66_, scope);
				_tmp68_ = _tmp67_;
				_tmp69_ = g_strconcat (_tmp65_, _tmp68_, NULL);
				_g_free0 (s);
				s = _tmp69_;
				_g_free0 (_tmp68_);
				_bala_code_node_unref0 (type_arg);
			}
			_bala_iterable_unref0 (_type_arg_list);
		}
		_tmp70_ = s;
		_tmp71_ = g_strconcat (_tmp70_, ">", NULL);
		_g_free0 (s);
		s = _tmp71_;
	}
	_tmp72_ = self->priv->_nullable;
	if (_tmp72_) {
		const gchar* _tmp73_;
		gchar* _tmp74_;
		_tmp73_ = s;
		_tmp74_ = g_strconcat (_tmp73_, "?", NULL);
		_g_free0 (s);
		s = _tmp74_;
	}
	result = s;
	_bala_iterable_unref0 (type_args);
	return result;
}

gchar*
bala_data_type_to_qualified_string (BalaDataType* self,
                                    BalaScope* scope)
{
	g_return_val_if_fail (self != NULL, NULL);
	return BALA_DATA_TYPE_GET_CLASS (self)->to_qualified_string (self, scope);
}

/**
 * Creates a shallow copy of this type reference.
 *
 * @return copy of this type reference
 */
static BalaDataType*
bala_data_type_real_copy (BalaDataType* self)
{
	g_critical ("Type `%s' does not implement abstract method `bala_data_type_copy'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}

BalaDataType*
bala_data_type_copy (BalaDataType* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return BALA_DATA_TYPE_GET_CLASS (self)->copy (self);
}

/**
 * Checks two type references for equality. May only be used with
 * resolved type references.
 *
 * @param type2 a type reference
 * @return      true if this type reference is equal to type2, false
 *              otherwise
 */
static gboolean
bala_data_type_real_equals (BalaDataType* self,
                            BalaDataType* type2)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
	BalaTypeSymbol* _tmp2_;
	BalaTypeSymbol* _tmp3_;
	BalaTypeSymbol* _tmp4_;
	BalaTypeSymbol* _tmp5_;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp12_;
	gboolean _tmp13_;
	BalaList* type_args = NULL;
	BalaList* _tmp14_;
	BalaList* _tmp15_;
	BalaList* type2_args = NULL;
	BalaList* _tmp16_;
	BalaList* _tmp17_;
	BalaList* _tmp18_;
	gint _tmp19_;
	gint _tmp20_;
	BalaList* _tmp21_;
	gint _tmp22_;
	gint _tmp23_;
	gboolean result = FALSE;
	g_return_val_if_fail (type2 != NULL, FALSE);
	if (bala_data_type_is_disposable (type2) != bala_data_type_is_disposable (self)) {
		result = FALSE;
		return result;
	}
	_tmp0_ = type2->priv->_nullable;
	_tmp1_ = self->priv->_nullable;
	if (_tmp0_ != _tmp1_) {
		result = FALSE;
		return result;
	}
	_tmp2_ = bala_data_type_get_type_symbol (type2);
	_tmp3_ = _tmp2_;
	_tmp4_ = bala_data_type_get_type_symbol (self);
	_tmp5_ = _tmp4_;
	if (_tmp3_ != _tmp5_) {
		result = FALSE;
		return result;
	}
	if (BALA_IS_GENERIC_TYPE (type2)) {
		_tmp6_ = TRUE;
	} else {
		_tmp6_ = BALA_IS_GENERIC_TYPE (self);
	}
	if (_tmp6_) {
		gboolean _tmp7_ = FALSE;
		BalaTypeParameter* _tmp8_;
		BalaTypeParameter* _tmp9_;
		BalaTypeParameter* _tmp10_;
		BalaTypeParameter* _tmp11_;
		if (!BALA_IS_GENERIC_TYPE (type2)) {
			_tmp7_ = TRUE;
		} else {
			_tmp7_ = !BALA_IS_GENERIC_TYPE (self);
		}
		if (_tmp7_) {
			result = FALSE;
			return result;
		}
		_tmp8_ = bala_generic_type_get_type_parameter (G_TYPE_CHECK_INSTANCE_CAST (type2, BALA_TYPE_GENERIC_TYPE, BalaGenericType));
		_tmp9_ = _tmp8_;
		_tmp10_ = bala_generic_type_get_type_parameter (G_TYPE_CHECK_INSTANCE_CAST (self, BALA_TYPE_GENERIC_TYPE, BalaGenericType));
		_tmp11_ = _tmp10_;
		if (!bala_typeparameter_equals (_tmp9_, _tmp11_)) {
			result = FALSE;
			return result;
		}
	}
	_tmp12_ = type2->priv->_floating_reference;
	_tmp13_ = self->priv->_floating_reference;
	if (_tmp12_ != _tmp13_) {
		result = FALSE;
		return result;
	}
	_tmp14_ = bala_data_type_get_type_arguments (self);
	_tmp15_ = _bala_iterable_ref0 (_tmp14_);
	type_args = _tmp15_;
	_tmp16_ = bala_data_type_get_type_arguments (type2);
	_tmp17_ = _bala_iterable_ref0 (_tmp16_);
	type2_args = _tmp17_;
	_tmp18_ = type2_args;
	_tmp19_ = bala_collection_get_size ((BalaCollection*) _tmp18_);
	_tmp20_ = _tmp19_;
	_tmp21_ = type_args;
	_tmp22_ = bala_collection_get_size ((BalaCollection*) _tmp21_);
	_tmp23_ = _tmp22_;
	if (_tmp20_ != _tmp23_) {
		result = FALSE;
		_bala_iterable_unref0 (type2_args);
		_bala_iterable_unref0 (type_args);
		return result;
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp24_ = FALSE;
			_tmp24_ = TRUE;
			while (TRUE) {
				BalaList* _tmp26_;
				gint _tmp27_;
				gint _tmp28_;
				BalaList* _tmp29_;
				gpointer _tmp30_;
				BalaDataType* _tmp31_;
				BalaList* _tmp32_;
				gpointer _tmp33_;
				BalaDataType* _tmp34_;
				gboolean _tmp35_;
				if (!_tmp24_) {
					gint _tmp25_;
					_tmp25_ = i;
					i = _tmp25_ + 1;
				}
				_tmp24_ = FALSE;
				_tmp26_ = type_args;
				_tmp27_ = bala_collection_get_size ((BalaCollection*) _tmp26_);
				_tmp28_ = _tmp27_;
				if (!(i < _tmp28_)) {
					break;
				}
				_tmp29_ = type2_args;
				_tmp30_ = bala_list_get (_tmp29_, i);
				_tmp31_ = (BalaDataType*) _tmp30_;
				_tmp32_ = type_args;
				_tmp33_ = bala_list_get (_tmp32_, i);
				_tmp34_ = (BalaDataType*) _tmp33_;
				_tmp35_ = !bala_data_type_equals (_tmp31_, _tmp34_);
				_bala_code_node_unref0 (_tmp34_);
				_bala_code_node_unref0 (_tmp31_);
				if (_tmp35_) {
					result = FALSE;
					_bala_iterable_unref0 (type2_args);
					_bala_iterable_unref0 (type_args);
					return result;
				}
			}
		}
	}
	result = TRUE;
	_bala_iterable_unref0 (type2_args);
	_bala_iterable_unref0 (type_args);
	return result;
}

gboolean
bala_data_type_equals (BalaDataType* self,
                       BalaDataType* type2)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return BALA_DATA_TYPE_GET_CLASS (self)->equals (self, type2);
}

/**
 * Checks whether this type reference is at least as strict as the
 * specified type reference type2.
 *
 * @param type2 a type reference
 * @return      true if this type reference is stricter or equal
 */
static gboolean
bala_data_type_real_stricter (BalaDataType* self,
                              BalaDataType* type2)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	gboolean _tmp3_ = FALSE;
	BalaTypeSymbol* _tmp4_;
	BalaTypeSymbol* _tmp5_;
	BalaTypeSymbol* _tmp6_;
	BalaTypeSymbol* _tmp7_;
	gboolean _tmp8_;
	gboolean _tmp9_;
	gboolean result = FALSE;
	g_return_val_if_fail (type2 != NULL, FALSE);
	if (bala_data_type_is_disposable (type2) != bala_data_type_is_disposable (self)) {
		result = FALSE;
		return result;
	}
	_tmp1_ = type2->priv->_nullable;
	if (!_tmp1_) {
		gboolean _tmp2_;
		_tmp2_ = self->priv->_nullable;
		_tmp0_ = _tmp2_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = FALSE;
		return result;
	}
	if (BALA_IS_GENERIC_TYPE (self)) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = BALA_IS_GENERIC_TYPE (type2);
	}
	if (_tmp3_) {
		result = TRUE;
		return result;
	}
	_tmp4_ = bala_data_type_get_type_symbol (type2);
	_tmp5_ = _tmp4_;
	_tmp6_ = bala_data_type_get_type_symbol (self);
	_tmp7_ = _tmp6_;
	if (_tmp5_ != _tmp7_) {
		result = FALSE;
		return result;
	}
	_tmp8_ = type2->priv->_floating_reference;
	_tmp9_ = self->priv->_floating_reference;
	if (_tmp8_ != _tmp9_) {
		result = FALSE;
		return result;
	}
	result = TRUE;
	return result;
}

gboolean
bala_data_type_stricter (BalaDataType* self,
                         BalaDataType* type2)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return BALA_DATA_TYPE_GET_CLASS (self)->stricter (self, type2);
}

static void
bala_data_type_real_replace_type (BalaCodeNode* base,
                                  BalaDataType* old_type,
                                  BalaDataType* new_type)
{
	BalaDataType * self;
	BalaList* _tmp0_;
	self = (BalaDataType*) base;
	g_return_if_fail (old_type != NULL);
	g_return_if_fail (new_type != NULL);
	_tmp0_ = self->priv->type_argument_list;
	if (_tmp0_ != NULL) {
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp1_ = FALSE;
				_tmp1_ = TRUE;
				while (TRUE) {
					BalaList* _tmp3_;
					gint _tmp4_;
					gint _tmp5_;
					BalaList* _tmp6_;
					gpointer _tmp7_;
					BalaDataType* _tmp8_;
					gboolean _tmp9_;
					if (!_tmp1_) {
						gint _tmp2_;
						_tmp2_ = i;
						i = _tmp2_ + 1;
					}
					_tmp1_ = FALSE;
					_tmp3_ = self->priv->type_argument_list;
					_tmp4_ = bala_collection_get_size ((BalaCollection*) _tmp3_);
					_tmp5_ = _tmp4_;
					if (!(i < _tmp5_)) {
						break;
					}
					_tmp6_ = self->priv->type_argument_list;
					_tmp7_ = bala_list_get (_tmp6_, i);
					_tmp8_ = (BalaDataType*) _tmp7_;
					_tmp9_ = _tmp8_ == old_type;
					_bala_code_node_unref0 (_tmp8_);
					if (_tmp9_) {
						BalaList* _tmp10_;
						_tmp10_ = self->priv->type_argument_list;
						bala_list_set (_tmp10_, i, new_type);
						return;
					}
				}
			}
		}
	}
}

static gboolean
bala_data_type_real_compatible (BalaDataType* self,
                                BalaDataType* target_type)
{
	BalaCodeContext* context = NULL;
	BalaCodeContext* _tmp0_;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	BalaCodeContext* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	gboolean _tmp8_ = FALSE;
	BalaCodeContext* _tmp9_;
	BalaProfile _tmp10_;
	BalaProfile _tmp11_;
	gboolean _tmp43_ = FALSE;
	gboolean _tmp44_ = FALSE;
	BalaTypeSymbol* _tmp45_;
	BalaTypeSymbol* _tmp46_;
	BalaList* type_args = NULL;
	BalaList* _tmp51_;
	BalaList* _tmp52_;
	BalaList* target_type_args = NULL;
	BalaList* _tmp53_;
	BalaList* _tmp54_;
	BalaList* _tmp55_;
	gint _tmp56_;
	gint _tmp57_;
	BalaList* _tmp58_;
	gint _tmp59_;
	gint _tmp60_;
	gboolean _tmp74_ = FALSE;
	gboolean _tmp75_ = FALSE;
	BalaTypeSymbol* _tmp76_;
	BalaTypeSymbol* _tmp77_;
	gboolean _tmp108_ = FALSE;
	BalaTypeSymbol* _tmp109_;
	BalaTypeSymbol* _tmp110_;
	gboolean result = FALSE;
	g_return_val_if_fail (target_type != NULL, FALSE);
	_tmp0_ = bala_code_context_get ();
	context = _tmp0_;
	_tmp3_ = context;
	_tmp4_ = bala_code_context_get_experimental_non_null (_tmp3_);
	_tmp5_ = _tmp4_;
	if (_tmp5_) {
		gboolean _tmp6_;
		_tmp6_ = self->priv->_nullable;
		_tmp2_ = _tmp6_;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		gboolean _tmp7_;
		_tmp7_ = target_type->priv->_nullable;
		_tmp1_ = !_tmp7_;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		result = FALSE;
		_bala_code_context_unref0 (context);
		return result;
	}
	_tmp9_ = context;
	_tmp10_ = bala_code_context_get_profile (_tmp9_);
	_tmp11_ = _tmp10_;
	if (_tmp11_ == BALA_PROFILE_GOBJECT) {
		BalaTypeSymbol* _tmp12_;
		BalaTypeSymbol* _tmp13_;
		_tmp12_ = bala_data_type_get_type_symbol (target_type);
		_tmp13_ = _tmp12_;
		_tmp8_ = _tmp13_ != NULL;
	} else {
		_tmp8_ = FALSE;
	}
	if (_tmp8_) {
		BalaDataType* gvalue_type = NULL;
		BalaCodeContext* _tmp14_;
		BalaSemanticAnalyzer* _tmp15_;
		BalaSemanticAnalyzer* _tmp16_;
		BalaStructValueType* _tmp17_;
		gboolean _tmp18_ = FALSE;
		BalaDataType* _tmp19_;
		BalaDataType* gvariant_type = NULL;
		BalaCodeContext* _tmp25_;
		BalaSemanticAnalyzer* _tmp26_;
		BalaSemanticAnalyzer* _tmp27_;
		BalaObjectType* _tmp28_;
		gboolean _tmp29_ = FALSE;
		BalaDataType* _tmp30_;
		_tmp14_ = context;
		_tmp15_ = bala_code_context_get_analyzer (_tmp14_);
		_tmp16_ = _tmp15_;
		_tmp17_ = _tmp16_->gvalue_type;
		gvalue_type = (BalaDataType*) _tmp17_;
		_tmp19_ = gvalue_type;
		if (_tmp19_ != NULL) {
			BalaTypeSymbol* _tmp20_;
			BalaTypeSymbol* _tmp21_;
			BalaDataType* _tmp22_;
			BalaTypeSymbol* _tmp23_;
			BalaTypeSymbol* _tmp24_;
			_tmp20_ = bala_data_type_get_type_symbol (target_type);
			_tmp21_ = _tmp20_;
			_tmp22_ = gvalue_type;
			_tmp23_ = bala_data_type_get_type_symbol (_tmp22_);
			_tmp24_ = _tmp23_;
			_tmp18_ = bala_typesymbol_is_subtype_of (_tmp21_, _tmp24_);
		} else {
			_tmp18_ = FALSE;
		}
		if (_tmp18_) {
			result = TRUE;
			_bala_code_context_unref0 (context);
			return result;
		}
		_tmp25_ = context;
		_tmp26_ = bala_code_context_get_analyzer (_tmp25_);
		_tmp27_ = _tmp26_;
		_tmp28_ = _tmp27_->gvariant_type;
		gvariant_type = (BalaDataType*) _tmp28_;
		_tmp30_ = gvariant_type;
		if (_tmp30_ != NULL) {
			BalaTypeSymbol* _tmp31_;
			BalaTypeSymbol* _tmp32_;
			BalaDataType* _tmp33_;
			BalaTypeSymbol* _tmp34_;
			BalaTypeSymbol* _tmp35_;
			_tmp31_ = bala_data_type_get_type_symbol (target_type);
			_tmp32_ = _tmp31_;
			_tmp33_ = gvariant_type;
			_tmp34_ = bala_data_type_get_type_symbol (_tmp33_);
			_tmp35_ = _tmp34_;
			_tmp29_ = bala_typesymbol_is_subtype_of (_tmp32_, _tmp35_);
		} else {
			_tmp29_ = FALSE;
		}
		if (_tmp29_) {
			result = TRUE;
			_bala_code_context_unref0 (context);
			return result;
		}
	}
	if (BALA_IS_POINTER_TYPE (target_type)) {
		gboolean _tmp36_ = FALSE;
		if (BALA_IS_GENERIC_TYPE (self)) {
			_tmp36_ = TRUE;
		} else {
			gboolean _tmp37_ = FALSE;
			BalaTypeSymbol* _tmp38_;
			BalaTypeSymbol* _tmp39_;
			_tmp38_ = bala_data_type_get_type_symbol (self);
			_tmp39_ = _tmp38_;
			if (_tmp39_ != NULL) {
				gboolean _tmp40_ = FALSE;
				BalaTypeSymbol* _tmp41_;
				BalaTypeSymbol* _tmp42_;
				_tmp41_ = bala_data_type_get_type_symbol (self);
				_tmp42_ = _tmp41_;
				if (bala_typesymbol_is_reference_type (_tmp42_)) {
					_tmp40_ = TRUE;
				} else {
					_tmp40_ = BALA_IS_DELEGATE_TYPE (self);
				}
				_tmp37_ = _tmp40_;
			} else {
				_tmp37_ = FALSE;
			}
			_tmp36_ = _tmp37_;
		}
		if (_tmp36_) {
			result = TRUE;
			_bala_code_context_unref0 (context);
			return result;
		}
		result = FALSE;
		_bala_code_context_unref0 (context);
		return result;
	}
	if (BALA_IS_GENERIC_TYPE (target_type)) {
		result = TRUE;
		_bala_code_context_unref0 (context);
		return result;
	}
	if (BALA_IS_ARRAY_TYPE (self) != BALA_IS_ARRAY_TYPE (target_type)) {
		result = FALSE;
		_bala_code_context_unref0 (context);
		return result;
	}
	_tmp45_ = bala_data_type_get_type_symbol (self);
	_tmp46_ = _tmp45_;
	if (BALA_IS_ENUM (_tmp46_)) {
		BalaTypeSymbol* _tmp47_;
		BalaTypeSymbol* _tmp48_;
		_tmp47_ = bala_data_type_get_type_symbol (target_type);
		_tmp48_ = _tmp47_;
		_tmp44_ = BALA_IS_STRUCT (_tmp48_);
	} else {
		_tmp44_ = FALSE;
	}
	if (_tmp44_) {
		BalaTypeSymbol* _tmp49_;
		BalaTypeSymbol* _tmp50_;
		_tmp49_ = bala_data_type_get_type_symbol (target_type);
		_tmp50_ = _tmp49_;
		_tmp43_ = bala_struct_is_integer_type (G_TYPE_CHECK_INSTANCE_CAST (_tmp50_, BALA_TYPE_STRUCT, BalaStruct));
	} else {
		_tmp43_ = FALSE;
	}
	if (_tmp43_) {
		result = TRUE;
		_bala_code_context_unref0 (context);
		return result;
	}
	_tmp51_ = bala_data_type_get_type_arguments (self);
	_tmp52_ = _bala_iterable_ref0 (_tmp51_);
	type_args = _tmp52_;
	_tmp53_ = bala_data_type_get_type_arguments (target_type);
	_tmp54_ = _bala_iterable_ref0 (_tmp53_);
	target_type_args = _tmp54_;
	_tmp55_ = type_args;
	_tmp56_ = bala_collection_get_size ((BalaCollection*) _tmp55_);
	_tmp57_ = _tmp56_;
	_tmp58_ = target_type_args;
	_tmp59_ = bala_collection_get_size ((BalaCollection*) _tmp58_);
	_tmp60_ = _tmp59_;
	if (_tmp57_ == _tmp60_) {
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp61_ = FALSE;
				_tmp61_ = TRUE;
				while (TRUE) {
					BalaList* _tmp63_;
					gint _tmp64_;
					gint _tmp65_;
					BalaDataType* type_arg = NULL;
					BalaList* _tmp66_;
					gpointer _tmp67_;
					BalaDataType* target_type_arg = NULL;
					BalaList* _tmp68_;
					gpointer _tmp69_;
					gboolean _tmp70_ = FALSE;
					BalaDataType* _tmp71_;
					if (!_tmp61_) {
						gint _tmp62_;
						_tmp62_ = i;
						i = _tmp62_ + 1;
					}
					_tmp61_ = FALSE;
					_tmp63_ = type_args;
					_tmp64_ = bala_collection_get_size ((BalaCollection*) _tmp63_);
					_tmp65_ = _tmp64_;
					if (!(i < _tmp65_)) {
						break;
					}
					_tmp66_ = type_args;
					_tmp67_ = bala_list_get (_tmp66_, i);
					type_arg = (BalaDataType*) _tmp67_;
					_tmp68_ = target_type_args;
					_tmp69_ = bala_list_get (_tmp68_, i);
					target_type_arg = (BalaDataType*) _tmp69_;
					_tmp71_ = type_arg;
					if (!bala_data_type_is_non_null_simple_type (_tmp71_)) {
						BalaDataType* _tmp72_;
						BalaDataType* _tmp73_;
						_tmp72_ = type_arg;
						_tmp73_ = target_type_arg;
						_tmp70_ = bala_data_type_is_weak (_tmp72_) != bala_data_type_is_weak (_tmp73_);
					} else {
						_tmp70_ = FALSE;
					}
					if (_tmp70_) {
						result = FALSE;
						_bala_code_node_unref0 (target_type_arg);
						_bala_code_node_unref0 (type_arg);
						_bala_iterable_unref0 (target_type_args);
						_bala_iterable_unref0 (type_args);
						_bala_code_context_unref0 (context);
						return result;
					}
					_bala_code_node_unref0 (target_type_arg);
					_bala_code_node_unref0 (type_arg);
				}
			}
		}
	}
	_tmp76_ = bala_data_type_get_type_symbol (self);
	_tmp77_ = _tmp76_;
	if (_tmp77_ != NULL) {
		BalaTypeSymbol* _tmp78_;
		BalaTypeSymbol* _tmp79_;
		_tmp78_ = bala_data_type_get_type_symbol (target_type);
		_tmp79_ = _tmp78_;
		_tmp75_ = _tmp79_ != NULL;
	} else {
		_tmp75_ = FALSE;
	}
	if (_tmp75_) {
		BalaTypeSymbol* _tmp80_;
		BalaTypeSymbol* _tmp81_;
		BalaTypeSymbol* _tmp82_;
		BalaTypeSymbol* _tmp83_;
		_tmp80_ = bala_data_type_get_type_symbol (self);
		_tmp81_ = _tmp80_;
		_tmp82_ = bala_data_type_get_type_symbol (target_type);
		_tmp83_ = _tmp82_;
		_tmp74_ = bala_typesymbol_is_subtype_of (_tmp81_, _tmp83_);
	} else {
		_tmp74_ = FALSE;
	}
	if (_tmp74_) {
		BalaDataType* base_type = NULL;
		BalaTypeSymbol* _tmp84_;
		BalaTypeSymbol* _tmp85_;
		BalaDataType* _tmp86_;
		BalaList* base_type_args = NULL;
		BalaDataType* _tmp87_;
		BalaList* _tmp88_;
		BalaList* _tmp89_;
		BalaList* _tmp90_;
		gint _tmp91_;
		gint _tmp92_;
		BalaList* _tmp93_;
		gint _tmp94_;
		gint _tmp95_;
		_tmp84_ = bala_data_type_get_type_symbol (target_type);
		_tmp85_ = _tmp84_;
		_tmp86_ = bala_semantic_analyzer_get_instance_base_type_for_member (self, _tmp85_, (BalaCodeNode*) self);
		base_type = _tmp86_;
		_tmp87_ = base_type;
		_tmp88_ = bala_data_type_get_type_arguments (_tmp87_);
		_tmp89_ = _bala_iterable_ref0 (_tmp88_);
		base_type_args = _tmp89_;
		_tmp90_ = base_type_args;
		_tmp91_ = bala_collection_get_size ((BalaCollection*) _tmp90_);
		_tmp92_ = _tmp91_;
		_tmp93_ = target_type_args;
		_tmp94_ = bala_collection_get_size ((BalaCollection*) _tmp93_);
		_tmp95_ = _tmp94_;
		if (_tmp92_ == _tmp95_) {
			{
				gint i = 0;
				i = 0;
				{
					gboolean _tmp96_ = FALSE;
					_tmp96_ = TRUE;
					while (TRUE) {
						BalaList* _tmp98_;
						gint _tmp99_;
						gint _tmp100_;
						BalaList* _tmp101_;
						gpointer _tmp102_;
						BalaDataType* _tmp103_;
						BalaList* _tmp104_;
						gpointer _tmp105_;
						BalaDataType* _tmp106_;
						gboolean _tmp107_;
						if (!_tmp96_) {
							gint _tmp97_;
							_tmp97_ = i;
							i = _tmp97_ + 1;
						}
						_tmp96_ = FALSE;
						_tmp98_ = base_type_args;
						_tmp99_ = bala_collection_get_size ((BalaCollection*) _tmp98_);
						_tmp100_ = _tmp99_;
						if (!(i < _tmp100_)) {
							break;
						}
						_tmp101_ = base_type_args;
						_tmp102_ = bala_list_get (_tmp101_, i);
						_tmp103_ = (BalaDataType*) _tmp102_;
						_tmp104_ = target_type_args;
						_tmp105_ = bala_list_get (_tmp104_, i);
						_tmp106_ = (BalaDataType*) _tmp105_;
						_tmp107_ = !bala_data_type_compatible (_tmp103_, _tmp106_);
						_bala_code_node_unref0 (_tmp106_);
						_bala_code_node_unref0 (_tmp103_);
						if (_tmp107_) {
							result = FALSE;
							_bala_iterable_unref0 (base_type_args);
							_bala_code_node_unref0 (base_type);
							_bala_iterable_unref0 (target_type_args);
							_bala_iterable_unref0 (type_args);
							_bala_code_context_unref0 (context);
							return result;
						}
					}
				}
			}
		}
		result = TRUE;
		_bala_iterable_unref0 (base_type_args);
		_bala_code_node_unref0 (base_type);
		_bala_iterable_unref0 (target_type_args);
		_bala_iterable_unref0 (type_args);
		_bala_code_context_unref0 (context);
		return result;
	}
	_tmp109_ = bala_data_type_get_type_symbol (self);
	_tmp110_ = _tmp109_;
	if (BALA_IS_STRUCT (_tmp110_)) {
		BalaTypeSymbol* _tmp111_;
		BalaTypeSymbol* _tmp112_;
		_tmp111_ = bala_data_type_get_type_symbol (target_type);
		_tmp112_ = _tmp111_;
		_tmp108_ = BALA_IS_STRUCT (_tmp112_);
	} else {
		_tmp108_ = FALSE;
	}
	if (_tmp108_) {
		BalaStruct* expr_struct = NULL;
		BalaTypeSymbol* _tmp113_;
		BalaTypeSymbol* _tmp114_;
		BalaStruct* expect_struct = NULL;
		BalaTypeSymbol* _tmp115_;
		BalaTypeSymbol* _tmp116_;
		gboolean _tmp117_ = FALSE;
		BalaStruct* _tmp118_;
		gboolean _tmp120_ = FALSE;
		gboolean _tmp121_ = FALSE;
		BalaStruct* _tmp122_;
		gboolean _tmp133_ = FALSE;
		BalaStruct* _tmp134_;
		BalaStruct* _tmp136_;
		BalaStruct* _tmp137_;
		_tmp113_ = bala_data_type_get_type_symbol (self);
		_tmp114_ = _tmp113_;
		expr_struct = G_TYPE_CHECK_INSTANCE_CAST (_tmp114_, BALA_TYPE_STRUCT, BalaStruct);
		_tmp115_ = bala_data_type_get_type_symbol (target_type);
		_tmp116_ = _tmp115_;
		expect_struct = G_TYPE_CHECK_INSTANCE_CAST (_tmp116_, BALA_TYPE_STRUCT, BalaStruct);
		_tmp118_ = expr_struct;
		if (bala_struct_is_integer_type (_tmp118_)) {
			BalaStruct* _tmp119_;
			_tmp119_ = expect_struct;
			_tmp117_ = bala_struct_is_floating_type (_tmp119_);
		} else {
			_tmp117_ = FALSE;
		}
		if (_tmp117_) {
			result = TRUE;
			_bala_iterable_unref0 (target_type_args);
			_bala_iterable_unref0 (type_args);
			_bala_code_context_unref0 (context);
			return result;
		}
		_tmp122_ = expr_struct;
		if (bala_struct_is_integer_type (_tmp122_)) {
			BalaStruct* _tmp123_;
			_tmp123_ = expect_struct;
			_tmp121_ = bala_struct_is_integer_type (_tmp123_);
		} else {
			_tmp121_ = FALSE;
		}
		if (_tmp121_) {
			_tmp120_ = TRUE;
		} else {
			gboolean _tmp124_ = FALSE;
			BalaStruct* _tmp125_;
			_tmp125_ = expr_struct;
			if (bala_struct_is_floating_type (_tmp125_)) {
				BalaStruct* _tmp126_;
				_tmp126_ = expect_struct;
				_tmp124_ = bala_struct_is_floating_type (_tmp126_);
			} else {
				_tmp124_ = FALSE;
			}
			_tmp120_ = _tmp124_;
		}
		if (_tmp120_) {
			BalaStruct* _tmp127_;
			gint _tmp128_;
			gint _tmp129_;
			BalaStruct* _tmp130_;
			gint _tmp131_;
			gint _tmp132_;
			_tmp127_ = expr_struct;
			_tmp128_ = bala_struct_get_rank (_tmp127_);
			_tmp129_ = _tmp128_;
			_tmp130_ = expect_struct;
			_tmp131_ = bala_struct_get_rank (_tmp130_);
			_tmp132_ = _tmp131_;
			if (_tmp129_ <= _tmp132_) {
				result = TRUE;
				_bala_iterable_unref0 (target_type_args);
				_bala_iterable_unref0 (type_args);
				_bala_code_context_unref0 (context);
				return result;
			}
		}
		_tmp134_ = expr_struct;
		if (bala_struct_is_boolean_type (_tmp134_)) {
			BalaStruct* _tmp135_;
			_tmp135_ = expect_struct;
			_tmp133_ = bala_struct_is_boolean_type (_tmp135_);
		} else {
			_tmp133_ = FALSE;
		}
		if (_tmp133_) {
			result = TRUE;
			_bala_iterable_unref0 (target_type_args);
			_bala_iterable_unref0 (type_args);
			_bala_code_context_unref0 (context);
			return result;
		}
		_tmp136_ = expect_struct;
		_tmp137_ = expr_struct;
		if (bala_typesymbol_is_subtype_of ((BalaTypeSymbol*) _tmp136_, (BalaTypeSymbol*) _tmp137_)) {
			result = TRUE;
			_bala_iterable_unref0 (target_type_args);
			_bala_iterable_unref0 (type_args);
			_bala_code_context_unref0 (context);
			return result;
		}
	}
	result = FALSE;
	_bala_iterable_unref0 (target_type_args);
	_bala_iterable_unref0 (type_args);
	_bala_code_context_unref0 (context);
	return result;
}

gboolean
bala_data_type_compatible (BalaDataType* self,
                           BalaDataType* target_type)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return BALA_DATA_TYPE_GET_CLASS (self)->compatible (self, target_type);
}

/**
 * Returns whether instances of this type are invokable.
 *
 * @return true if invokable, false otherwise
 */
static gboolean
bala_data_type_real_is_invokable (BalaDataType* self)
{
	gboolean result = FALSE;
	result = FALSE;
	return result;
}

gboolean
bala_data_type_is_invokable (BalaDataType* self)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return BALA_DATA_TYPE_GET_CLASS (self)->is_invokable (self);
}

/**
 * Returns the return type of this invokable.
 *
 * @return return type
 */
static BalaDataType*
bala_data_type_real_get_return_type (BalaDataType* self)
{
	BalaDataType* result = NULL;
	result = NULL;
	return result;
}

BalaDataType*
bala_data_type_get_return_type (BalaDataType* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return BALA_DATA_TYPE_GET_CLASS (self)->get_return_type (self);
}

/**
 * Returns the list of invocation parameters.
 *
 * @return parameter list
 */
static BalaList*
bala_data_type_real_get_parameters (BalaDataType* self)
{
	BalaList* result = NULL;
	result = NULL;
	return result;
}

BalaList*
bala_data_type_get_parameters (BalaDataType* self)
{
	g_return_val_if_fail (self != NULL, NULL);
	return BALA_DATA_TYPE_GET_CLASS (self)->get_parameters (self);
}

static gboolean
bala_data_type_real_is_reference_type_or_type_parameter (BalaDataType* self)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	BalaTypeSymbol* _tmp2_;
	BalaTypeSymbol* _tmp3_;
	gboolean result = FALSE;
	_tmp2_ = bala_data_type_get_type_symbol (self);
	_tmp3_ = _tmp2_;
	if (_tmp3_ != NULL) {
		BalaTypeSymbol* _tmp4_;
		BalaTypeSymbol* _tmp5_;
		_tmp4_ = bala_data_type_get_type_symbol (self);
		_tmp5_ = _tmp4_;
		_tmp1_ = bala_typesymbol_is_reference_type (_tmp5_);
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = BALA_IS_GENERIC_TYPE (self);
	}
	result = _tmp0_;
	return result;
}

gboolean
bala_data_type_is_reference_type_or_type_parameter (BalaDataType* self)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return BALA_DATA_TYPE_GET_CLASS (self)->is_reference_type_or_type_parameter (self);
}

static gboolean
bala_data_type_real_is_accessible (BalaDataType* self,
                                   BalaSymbol* sym)
{
	BalaTypeSymbol* _tmp10_;
	BalaTypeSymbol* _tmp11_;
	gboolean result = FALSE;
	g_return_val_if_fail (sym != NULL, FALSE);
	{
		BalaList* _type_arg_list = NULL;
		BalaList* _tmp0_;
		BalaList* _tmp1_;
		gint _type_arg_size = 0;
		BalaList* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		gint _type_arg_index = 0;
		_tmp0_ = bala_data_type_get_type_arguments (self);
		_tmp1_ = _bala_iterable_ref0 (_tmp0_);
		_type_arg_list = _tmp1_;
		_tmp2_ = _type_arg_list;
		_tmp3_ = bala_collection_get_size ((BalaCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_type_arg_size = _tmp4_;
		_type_arg_index = -1;
		while (TRUE) {
			gint _tmp5_;
			gint _tmp6_;
			BalaDataType* type_arg = NULL;
			BalaList* _tmp7_;
			gpointer _tmp8_;
			BalaDataType* _tmp9_;
			_type_arg_index = _type_arg_index + 1;
			_tmp5_ = _type_arg_index;
			_tmp6_ = _type_arg_size;
			if (!(_tmp5_ < _tmp6_)) {
				break;
			}
			_tmp7_ = _type_arg_list;
			_tmp8_ = bala_list_get (_tmp7_, _type_arg_index);
			type_arg = (BalaDataType*) _tmp8_;
			_tmp9_ = type_arg;
			if (!bala_data_type_is_accessible (_tmp9_, sym)) {
				result = FALSE;
				_bala_code_node_unref0 (type_arg);
				_bala_iterable_unref0 (_type_arg_list);
				return result;
			}
			_bala_code_node_unref0 (type_arg);
		}
		_bala_iterable_unref0 (_type_arg_list);
	}
	_tmp10_ = bala_data_type_get_type_symbol (self);
	_tmp11_ = _tmp10_;
	if (_tmp11_ != NULL) {
		BalaTypeSymbol* _tmp12_;
		BalaTypeSymbol* _tmp13_;
		_tmp12_ = bala_data_type_get_type_symbol (self);
		_tmp13_ = _tmp12_;
		result = bala_symbol_is_accessible ((BalaSymbol*) _tmp13_, sym);
		return result;
	}
	result = TRUE;
	return result;
}

gboolean
bala_data_type_is_accessible (BalaDataType* self,
                              BalaSymbol* sym)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return BALA_DATA_TYPE_GET_CLASS (self)->is_accessible (self, sym);
}

static BalaSymbol*
bala_data_type_real_get_member (BalaDataType* self,
                                const gchar* member_name)
{
	BalaTypeSymbol* _tmp0_;
	BalaTypeSymbol* _tmp1_;
	BalaSymbol* result = NULL;
	g_return_val_if_fail (member_name != NULL, NULL);
	_tmp0_ = bala_data_type_get_type_symbol (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ != NULL) {
		BalaTypeSymbol* _tmp2_;
		BalaTypeSymbol* _tmp3_;
		BalaSymbol* _tmp4_;
		_tmp2_ = bala_data_type_get_type_symbol (self);
		_tmp3_ = _tmp2_;
		_tmp4_ = bala_semantic_analyzer_symbol_lookup_inherited ((BalaSymbol*) _tmp3_, member_name);
		result = _tmp4_;
		return result;
	}
	result = NULL;
	return result;
}

BalaSymbol*
bala_data_type_get_member (BalaDataType* self,
                           const gchar* member_name)
{
	g_return_val_if_fail (self != NULL, NULL);
	return BALA_DATA_TYPE_GET_CLASS (self)->get_member (self, member_name);
}

static BalaSymbol*
bala_data_type_real_get_pointer_member (BalaDataType* self,
                                        const gchar* member_name)
{
	BalaSymbol* result = NULL;
	g_return_val_if_fail (member_name != NULL, NULL);
	result = NULL;
	return result;
}

BalaSymbol*
bala_data_type_get_pointer_member (BalaDataType* self,
                                   const gchar* member_name)
{
	g_return_val_if_fail (self != NULL, NULL);
	return BALA_DATA_TYPE_GET_CLASS (self)->get_pointer_member (self, member_name);
}

/**
 * Checks whether this data type references a real struct. A real struct
 * is a struct which is not a simple (fundamental) type.
 */
static gboolean
bala_data_type_real_is_real_struct_type (BalaDataType* self)
{
	BalaStruct* s = NULL;
	BalaTypeSymbol* _tmp0_;
	BalaTypeSymbol* _tmp1_;
	gboolean _tmp2_ = FALSE;
	BalaStruct* _tmp3_;
	gboolean result = FALSE;
	_tmp0_ = bala_data_type_get_type_symbol (self);
	_tmp1_ = _tmp0_;
	s = BALA_IS_STRUCT (_tmp1_) ? ((BalaStruct*) _tmp1_) : NULL;
	_tmp3_ = s;
	if (_tmp3_ != NULL) {
		BalaStruct* _tmp4_;
		_tmp4_ = s;
		_tmp2_ = !bala_struct_is_simple_type (_tmp4_);
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}

gboolean
bala_data_type_is_real_struct_type (BalaDataType* self)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return BALA_DATA_TYPE_GET_CLASS (self)->is_real_struct_type (self);
}

gboolean
bala_data_type_is_real_non_null_struct_type (BalaDataType* self)
{
	gboolean _tmp0_ = FALSE;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (bala_data_type_is_real_struct_type (self)) {
		gboolean _tmp1_;
		_tmp1_ = self->priv->_nullable;
		_tmp0_ = !_tmp1_;
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}

gboolean
bala_data_type_is_non_null_simple_type (BalaDataType* self)
{
	BalaStruct* s = NULL;
	BalaTypeSymbol* _tmp0_;
	BalaTypeSymbol* _tmp1_;
	gboolean _tmp2_ = FALSE;
	BalaStruct* _tmp3_;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = bala_data_type_get_type_symbol (self);
	_tmp1_ = _tmp0_;
	s = BALA_IS_STRUCT (_tmp1_) ? ((BalaStruct*) _tmp1_) : NULL;
	_tmp3_ = s;
	if (_tmp3_ != NULL) {
		BalaStruct* _tmp4_;
		_tmp4_ = s;
		_tmp2_ = bala_struct_is_simple_type (_tmp4_);
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		gboolean _tmp5_;
		_tmp5_ = self->priv->_nullable;
		result = !_tmp5_;
		return result;
	}
	result = FALSE;
	return result;
}

/**
 * Returns whether the value needs to be disposed, i.e. whether
 * allocated memory or other resources need to be released when
 * the value is no longer needed.
 */
static gboolean
bala_data_type_real_is_disposable (BalaDataType* self)
{
	gboolean _tmp0_;
	gboolean result = FALSE;
	_tmp0_ = self->priv->_value_owned;
	if (!_tmp0_) {
		result = FALSE;
		return result;
	}
	if (bala_data_type_is_reference_type_or_type_parameter (self)) {
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}

gboolean
bala_data_type_is_disposable (BalaDataType* self)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return BALA_DATA_TYPE_GET_CLASS (self)->is_disposable (self);
}

static BalaDataType*
bala_data_type_real_get_actual_type (BalaDataType* self,
                                     BalaDataType* derived_instance_type,
                                     BalaList* method_type_arguments,
                                     BalaCodeNode* node_reference)
{
	BalaDataType* _result_ = NULL;
	BalaDataType* _tmp0_;
	gboolean _tmp1_ = FALSE;
	BalaDataType* _tmp2_;
	BalaList* _tmp3_;
	BalaDataType* result = NULL;
	_tmp0_ = bala_data_type_copy (self);
	_result_ = _tmp0_;
	if (derived_instance_type == NULL) {
		_tmp1_ = method_type_arguments == NULL;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		result = _result_;
		return result;
	}
	_tmp2_ = _result_;
	_tmp3_ = _tmp2_->priv->type_argument_list;
	if (_tmp3_ != NULL) {
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp4_ = FALSE;
				_tmp4_ = TRUE;
				while (TRUE) {
					BalaDataType* _tmp6_;
					BalaList* _tmp7_;
					gint _tmp8_;
					gint _tmp9_;
					BalaDataType* _tmp10_;
					BalaList* _tmp11_;
					BalaDataType* _tmp12_;
					BalaList* _tmp13_;
					gpointer _tmp14_;
					BalaDataType* _tmp15_;
					BalaDataType* _tmp16_;
					BalaDataType* _tmp17_;
					if (!_tmp4_) {
						gint _tmp5_;
						_tmp5_ = i;
						i = _tmp5_ + 1;
					}
					_tmp4_ = FALSE;
					_tmp6_ = _result_;
					_tmp7_ = _tmp6_->priv->type_argument_list;
					_tmp8_ = bala_collection_get_size ((BalaCollection*) _tmp7_);
					_tmp9_ = _tmp8_;
					if (!(i < _tmp9_)) {
						break;
					}
					_tmp10_ = _result_;
					_tmp11_ = _tmp10_->priv->type_argument_list;
					_tmp12_ = _result_;
					_tmp13_ = _tmp12_->priv->type_argument_list;
					_tmp14_ = bala_list_get (_tmp13_, i);
					_tmp15_ = (BalaDataType*) _tmp14_;
					_tmp16_ = bala_data_type_get_actual_type (_tmp15_, derived_instance_type, method_type_arguments, node_reference);
					_tmp17_ = _tmp16_;
					bala_list_set (_tmp11_, i, _tmp17_);
					_bala_code_node_unref0 (_tmp17_);
					_bala_code_node_unref0 (_tmp15_);
				}
			}
		}
	}
	result = _result_;
	return result;
}

BalaDataType*
bala_data_type_get_actual_type (BalaDataType* self,
                                BalaDataType* derived_instance_type,
                                BalaList* method_type_arguments,
                                BalaCodeNode* node_reference)
{
	g_return_val_if_fail (self != NULL, NULL);
	return BALA_DATA_TYPE_GET_CLASS (self)->get_actual_type (self, derived_instance_type, method_type_arguments, node_reference);
}

gboolean
bala_data_type_is_generic (BalaDataType* self)
{
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (BALA_IS_GENERIC_TYPE (self)) {
		result = TRUE;
		return result;
	}
	if (!bala_data_type_has_type_arguments (self)) {
		result = FALSE;
		return result;
	}
	{
		BalaList* _type_arg_list = NULL;
		BalaList* _tmp0_;
		BalaList* _tmp1_;
		gint _type_arg_size = 0;
		BalaList* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		gint _type_arg_index = 0;
		_tmp0_ = self->priv->type_argument_list;
		_tmp1_ = _bala_iterable_ref0 (_tmp0_);
		_type_arg_list = _tmp1_;
		_tmp2_ = _type_arg_list;
		_tmp3_ = bala_collection_get_size ((BalaCollection*) _tmp2_);
		_tmp4_ = _tmp3_;
		_type_arg_size = _tmp4_;
		_type_arg_index = -1;
		while (TRUE) {
			gint _tmp5_;
			gint _tmp6_;
			BalaDataType* type_arg = NULL;
			BalaList* _tmp7_;
			gpointer _tmp8_;
			BalaDataType* _tmp9_;
			_type_arg_index = _type_arg_index + 1;
			_tmp5_ = _type_arg_index;
			_tmp6_ = _type_arg_size;
			if (!(_tmp5_ < _tmp6_)) {
				break;
			}
			_tmp7_ = _type_arg_list;
			_tmp8_ = bala_list_get (_tmp7_, _type_arg_index);
			type_arg = (BalaDataType*) _tmp8_;
			_tmp9_ = type_arg;
			if (bala_data_type_is_generic (_tmp9_)) {
				result = TRUE;
				_bala_code_node_unref0 (type_arg);
				_bala_iterable_unref0 (_type_arg_list);
				return result;
			}
			_bala_code_node_unref0 (type_arg);
		}
		_bala_iterable_unref0 (_type_arg_list);
	}
	result = FALSE;
	return result;
}

void
bala_data_type_replace_type_parameter (BalaDataType* self,
                                       BalaTypeParameter* old_type_param,
                                       BalaTypeParameter* new_type_param)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (old_type_param != NULL);
	g_return_if_fail (new_type_param != NULL);
	if (BALA_IS_GENERIC_TYPE (self)) {
		BalaGenericType* generic_type = NULL;
		BalaGenericType* _tmp0_;
		BalaTypeParameter* _tmp1_;
		BalaTypeParameter* _tmp2_;
		generic_type = G_TYPE_CHECK_INSTANCE_CAST (self, BALA_TYPE_GENERIC_TYPE, BalaGenericType);
		_tmp0_ = generic_type;
		_tmp1_ = bala_generic_type_get_type_parameter (_tmp0_);
		_tmp2_ = _tmp1_;
		if (_tmp2_ == old_type_param) {
			BalaGenericType* _tmp3_;
			_tmp3_ = generic_type;
			bala_generic_type_set_type_parameter (_tmp3_, new_type_param);
		}
		return;
	}
	if (!bala_data_type_has_type_arguments (self)) {
		return;
	}
	{
		BalaList* _type_arg_list = NULL;
		BalaList* _tmp4_;
		BalaList* _tmp5_;
		gint _type_arg_size = 0;
		BalaList* _tmp6_;
		gint _tmp7_;
		gint _tmp8_;
		gint _type_arg_index = 0;
		_tmp4_ = self->priv->type_argument_list;
		_tmp5_ = _bala_iterable_ref0 (_tmp4_);
		_type_arg_list = _tmp5_;
		_tmp6_ = _type_arg_list;
		_tmp7_ = bala_collection_get_size ((BalaCollection*) _tmp6_);
		_tmp8_ = _tmp7_;
		_type_arg_size = _tmp8_;
		_type_arg_index = -1;
		while (TRUE) {
			gint _tmp9_;
			gint _tmp10_;
			BalaDataType* type_arg = NULL;
			BalaList* _tmp11_;
			gpointer _tmp12_;
			BalaDataType* _tmp13_;
			_type_arg_index = _type_arg_index + 1;
			_tmp9_ = _type_arg_index;
			_tmp10_ = _type_arg_size;
			if (!(_tmp9_ < _tmp10_)) {
				break;
			}
			_tmp11_ = _type_arg_list;
			_tmp12_ = bala_list_get (_tmp11_, _type_arg_index);
			type_arg = (BalaDataType*) _tmp12_;
			_tmp13_ = type_arg;
			bala_data_type_replace_type_parameter (_tmp13_, old_type_param, new_type_param);
			_bala_code_node_unref0 (type_arg);
		}
		_bala_iterable_unref0 (_type_arg_list);
	}
}

/**
 * Search for the type parameter in this formal type and match it in
 * value_type.
 */
static BalaDataType*
bala_data_type_real_infer_type_argument (BalaDataType* self,
                                         BalaTypeParameter* type_param,
                                         BalaDataType* value_type)
{
	BalaIterator* value_type_arg_it = NULL;
	BalaList* _tmp0_;
	BalaIterator* _tmp1_;
	BalaDataType* result = NULL;
	g_return_val_if_fail (type_param != NULL, NULL);
	g_return_val_if_fail (value_type != NULL, NULL);
	_tmp0_ = bala_data_type_get_type_arguments (value_type);
	_tmp1_ = bala_iterable_iterator ((BalaIterable*) _tmp0_);
	value_type_arg_it = _tmp1_;
	{
		BalaList* _formal_type_arg_list = NULL;
		BalaList* _tmp2_;
		BalaList* _tmp3_;
		gint _formal_type_arg_size = 0;
		BalaList* _tmp4_;
		gint _tmp5_;
		gint _tmp6_;
		gint _formal_type_arg_index = 0;
		_tmp2_ = bala_data_type_get_type_arguments (self);
		_tmp3_ = _bala_iterable_ref0 (_tmp2_);
		_formal_type_arg_list = _tmp3_;
		_tmp4_ = _formal_type_arg_list;
		_tmp5_ = bala_collection_get_size ((BalaCollection*) _tmp4_);
		_tmp6_ = _tmp5_;
		_formal_type_arg_size = _tmp6_;
		_formal_type_arg_index = -1;
		while (TRUE) {
			gint _tmp7_;
			gint _tmp8_;
			BalaDataType* formal_type_arg = NULL;
			BalaList* _tmp9_;
			gpointer _tmp10_;
			BalaIterator* _tmp11_;
			_formal_type_arg_index = _formal_type_arg_index + 1;
			_tmp7_ = _formal_type_arg_index;
			_tmp8_ = _formal_type_arg_size;
			if (!(_tmp7_ < _tmp8_)) {
				break;
			}
			_tmp9_ = _formal_type_arg_list;
			_tmp10_ = bala_list_get (_tmp9_, _formal_type_arg_index);
			formal_type_arg = (BalaDataType*) _tmp10_;
			_tmp11_ = value_type_arg_it;
			if (bala_iterator_next (_tmp11_)) {
				BalaDataType* inferred_type = NULL;
				BalaDataType* _tmp12_;
				BalaIterator* _tmp13_;
				gpointer _tmp14_;
				BalaDataType* _tmp15_;
				BalaDataType* _tmp16_;
				BalaDataType* _tmp17_;
				BalaDataType* _tmp18_;
				_tmp12_ = formal_type_arg;
				_tmp13_ = value_type_arg_it;
				_tmp14_ = bala_iterator_get (_tmp13_);
				_tmp15_ = (BalaDataType*) _tmp14_;
				_tmp16_ = bala_data_type_infer_type_argument (_tmp12_, type_param, _tmp15_);
				_tmp17_ = _tmp16_;
				_bala_code_node_unref0 (_tmp15_);
				inferred_type = _tmp17_;
				_tmp18_ = inferred_type;
				if (_tmp18_ != NULL) {
					result = inferred_type;
					_bala_code_node_unref0 (formal_type_arg);
					_bala_iterable_unref0 (_formal_type_arg_list);
					_bala_iterator_unref0 (value_type_arg_it);
					return result;
				}
				_bala_code_node_unref0 (inferred_type);
			}
			_bala_code_node_unref0 (formal_type_arg);
		}
		_bala_iterable_unref0 (_formal_type_arg_list);
	}
	result = NULL;
	_bala_iterator_unref0 (value_type_arg_it);
	return result;
}

BalaDataType*
bala_data_type_infer_type_argument (BalaDataType* self,
                                    BalaTypeParameter* type_param,
                                    BalaDataType* value_type)
{
	g_return_val_if_fail (self != NULL, NULL);
	return BALA_DATA_TYPE_GET_CLASS (self)->infer_type_argument (self, type_param, value_type);
}

/**
 * Returns a stringified representation used for detailed error output
 *
 * @param override_name used as name if given
 * @return stringified representation
 */
static gchar*
bala_data_type_real_to_prototype_string (BalaDataType* self,
                                         const gchar* override_name)
{
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* result = NULL;
	if (bala_data_type_is_weak (self)) {
		_tmp0_ = "unowned ";
	} else {
		_tmp0_ = "";
	}
	_tmp1_ = bala_data_type_to_qualified_string (self, NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strdup_printf ("%s%s", _tmp0_, _tmp2_);
	_tmp4_ = _tmp3_;
	_g_free0 (_tmp2_);
	result = _tmp4_;
	return result;
}

gchar*
bala_data_type_to_prototype_string (BalaDataType* self,
                                    const gchar* override_name)
{
	g_return_val_if_fail (self != NULL, NULL);
	return BALA_DATA_TYPE_GET_CLASS (self)->to_prototype_string (self, override_name);
}

gboolean
bala_data_type_is_weak (BalaDataType* self)
{
	gboolean _tmp0_;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_value_owned;
	if (_tmp0_) {
		result = FALSE;
		return result;
	} else {
		gboolean _tmp1_ = FALSE;
		if (BALA_IS_VOID_TYPE (self)) {
			_tmp1_ = TRUE;
		} else {
			_tmp1_ = BALA_IS_POINTER_TYPE (self);
		}
		if (_tmp1_) {
			result = FALSE;
			return result;
		} else {
			if (BALA_IS_VALUE_TYPE (self)) {
				gboolean _tmp2_;
				_tmp2_ = self->priv->_nullable;
				if (_tmp2_) {
					result = TRUE;
					return result;
				}
				result = FALSE;
				return result;
			}
		}
	}
	result = TRUE;
	return result;
}

static gboolean
string_contains (const gchar* self,
                 const gchar* needle)
{
	gchar* _tmp0_;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}

static gchar*
string_replace (const gchar* self,
                const gchar* old,
                const gchar* replacement)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GError* _inner_error0_ = NULL;
	gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	if ((*((gchar*) self)) == '\0') {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = (*((gchar*) old)) == '\0';
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (old, replacement) == 0;
	}
	if (_tmp0_) {
		gchar* _tmp2_;
		_tmp2_ = g_strdup (self);
		result = _tmp2_;
		return result;
	}
	{
		GRegex* regex = NULL;
		gchar* _tmp3_;
		gchar* _tmp4_;
		GRegex* _tmp5_;
		GRegex* _tmp6_;
		gchar* _tmp7_ = NULL;
		GRegex* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp3_ = g_regex_escape_string (old, -1);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_regex_new (_tmp4_, 0, 0, &_inner_error0_);
		_tmp6_ = _tmp5_;
		_g_free0 (_tmp4_);
		regex = _tmp6_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return NULL;
		}
		_tmp8_ = regex;
		_tmp9_ = g_regex_replace_literal (_tmp8_, self, (gssize) -1, 0, replacement, 0, &_inner_error0_);
		_tmp7_ = _tmp9_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error0_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return NULL;
		}
		_tmp10_ = _tmp7_;
		_tmp7_ = NULL;
		result = _tmp10_;
		_g_free0 (_tmp7_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally0;
	__catch0_g_regex_error:
	{
		g_clear_error (&_inner_error0_);
		g_assert_not_reached ();
	}
	__finally0:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
	g_clear_error (&_inner_error0_);
	return NULL;
}

gchar*
bala_data_type_get_type_signature (BalaDataType* self,
                                   BalaSymbol* symbol)
{
	BalaArrayType* array_type = NULL;
	BalaArrayType* _tmp2_;
	gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	if (symbol != NULL) {
		gchar* sig = NULL;
		gchar* _tmp0_;
		const gchar* _tmp1_;
		_tmp0_ = bala_code_node_get_attribute_string ((BalaCodeNode*) symbol, "DBus", "signature", NULL);
		sig = _tmp0_;
		_tmp1_ = sig;
		if (_tmp1_ != NULL) {
			result = sig;
			return result;
		}
		_g_free0 (sig);
	}
	array_type = BALA_IS_ARRAY_TYPE (self) ? ((BalaArrayType*) self) : NULL;
	_tmp2_ = array_type;
	if (_tmp2_ != NULL) {
		gchar* element_type_signature = NULL;
		BalaArrayType* _tmp3_;
		BalaDataType* _tmp4_;
		BalaDataType* _tmp5_;
		gchar* _tmp6_;
		const gchar* _tmp7_;
		BalaArrayType* _tmp8_;
		gint _tmp9_;
		gint _tmp10_;
		gchar* _tmp11_;
		gchar* _tmp12_;
		const gchar* _tmp13_;
		gchar* _tmp14_;
		gchar* _tmp15_;
		_tmp3_ = array_type;
		_tmp4_ = bala_array_type_get_element_type (_tmp3_);
		_tmp5_ = _tmp4_;
		_tmp6_ = bala_data_type_get_type_signature (_tmp5_, NULL);
		element_type_signature = _tmp6_;
		_tmp7_ = element_type_signature;
		if (_tmp7_ == NULL) {
			result = NULL;
			_g_free0 (element_type_signature);
			return result;
		}
		_tmp8_ = array_type;
		_tmp9_ = bala_array_type_get_rank (_tmp8_);
		_tmp10_ = _tmp9_;
		_tmp11_ = g_strnfill ((gsize) _tmp10_, 'a');
		_tmp12_ = _tmp11_;
		_tmp13_ = element_type_signature;
		_tmp14_ = g_strconcat (_tmp12_, _tmp13_, NULL);
		_tmp15_ = _tmp14_;
		_g_free0 (_tmp12_);
		result = _tmp15_;
		_g_free0 (element_type_signature);
		return result;
	} else {
		gboolean _tmp16_ = FALSE;
		BalaTypeSymbol* _tmp17_;
		BalaTypeSymbol* _tmp18_;
		_tmp17_ = bala_data_type_get_type_symbol (self);
		_tmp18_ = _tmp17_;
		if (BALA_IS_ENUM (_tmp18_)) {
			BalaTypeSymbol* _tmp19_;
			BalaTypeSymbol* _tmp20_;
			_tmp19_ = bala_data_type_get_type_symbol (self);
			_tmp20_ = _tmp19_;
			_tmp16_ = bala_code_node_get_attribute_bool ((BalaCodeNode*) _tmp20_, "DBus", "use_string_marshalling", FALSE);
		} else {
			_tmp16_ = FALSE;
		}
		if (_tmp16_) {
			gchar* _tmp21_;
			_tmp21_ = g_strdup ("s");
			result = _tmp21_;
			return result;
		} else {
			BalaTypeSymbol* _tmp22_;
			BalaTypeSymbol* _tmp23_;
			_tmp22_ = bala_data_type_get_type_symbol (self);
			_tmp23_ = _tmp22_;
			if (_tmp23_ != NULL) {
				gchar* sig = NULL;
				BalaTypeSymbol* _tmp24_;
				BalaTypeSymbol* _tmp25_;
				gchar* _tmp26_;
				BalaStruct* st = NULL;
				BalaTypeSymbol* _tmp27_;
				BalaTypeSymbol* _tmp28_;
				BalaEnum* en = NULL;
				BalaTypeSymbol* _tmp29_;
				BalaTypeSymbol* _tmp30_;
				gboolean _tmp31_ = FALSE;
				const gchar* _tmp32_;
				BalaList* type_args = NULL;
				BalaList* _tmp69_;
				BalaList* _tmp70_;
				gboolean _tmp71_ = FALSE;
				gboolean _tmp72_ = FALSE;
				const gchar* _tmp73_;
				gboolean _tmp97_ = FALSE;
				const gchar* _tmp98_;
				_tmp24_ = bala_data_type_get_type_symbol (self);
				_tmp25_ = _tmp24_;
				_tmp26_ = bala_code_node_get_attribute_string ((BalaCodeNode*) _tmp25_, "CCode", "type_signature", NULL);
				sig = _tmp26_;
				_tmp27_ = bala_data_type_get_type_symbol (self);
				_tmp28_ = _tmp27_;
				st = BALA_IS_STRUCT (_tmp28_) ? ((BalaStruct*) _tmp28_) : NULL;
				_tmp29_ = bala_data_type_get_type_symbol (self);
				_tmp30_ = _tmp29_;
				en = BALA_IS_ENUM (_tmp30_) ? ((BalaEnum*) _tmp30_) : NULL;
				_tmp32_ = sig;
				if (_tmp32_ == NULL) {
					BalaStruct* _tmp33_;
					_tmp33_ = st;
					_tmp31_ = _tmp33_ != NULL;
				} else {
					_tmp31_ = FALSE;
				}
				if (_tmp31_) {
					GString* str = NULL;
					GString* _tmp34_;
					GString* _tmp35_;
					GString* _tmp57_;
					GString* _tmp58_;
					const gchar* _tmp59_;
					gchar* _tmp60_;
					_tmp34_ = g_string_new ("");
					str = _tmp34_;
					_tmp35_ = str;
					g_string_append_c (_tmp35_, '(');
					{
						BalaList* _f_list = NULL;
						BalaStruct* _tmp36_;
						BalaList* _tmp37_;
						BalaList* _tmp38_;
						gint _f_size = 0;
						BalaList* _tmp39_;
						gint _tmp40_;
						gint _tmp41_;
						gint _f_index = 0;
						_tmp36_ = st;
						_tmp37_ = bala_struct_get_fields (_tmp36_);
						_tmp38_ = _bala_iterable_ref0 (_tmp37_);
						_f_list = _tmp38_;
						_tmp39_ = _f_list;
						_tmp40_ = bala_collection_get_size ((BalaCollection*) _tmp39_);
						_tmp41_ = _tmp40_;
						_f_size = _tmp41_;
						_f_index = -1;
						while (TRUE) {
							gint _tmp42_;
							gint _tmp43_;
							BalaField* f = NULL;
							BalaList* _tmp44_;
							gpointer _tmp45_;
							BalaField* _tmp46_;
							BalaMemberBinding _tmp47_;
							BalaMemberBinding _tmp48_;
							_f_index = _f_index + 1;
							_tmp42_ = _f_index;
							_tmp43_ = _f_size;
							if (!(_tmp42_ < _tmp43_)) {
								break;
							}
							_tmp44_ = _f_list;
							_tmp45_ = bala_list_get (_tmp44_, _f_index);
							f = (BalaField*) _tmp45_;
							_tmp46_ = f;
							_tmp47_ = bala_field_get_binding (_tmp46_);
							_tmp48_ = _tmp47_;
							if (_tmp48_ == BALA_MEMBER_BINDING_INSTANCE) {
								gchar* s = NULL;
								BalaField* _tmp49_;
								BalaDataType* _tmp50_;
								BalaDataType* _tmp51_;
								BalaField* _tmp52_;
								gchar* _tmp53_;
								const gchar* _tmp54_;
								_tmp49_ = f;
								_tmp50_ = bala_variable_get_variable_type ((BalaVariable*) _tmp49_);
								_tmp51_ = _tmp50_;
								_tmp52_ = f;
								_tmp53_ = bala_data_type_get_type_signature (_tmp51_, (BalaSymbol*) _tmp52_);
								s = _tmp53_;
								_tmp54_ = s;
								if (_tmp54_ != NULL) {
									GString* _tmp55_;
									const gchar* _tmp56_;
									_tmp55_ = str;
									_tmp56_ = s;
									g_string_append (_tmp55_, _tmp56_);
								} else {
									result = NULL;
									_g_free0 (s);
									_bala_code_node_unref0 (f);
									_bala_iterable_unref0 (_f_list);
									_g_string_free0 (str);
									_g_free0 (sig);
									return result;
								}
								_g_free0 (s);
							}
							_bala_code_node_unref0 (f);
						}
						_bala_iterable_unref0 (_f_list);
					}
					_tmp57_ = str;
					g_string_append_c (_tmp57_, ')');
					_tmp58_ = str;
					_tmp59_ = _tmp58_->str;
					_tmp60_ = g_strdup (_tmp59_);
					_g_free0 (sig);
					sig = _tmp60_;
					_g_string_free0 (str);
				} else {
					gboolean _tmp61_ = FALSE;
					const gchar* _tmp62_;
					_tmp62_ = sig;
					if (_tmp62_ == NULL) {
						BalaEnum* _tmp63_;
						_tmp63_ = en;
						_tmp61_ = _tmp63_ != NULL;
					} else {
						_tmp61_ = FALSE;
					}
					if (_tmp61_) {
						BalaEnum* _tmp64_;
						gboolean _tmp65_;
						gboolean _tmp66_;
						_tmp64_ = en;
						_tmp65_ = bala_enum_get_is_flags (_tmp64_);
						_tmp66_ = _tmp65_;
						if (_tmp66_) {
							gchar* _tmp67_;
							_tmp67_ = g_strdup ("u");
							result = _tmp67_;
							_g_free0 (sig);
							return result;
						} else {
							gchar* _tmp68_;
							_tmp68_ = g_strdup ("i");
							result = _tmp68_;
							_g_free0 (sig);
							return result;
						}
					}
				}
				_tmp69_ = bala_data_type_get_type_arguments (self);
				_tmp70_ = _bala_iterable_ref0 (_tmp69_);
				type_args = _tmp70_;
				_tmp73_ = sig;
				if (_tmp73_ != NULL) {
					const gchar* _tmp74_;
					_tmp74_ = sig;
					_tmp72_ = string_contains (_tmp74_, "%s");
				} else {
					_tmp72_ = FALSE;
				}
				if (_tmp72_) {
					BalaList* _tmp75_;
					gint _tmp76_;
					gint _tmp77_;
					_tmp75_ = type_args;
					_tmp76_ = bala_collection_get_size ((BalaCollection*) _tmp75_);
					_tmp77_ = _tmp76_;
					_tmp71_ = _tmp77_ > 0;
				} else {
					_tmp71_ = FALSE;
				}
				if (_tmp71_) {
					gchar* element_sig = NULL;
					gchar* _tmp78_;
					const gchar* _tmp94_;
					const gchar* _tmp95_;
					gchar* _tmp96_;
					_tmp78_ = g_strdup ("");
					element_sig = _tmp78_;
					{
						BalaList* _type_arg_list = NULL;
						BalaList* _tmp79_;
						BalaList* _tmp80_;
						gint _type_arg_size = 0;
						BalaList* _tmp81_;
						gint _tmp82_;
						gint _tmp83_;
						gint _type_arg_index = 0;
						_tmp79_ = type_args;
						_tmp80_ = _bala_iterable_ref0 (_tmp79_);
						_type_arg_list = _tmp80_;
						_tmp81_ = _type_arg_list;
						_tmp82_ = bala_collection_get_size ((BalaCollection*) _tmp81_);
						_tmp83_ = _tmp82_;
						_type_arg_size = _tmp83_;
						_type_arg_index = -1;
						while (TRUE) {
							gint _tmp84_;
							gint _tmp85_;
							BalaDataType* type_arg = NULL;
							BalaList* _tmp86_;
							gpointer _tmp87_;
							gchar* s = NULL;
							BalaDataType* _tmp88_;
							gchar* _tmp89_;
							const gchar* _tmp90_;
							_type_arg_index = _type_arg_index + 1;
							_tmp84_ = _type_arg_index;
							_tmp85_ = _type_arg_size;
							if (!(_tmp84_ < _tmp85_)) {
								break;
							}
							_tmp86_ = _type_arg_list;
							_tmp87_ = bala_list_get (_tmp86_, _type_arg_index);
							type_arg = (BalaDataType*) _tmp87_;
							_tmp88_ = type_arg;
							_tmp89_ = bala_data_type_get_type_signature (_tmp88_, NULL);
							s = _tmp89_;
							_tmp90_ = s;
							if (_tmp90_ != NULL) {
								const gchar* _tmp91_;
								const gchar* _tmp92_;
								gchar* _tmp93_;
								_tmp91_ = element_sig;
								_tmp92_ = s;
								_tmp93_ = g_strconcat (_tmp91_, _tmp92_, NULL);
								_g_free0 (element_sig);
								element_sig = _tmp93_;
							}
							_g_free0 (s);
							_bala_code_node_unref0 (type_arg);
						}
						_bala_iterable_unref0 (_type_arg_list);
					}
					_tmp94_ = sig;
					_tmp95_ = element_sig;
					_tmp96_ = string_replace (_tmp94_, "%s", _tmp95_);
					_g_free0 (sig);
					sig = _tmp96_;
					_g_free0 (element_sig);
				}
				_tmp98_ = sig;
				if (_tmp98_ == NULL) {
					gboolean _tmp99_ = FALSE;
					gboolean _tmp100_ = FALSE;
					BalaTypeSymbol* _tmp101_;
					BalaTypeSymbol* _tmp102_;
					gchar* _tmp103_;
					gchar* _tmp104_;
					gboolean _tmp105_;
					_tmp101_ = bala_data_type_get_type_symbol (self);
					_tmp102_ = _tmp101_;
					_tmp103_ = bala_symbol_get_full_name ((BalaSymbol*) _tmp102_);
					_tmp104_ = _tmp103_;
					_tmp105_ = g_strcmp0 (_tmp104_, "GLib.UnixInputStream") == 0;
					_g_free0 (_tmp104_);
					if (_tmp105_) {
						_tmp100_ = TRUE;
					} else {
						BalaTypeSymbol* _tmp106_;
						BalaTypeSymbol* _tmp107_;
						gchar* _tmp108_;
						gchar* _tmp109_;
						_tmp106_ = bala_data_type_get_type_symbol (self);
						_tmp107_ = _tmp106_;
						_tmp108_ = bala_symbol_get_full_name ((BalaSymbol*) _tmp107_);
						_tmp109_ = _tmp108_;
						_tmp100_ = g_strcmp0 (_tmp109_, "GLib.UnixOutputStream") == 0;
						_g_free0 (_tmp109_);
					}
					if (_tmp100_) {
						_tmp99_ = TRUE;
					} else {
						BalaTypeSymbol* _tmp110_;
						BalaTypeSymbol* _tmp111_;
						gchar* _tmp112_;
						gchar* _tmp113_;
						_tmp110_ = bala_data_type_get_type_symbol (self);
						_tmp111_ = _tmp110_;
						_tmp112_ = bala_symbol_get_full_name ((BalaSymbol*) _tmp111_);
						_tmp113_ = _tmp112_;
						_tmp99_ = g_strcmp0 (_tmp113_, "GLib.Socket") == 0;
						_g_free0 (_tmp113_);
					}
					_tmp97_ = _tmp99_;
				} else {
					_tmp97_ = FALSE;
				}
				if (_tmp97_) {
					gchar* _tmp114_;
					_tmp114_ = g_strdup ("h");
					result = _tmp114_;
					_bala_iterable_unref0 (type_args);
					_g_free0 (sig);
					return result;
				}
				result = sig;
				_bala_iterable_unref0 (type_args);
				return result;
			} else {
				result = NULL;
				return result;
			}
		}
	}
}

/**
 * Returns whether the given amount of type-argument matches the symbol's count of type-parameters
 *
 * @param context a CodeContext
 * @param allow_none whether no type-argments are allowed
 * @return true if successful
 */
gboolean
bala_data_type_check_type_arguments (BalaDataType* self,
                                     BalaCodeContext* context,
                                     gboolean allow_none)
{
	gint n_type_args = 0;
	BalaList* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint expected_n_type_args = 0;
	BalaTypeSymbol* _tmp3_;
	BalaTypeSymbol* _tmp4_;
	gboolean _tmp32_ = FALSE;
	gboolean _tmp33_ = FALSE;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (context != NULL, FALSE);
	_tmp0_ = bala_data_type_get_type_arguments (self);
	_tmp1_ = bala_collection_get_size ((BalaCollection*) _tmp0_);
	_tmp2_ = _tmp1_;
	n_type_args = _tmp2_;
	expected_n_type_args = 0;
	_tmp3_ = bala_data_type_get_type_symbol (self);
	_tmp4_ = _tmp3_;
	if (BALA_IS_OBJECT_TYPE_SYMBOL (_tmp4_)) {
		BalaTypeSymbol* _tmp5_;
		BalaTypeSymbol* _tmp6_;
		BalaList* _tmp7_;
		gint _tmp8_;
		gint _tmp9_;
		_tmp5_ = bala_data_type_get_type_symbol (self);
		_tmp6_ = _tmp5_;
		_tmp7_ = bala_object_type_symbol_get_type_parameters (G_TYPE_CHECK_INSTANCE_CAST (_tmp6_, BALA_TYPE_OBJECT_TYPE_SYMBOL, BalaObjectTypeSymbol));
		_tmp8_ = bala_collection_get_size ((BalaCollection*) _tmp7_);
		_tmp9_ = _tmp8_;
		expected_n_type_args = _tmp9_;
	} else {
		BalaTypeSymbol* _tmp10_;
		BalaTypeSymbol* _tmp11_;
		_tmp10_ = bala_data_type_get_type_symbol (self);
		_tmp11_ = _tmp10_;
		if (BALA_IS_STRUCT (_tmp11_)) {
			BalaTypeSymbol* _tmp12_;
			BalaTypeSymbol* _tmp13_;
			BalaList* _tmp14_;
			gint _tmp15_;
			gint _tmp16_;
			_tmp12_ = bala_data_type_get_type_symbol (self);
			_tmp13_ = _tmp12_;
			_tmp14_ = bala_struct_get_type_parameters (G_TYPE_CHECK_INSTANCE_CAST (_tmp13_, BALA_TYPE_STRUCT, BalaStruct));
			_tmp15_ = bala_collection_get_size ((BalaCollection*) _tmp14_);
			_tmp16_ = _tmp15_;
			expected_n_type_args = _tmp16_;
		} else {
			BalaTypeSymbol* _tmp17_;
			BalaTypeSymbol* _tmp18_;
			_tmp17_ = bala_data_type_get_type_symbol (self);
			_tmp18_ = _tmp17_;
			if (BALA_IS_DELEGATE (_tmp18_)) {
				BalaTypeSymbol* _tmp19_;
				BalaTypeSymbol* _tmp20_;
				BalaList* _tmp21_;
				gint _tmp22_;
				gint _tmp23_;
				_tmp19_ = bala_data_type_get_type_symbol (self);
				_tmp20_ = _tmp19_;
				_tmp21_ = bala_delegate_get_type_parameters (G_TYPE_CHECK_INSTANCE_CAST (_tmp20_, BALA_TYPE_DELEGATE, BalaDelegate));
				_tmp22_ = bala_collection_get_size ((BalaCollection*) _tmp21_);
				_tmp23_ = _tmp22_;
				expected_n_type_args = _tmp23_;
			} else {
				if (n_type_args > 0) {
					BalaSourceReference* _tmp24_;
					BalaSourceReference* _tmp25_;
					BalaTypeSymbol* _tmp26_;
					BalaTypeSymbol* _tmp27_;
					gchar* _tmp28_;
					gchar* _tmp29_;
					gchar* _tmp30_;
					gchar* _tmp31_;
					_tmp24_ = bala_code_node_get_source_reference ((BalaCodeNode*) self);
					_tmp25_ = _tmp24_;
					_tmp26_ = bala_data_type_get_type_symbol (self);
					_tmp27_ = _tmp26_;
					_tmp28_ = bala_symbol_get_full_name ((BalaSymbol*) _tmp27_);
					_tmp29_ = _tmp28_;
					_tmp30_ = g_strdup_printf ("`%s' does not support type arguments", _tmp29_);
					_tmp31_ = _tmp30_;
					bala_report_error (_tmp25_, _tmp31_);
					_g_free0 (_tmp31_);
					_g_free0 (_tmp29_);
					bala_code_node_set_error ((BalaCodeNode*) self, TRUE);
					result = FALSE;
					return result;
				} else {
					result = TRUE;
					return result;
				}
			}
		}
	}
	if (!allow_none) {
		_tmp33_ = TRUE;
	} else {
		_tmp33_ = n_type_args > 0;
	}
	if (_tmp33_) {
		_tmp32_ = n_type_args < expected_n_type_args;
	} else {
		_tmp32_ = FALSE;
	}
	if (_tmp32_) {
		BalaSourceReference* _tmp34_;
		BalaSourceReference* _tmp35_;
		BalaTypeSymbol* _tmp36_;
		BalaTypeSymbol* _tmp37_;
		gchar* _tmp38_;
		gchar* _tmp39_;
		gchar* _tmp40_;
		gchar* _tmp41_;
		bala_code_node_set_error ((BalaCodeNode*) self, TRUE);
		_tmp34_ = bala_code_node_get_source_reference ((BalaCodeNode*) self);
		_tmp35_ = _tmp34_;
		_tmp36_ = bala_data_type_get_type_symbol (self);
		_tmp37_ = _tmp36_;
		_tmp38_ = bala_symbol_get_full_name ((BalaSymbol*) _tmp37_);
		_tmp39_ = _tmp38_;
		_tmp40_ = g_strdup_printf ("too few type arguments for `%s'", _tmp39_);
		_tmp41_ = _tmp40_;
		bala_report_error (_tmp35_, _tmp41_);
		_g_free0 (_tmp41_);
		_g_free0 (_tmp39_);
		result = FALSE;
		return result;
	} else {
		gboolean _tmp42_ = FALSE;
		gboolean _tmp43_ = FALSE;
		if (!allow_none) {
			_tmp43_ = TRUE;
		} else {
			_tmp43_ = n_type_args > 0;
		}
		if (_tmp43_) {
			_tmp42_ = n_type_args > expected_n_type_args;
		} else {
			_tmp42_ = FALSE;
		}
		if (_tmp42_) {
			BalaSourceReference* _tmp44_;
			BalaSourceReference* _tmp45_;
			BalaTypeSymbol* _tmp46_;
			BalaTypeSymbol* _tmp47_;
			gchar* _tmp48_;
			gchar* _tmp49_;
			gchar* _tmp50_;
			gchar* _tmp51_;
			bala_code_node_set_error ((BalaCodeNode*) self, TRUE);
			_tmp44_ = bala_code_node_get_source_reference ((BalaCodeNode*) self);
			_tmp45_ = _tmp44_;
			_tmp46_ = bala_data_type_get_type_symbol (self);
			_tmp47_ = _tmp46_;
			_tmp48_ = bala_symbol_get_full_name ((BalaSymbol*) _tmp47_);
			_tmp49_ = _tmp48_;
			_tmp50_ = g_strdup_printf ("too many type arguments for `%s'", _tmp49_);
			_tmp51_ = _tmp50_;
			bala_report_error (_tmp45_, _tmp51_);
			_g_free0 (_tmp51_);
			_g_free0 (_tmp49_);
			result = FALSE;
			return result;
		}
	}
	{
		BalaList* _type_list = NULL;
		BalaList* _tmp52_;
		BalaList* _tmp53_;
		gint _type_size = 0;
		BalaList* _tmp54_;
		gint _tmp55_;
		gint _tmp56_;
		gint _type_index = 0;
		_tmp52_ = bala_data_type_get_type_arguments (self);
		_tmp53_ = _bala_iterable_ref0 (_tmp52_);
		_type_list = _tmp53_;
		_tmp54_ = _type_list;
		_tmp55_ = bala_collection_get_size ((BalaCollection*) _tmp54_);
		_tmp56_ = _tmp55_;
		_type_size = _tmp56_;
		_type_index = -1;
		while (TRUE) {
			gint _tmp57_;
			gint _tmp58_;
			BalaDataType* type = NULL;
			BalaList* _tmp59_;
			gpointer _tmp60_;
			BalaDataType* _tmp61_;
			_type_index = _type_index + 1;
			_tmp57_ = _type_index;
			_tmp58_ = _type_size;
			if (!(_tmp57_ < _tmp58_)) {
				break;
			}
			_tmp59_ = _type_list;
			_tmp60_ = bala_list_get (_tmp59_, _type_index);
			type = (BalaDataType*) _tmp60_;
			_tmp61_ = type;
			if (!bala_code_node_check ((BalaCodeNode*) _tmp61_, context)) {
				result = FALSE;
				_bala_code_node_unref0 (type);
				_bala_iterable_unref0 (_type_list);
				return result;
			}
			_bala_code_node_unref0 (type);
		}
		_bala_iterable_unref0 (_type_list);
	}
	result = TRUE;
	return result;
}

BalaDataType*
bala_data_type_construct (GType object_type)
{
	BalaDataType* self = NULL;
	self = (BalaDataType*) bala_code_node_construct (object_type);
	return self;
}

static void
bala_data_type_class_init (BalaDataTypeClass * klass,
                           gpointer klass_data)
{
	bala_data_type_parent_class = g_type_class_peek_parent (klass);
	((BalaCodeNodeClass *) klass)->finalize = bala_data_type_finalize;
	g_type_class_adjust_private_offset (klass, &BalaDataType_private_offset);
	((BalaCodeNodeClass *) klass)->accept = (void (*) (BalaCodeNode*, BalaCodeVisitor*)) bala_data_type_real_accept;
	((BalaCodeNodeClass *) klass)->accept_children = (void (*) (BalaCodeNode*, BalaCodeVisitor*)) bala_data_type_real_accept_children;
	((BalaCodeNodeClass *) klass)->to_string = (gchar* (*) (BalaCodeNode*)) bala_data_type_real_to_string;
	((BalaDataTypeClass *) klass)->to_qualified_string = (gchar* (*) (BalaDataType*, BalaScope*)) bala_data_type_real_to_qualified_string;
	((BalaDataTypeClass *) klass)->copy = (BalaDataType* (*) (BalaDataType*)) bala_data_type_real_copy;
	((BalaDataTypeClass *) klass)->equals = (gboolean (*) (BalaDataType*, BalaDataType*)) bala_data_type_real_equals;
	((BalaDataTypeClass *) klass)->stricter = (gboolean (*) (BalaDataType*, BalaDataType*)) bala_data_type_real_stricter;
	((BalaCodeNodeClass *) klass)->replace_type = (void (*) (BalaCodeNode*, BalaDataType*, BalaDataType*)) bala_data_type_real_replace_type;
	((BalaDataTypeClass *) klass)->compatible = (gboolean (*) (BalaDataType*, BalaDataType*)) bala_data_type_real_compatible;
	((BalaDataTypeClass *) klass)->is_invokable = (gboolean (*) (BalaDataType*)) bala_data_type_real_is_invokable;
	((BalaDataTypeClass *) klass)->get_return_type = (BalaDataType* (*) (BalaDataType*)) bala_data_type_real_get_return_type;
	((BalaDataTypeClass *) klass)->get_parameters = (BalaList* (*) (BalaDataType*)) bala_data_type_real_get_parameters;
	((BalaDataTypeClass *) klass)->is_reference_type_or_type_parameter = (gboolean (*) (BalaDataType*)) bala_data_type_real_is_reference_type_or_type_parameter;
	((BalaDataTypeClass *) klass)->is_accessible = (gboolean (*) (BalaDataType*, BalaSymbol*)) bala_data_type_real_is_accessible;
	((BalaDataTypeClass *) klass)->get_member = (BalaSymbol* (*) (BalaDataType*, const gchar*)) bala_data_type_real_get_member;
	((BalaDataTypeClass *) klass)->get_pointer_member = (BalaSymbol* (*) (BalaDataType*, const gchar*)) bala_data_type_real_get_pointer_member;
	((BalaDataTypeClass *) klass)->is_real_struct_type = (gboolean (*) (BalaDataType*)) bala_data_type_real_is_real_struct_type;
	((BalaDataTypeClass *) klass)->is_disposable = (gboolean (*) (BalaDataType*)) bala_data_type_real_is_disposable;
	((BalaDataTypeClass *) klass)->get_actual_type = (BalaDataType* (*) (BalaDataType*, BalaDataType*, BalaList*, BalaCodeNode*)) bala_data_type_real_get_actual_type;
	((BalaDataTypeClass *) klass)->infer_type_argument = (BalaDataType* (*) (BalaDataType*, BalaTypeParameter*, BalaDataType*)) bala_data_type_real_infer_type_argument;
	((BalaDataTypeClass *) klass)->to_prototype_string = (gchar* (*) (BalaDataType*, const gchar*)) bala_data_type_real_to_prototype_string;
}

static void
bala_data_type_instance_init (BalaDataType * self,
                              gpointer klass)
{
	self->priv = bala_data_type_get_instance_private (self);
}

static void
bala_data_type_finalize (BalaCodeNode * obj)
{
	BalaDataType * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, BALA_TYPE_DATA_TYPE, BalaDataType);
	_bala_iterable_unref0 (self->priv->type_argument_list);
	BALA_CODE_NODE_CLASS (bala_data_type_parent_class)->finalize (obj);
}

/**
 * A reference to a data type. This is used to specify static types of
 * expressions.
 */
static GType
bala_data_type_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (BalaDataTypeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bala_data_type_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BalaDataType), 0, (GInstanceInitFunc) bala_data_type_instance_init, NULL };
	GType bala_data_type_type_id;
	bala_data_type_type_id = g_type_register_static (BALA_TYPE_CODE_NODE, "BalaDataType", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
	BalaDataType_private_offset = g_type_add_instance_private (bala_data_type_type_id, sizeof (BalaDataTypePrivate));
	return bala_data_type_type_id;
}

GType
bala_data_type_get_type (void)
{
	static volatile gsize bala_data_type_type_id__volatile = 0;
	if (g_once_init_enter (&bala_data_type_type_id__volatile)) {
		GType bala_data_type_type_id;
		bala_data_type_type_id = bala_data_type_get_type_once ();
		g_once_init_leave (&bala_data_type_type_id__volatile, bala_data_type_type_id);
	}
	return bala_data_type_type_id__volatile;
}

