/* balacallabletype.c generated by balac, the Bala compiler
 * generated from balacallabletype.bala, do not modify */

/* balacallabletype.bala
 *
 * Copyright (C) 2017  Rico Tzschichholz
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Rico Tzschichholz <ricotz@ubuntu.com>
 */

#include "bala.h"
#include <glib.h>
#include <balagee.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _bala_code_node_unref0(var) ((var == NULL) ? NULL : (var = (bala_code_node_unref (var), NULL)))
#define _bala_iterable_unref0(var) ((var == NULL) ? NULL : (var = (bala_iterable_unref (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

static gpointer bala_callable_type_parent_class = NULL;

static gboolean bala_callable_type_real_is_invokable (BalaDataType* base);
static BalaDataType* bala_callable_type_real_get_return_type (BalaDataType* base);
static BalaList* bala_callable_type_real_get_parameters (BalaDataType* base);
static gchar* bala_callable_type_real_to_prototype_string (BalaDataType* base,
                                                    const gchar* override_name);
static GType bala_callable_type_get_type_once (void);

BalaCallable*
bala_callable_type_get_callable_symbol (BalaCallableType* self)
{
	BalaCallable* result;
	BalaSymbol* _tmp0_;
	BalaSymbol* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = bala_data_type_get_symbol ((BalaDataType*) self);
	_tmp1_ = _tmp0_;
	result = G_TYPE_CHECK_INSTANCE_CAST (_tmp1_, BALA_TYPE_CALLABLE, BalaCallable);
	return result;
}

BalaCallableType*
bala_callable_type_construct (GType object_type,
                              BalaSymbol* symbol)
{
	BalaCallableType* self = NULL;
	g_return_val_if_fail (symbol != NULL, NULL);
	self = (BalaCallableType*) bala_data_type_construct_with_symbol (object_type, symbol);
	return self;
}

static gboolean
bala_callable_type_real_is_invokable (BalaDataType* base)
{
	BalaCallableType * self;
	gboolean result = FALSE;
	self = (BalaCallableType*) base;
	result = TRUE;
	return result;
}

static BalaDataType*
bala_callable_type_real_get_return_type (BalaDataType* base)
{
	BalaCallableType * self;
	BalaCallable* _tmp0_;
	BalaCallable* _tmp1_;
	BalaDataType* _tmp2_;
	BalaDataType* _tmp3_;
	BalaDataType* result = NULL;
	self = (BalaCallableType*) base;
	_tmp0_ = bala_callable_type_get_callable_symbol (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = bala_callable_get_return_type (_tmp1_);
	_tmp3_ = _tmp2_;
	result = _tmp3_;
	return result;
}

static BalaList*
bala_callable_type_real_get_parameters (BalaDataType* base)
{
	BalaCallableType * self;
	BalaCallable* _tmp0_;
	BalaCallable* _tmp1_;
	BalaList* _tmp2_;
	BalaList* result = NULL;
	self = (BalaCallableType*) base;
	_tmp0_ = bala_callable_type_get_callable_symbol (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = bala_callable_get_parameters (_tmp1_);
	result = _tmp2_;
	return result;
}

static gpointer
_bala_iterable_ref0 (gpointer self)
{
	return self ? bala_iterable_ref (self) : NULL;
}

static gchar*
bala_callable_type_real_to_prototype_string (BalaDataType* base,
                                             const gchar* override_name)
{
	BalaCallableType * self;
	GString* builder = NULL;
	GString* _tmp0_;
	BalaDelegateType* delegate_type = NULL;
	BalaMethodType* method_type = NULL;
	BalaSignalType* signal_type = NULL;
	gboolean _tmp1_ = FALSE;
	BalaMethodType* _tmp2_;
	gboolean _tmp13_ = FALSE;
	BalaMethodType* _tmp14_;
	GString* _tmp22_;
	gchar* _tmp23_ = NULL;
	gchar* _tmp24_;
	GString* _tmp26_;
	GString* _tmp27_;
	GString* _tmp28_;
	gint i = 0;
	BalaDelegateType* _tmp29_;
	GString* _tmp109_;
	BalaArrayList* error_types = NULL;
	GEqualFunc _tmp110_;
	BalaArrayList* _tmp111_;
	BalaArrayList* _tmp112_;
	BalaArrayList* _tmp113_;
	gint _tmp114_;
	gint _tmp115_;
	GString* _tmp131_;
	const gchar* _tmp132_;
	gchar* _tmp133_;
	gchar* result = NULL;
	self = (BalaCallableType*) base;
	_tmp0_ = g_string_new ("");
	builder = _tmp0_;
	delegate_type = BALA_IS_DELEGATE_TYPE (self) ? ((BalaDelegateType*) self) : NULL;
	method_type = BALA_IS_METHOD_TYPE (self) ? ((BalaMethodType*) self) : NULL;
	signal_type = BALA_IS_SIGNAL_TYPE (self) ? ((BalaSignalType*) self) : NULL;
	_tmp2_ = method_type;
	if (_tmp2_ != NULL) {
		BalaMethodType* _tmp3_;
		BalaMethod* _tmp4_;
		BalaMethod* _tmp5_;
		gboolean _tmp6_;
		gboolean _tmp7_;
		_tmp3_ = method_type;
		_tmp4_ = bala_method_type_get_method_symbol (_tmp3_);
		_tmp5_ = _tmp4_;
		_tmp6_ = bala_method_get_coroutine (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp1_ = _tmp7_;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		GString* _tmp8_;
		_tmp8_ = builder;
		g_string_append (_tmp8_, "async ");
	} else {
		BalaDelegateType* _tmp9_;
		_tmp9_ = delegate_type;
		if (_tmp9_ != NULL) {
			GString* _tmp10_;
			_tmp10_ = builder;
			g_string_append (_tmp10_, "delegate ");
		} else {
			BalaSignalType* _tmp11_;
			_tmp11_ = signal_type;
			if (_tmp11_ != NULL) {
				GString* _tmp12_;
				_tmp12_ = builder;
				g_string_append (_tmp12_, "signal ");
			}
		}
	}
	_tmp14_ = method_type;
	if (_tmp14_ == NULL) {
		_tmp13_ = TRUE;
	} else {
		BalaMethodType* _tmp15_;
		BalaMethod* _tmp16_;
		BalaMethod* _tmp17_;
		_tmp15_ = method_type;
		_tmp16_ = bala_method_type_get_method_symbol (_tmp15_);
		_tmp17_ = _tmp16_;
		_tmp13_ = !BALA_IS_CREATION_METHOD (_tmp17_);
	}
	if (_tmp13_) {
		GString* _tmp18_;
		BalaDataType* _tmp19_;
		gchar* _tmp20_;
		gchar* _tmp21_;
		_tmp18_ = builder;
		_tmp19_ = bala_data_type_get_return_type ((BalaDataType*) self);
		_tmp20_ = bala_data_type_to_prototype_string (_tmp19_, NULL);
		_tmp21_ = _tmp20_;
		g_string_append (_tmp18_, _tmp21_);
		_g_free0 (_tmp21_);
	}
	_tmp22_ = builder;
	g_string_append_c (_tmp22_, ' ');
	_tmp24_ = g_strdup (override_name);
	_tmp23_ = _tmp24_;
	if (_tmp23_ == NULL) {
		gchar* _tmp25_;
		_tmp25_ = bala_code_node_to_string ((BalaCodeNode*) self);
		_g_free0 (_tmp23_);
		_tmp23_ = _tmp25_;
	}
	_tmp26_ = builder;
	g_string_append (_tmp26_, _tmp23_);
	_tmp27_ = builder;
	g_string_append_c (_tmp27_, ' ');
	_tmp28_ = builder;
	g_string_append_c (_tmp28_, '(');
	i = 1;
	_tmp29_ = delegate_type;
	if (_tmp29_ != NULL) {
		BalaDelegate* delegate_symbol = NULL;
		BalaDelegateType* _tmp30_;
		BalaDelegate* _tmp31_;
		BalaDelegate* _tmp32_;
		gboolean _tmp33_ = FALSE;
		BalaDelegate* _tmp34_;
		BalaSymbol* _tmp35_;
		BalaSymbol* _tmp36_;
		_tmp30_ = delegate_type;
		_tmp31_ = bala_delegate_type_get_delegate_symbol (_tmp30_);
		_tmp32_ = _tmp31_;
		delegate_symbol = _tmp32_;
		_tmp34_ = delegate_symbol;
		_tmp35_ = bala_symbol_get_parent_symbol ((BalaSymbol*) _tmp34_);
		_tmp36_ = _tmp35_;
		if (BALA_IS_SIGNAL (_tmp36_)) {
			BalaDelegate* _tmp37_;
			BalaDataType* _tmp38_;
			BalaDataType* _tmp39_;
			_tmp37_ = delegate_symbol;
			_tmp38_ = bala_delegate_get_sender_type (_tmp37_);
			_tmp39_ = _tmp38_;
			_tmp33_ = _tmp39_ != NULL;
		} else {
			_tmp33_ = FALSE;
		}
		if (_tmp33_) {
			GString* _tmp40_;
			BalaDelegate* _tmp41_;
			BalaDataType* _tmp42_;
			BalaDataType* _tmp43_;
			gchar* _tmp44_;
			gchar* _tmp45_;
			gint _tmp46_;
			_tmp40_ = builder;
			_tmp41_ = delegate_symbol;
			_tmp42_ = bala_delegate_get_sender_type (_tmp41_);
			_tmp43_ = _tmp42_;
			_tmp44_ = bala_data_type_to_qualified_string (_tmp43_, NULL);
			_tmp45_ = _tmp44_;
			g_string_append (_tmp40_, _tmp45_);
			_g_free0 (_tmp45_);
			_tmp46_ = i;
			i = _tmp46_ + 1;
		}
	}
	{
		BalaList* _param_list = NULL;
		BalaList* _tmp47_;
		BalaList* _tmp48_;
		gint _param_size = 0;
		BalaList* _tmp49_;
		gint _tmp50_;
		gint _tmp51_;
		gint _param_index = 0;
		_tmp47_ = bala_data_type_get_parameters ((BalaDataType*) self);
		_tmp48_ = _bala_iterable_ref0 (_tmp47_);
		_param_list = _tmp48_;
		_tmp49_ = _param_list;
		_tmp50_ = bala_collection_get_size ((BalaCollection*) _tmp49_);
		_tmp51_ = _tmp50_;
		_param_size = _tmp51_;
		_param_index = -1;
		while (TRUE) {
			gint _tmp52_;
			gint _tmp53_;
			BalaParameter* param = NULL;
			BalaList* _tmp54_;
			gpointer _tmp55_;
			BalaParameter* _tmp57_;
			gboolean _tmp58_;
			gboolean _tmp59_;
			BalaParameter* _tmp61_;
			gboolean _tmp62_;
			gboolean _tmp63_;
			BalaParameter* _tmp65_;
			BalaParameterDirection _tmp66_;
			BalaParameterDirection _tmp67_;
			GString* _tmp92_;
			BalaParameter* _tmp93_;
			BalaDataType* _tmp94_;
			BalaDataType* _tmp95_;
			gchar* _tmp96_;
			gchar* _tmp97_;
			BalaParameter* _tmp98_;
			BalaExpression* _tmp99_;
			BalaExpression* _tmp100_;
			gint _tmp108_;
			_param_index = _param_index + 1;
			_tmp52_ = _param_index;
			_tmp53_ = _param_size;
			if (!(_tmp52_ < _tmp53_)) {
				break;
			}
			_tmp54_ = _param_list;
			_tmp55_ = bala_list_get (_tmp54_, _param_index);
			param = (BalaParameter*) _tmp55_;
			if (i > 1) {
				GString* _tmp56_;
				_tmp56_ = builder;
				g_string_append (_tmp56_, ", ");
			}
			_tmp57_ = param;
			_tmp58_ = bala_parameter_get_ellipsis (_tmp57_);
			_tmp59_ = _tmp58_;
			if (_tmp59_) {
				GString* _tmp60_;
				_tmp60_ = builder;
				g_string_append (_tmp60_, "...");
				_bala_code_node_unref0 (param);
				continue;
			}
			_tmp61_ = param;
			_tmp62_ = bala_parameter_get_params_array (_tmp61_);
			_tmp63_ = _tmp62_;
			if (_tmp63_) {
				GString* _tmp64_;
				_tmp64_ = builder;
				g_string_append (_tmp64_, "params ");
			}
			_tmp65_ = param;
			_tmp66_ = bala_parameter_get_direction (_tmp65_);
			_tmp67_ = _tmp66_;
			if (_tmp67_ == BALA_PARAMETER_DIRECTION_IN) {
				BalaParameter* _tmp68_;
				BalaDataType* _tmp69_;
				BalaDataType* _tmp70_;
				gboolean _tmp71_;
				gboolean _tmp72_;
				_tmp68_ = param;
				_tmp69_ = bala_variable_get_variable_type ((BalaVariable*) _tmp68_);
				_tmp70_ = _tmp69_;
				_tmp71_ = bala_data_type_get_value_owned (_tmp70_);
				_tmp72_ = _tmp71_;
				if (_tmp72_) {
					GString* _tmp73_;
					_tmp73_ = builder;
					g_string_append (_tmp73_, "owned ");
				}
			} else {
				BalaParameter* _tmp74_;
				BalaParameterDirection _tmp75_;
				BalaParameterDirection _tmp76_;
				gboolean _tmp82_ = FALSE;
				BalaParameter* _tmp83_;
				BalaDataType* _tmp84_;
				BalaDataType* _tmp85_;
				gboolean _tmp86_;
				gboolean _tmp87_;
				_tmp74_ = param;
				_tmp75_ = bala_parameter_get_direction (_tmp74_);
				_tmp76_ = _tmp75_;
				if (_tmp76_ == BALA_PARAMETER_DIRECTION_REF) {
					GString* _tmp77_;
					_tmp77_ = builder;
					g_string_append (_tmp77_, "ref ");
				} else {
					BalaParameter* _tmp78_;
					BalaParameterDirection _tmp79_;
					BalaParameterDirection _tmp80_;
					_tmp78_ = param;
					_tmp79_ = bala_parameter_get_direction (_tmp78_);
					_tmp80_ = _tmp79_;
					if (_tmp80_ == BALA_PARAMETER_DIRECTION_OUT) {
						GString* _tmp81_;
						_tmp81_ = builder;
						g_string_append (_tmp81_, "out ");
					}
				}
				_tmp83_ = param;
				_tmp84_ = bala_variable_get_variable_type ((BalaVariable*) _tmp83_);
				_tmp85_ = _tmp84_;
				_tmp86_ = bala_data_type_get_value_owned (_tmp85_);
				_tmp87_ = _tmp86_;
				if (!_tmp87_) {
					BalaParameter* _tmp88_;
					BalaDataType* _tmp89_;
					BalaDataType* _tmp90_;
					_tmp88_ = param;
					_tmp89_ = bala_variable_get_variable_type ((BalaVariable*) _tmp88_);
					_tmp90_ = _tmp89_;
					_tmp82_ = BALA_IS_REFERENCE_TYPE (_tmp90_);
				} else {
					_tmp82_ = FALSE;
				}
				if (_tmp82_) {
					GString* _tmp91_;
					_tmp91_ = builder;
					g_string_append (_tmp91_, "weak ");
				}
			}
			_tmp92_ = builder;
			_tmp93_ = param;
			_tmp94_ = bala_variable_get_variable_type ((BalaVariable*) _tmp93_);
			_tmp95_ = _tmp94_;
			_tmp96_ = bala_data_type_to_qualified_string (_tmp95_, NULL);
			_tmp97_ = _tmp96_;
			g_string_append (_tmp92_, _tmp97_);
			_g_free0 (_tmp97_);
			_tmp98_ = param;
			_tmp99_ = bala_variable_get_initializer ((BalaVariable*) _tmp98_);
			_tmp100_ = _tmp99_;
			if (_tmp100_ != NULL) {
				GString* _tmp101_;
				GString* _tmp102_;
				BalaParameter* _tmp103_;
				BalaExpression* _tmp104_;
				BalaExpression* _tmp105_;
				gchar* _tmp106_;
				gchar* _tmp107_;
				_tmp101_ = builder;
				g_string_append (_tmp101_, " = ");
				_tmp102_ = builder;
				_tmp103_ = param;
				_tmp104_ = bala_variable_get_initializer ((BalaVariable*) _tmp103_);
				_tmp105_ = _tmp104_;
				_tmp106_ = bala_code_node_to_string ((BalaCodeNode*) _tmp105_);
				_tmp107_ = _tmp106_;
				g_string_append (_tmp102_, _tmp107_);
				_g_free0 (_tmp107_);
			}
			_tmp108_ = i;
			i = _tmp108_ + 1;
			_bala_code_node_unref0 (param);
		}
		_bala_iterable_unref0 (_param_list);
	}
	_tmp109_ = builder;
	g_string_append_c (_tmp109_, ')');
	_tmp110_ = g_direct_equal;
	_tmp111_ = bala_array_list_new (BALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) bala_code_node_ref, (GDestroyNotify) bala_code_node_unref, _tmp110_);
	error_types = _tmp111_;
	_tmp112_ = error_types;
	bala_code_node_get_error_types ((BalaCodeNode*) self, (BalaCollection*) _tmp112_, NULL);
	_tmp113_ = error_types;
	_tmp114_ = bala_collection_get_size ((BalaCollection*) _tmp113_);
	_tmp115_ = _tmp114_;
	if (_tmp115_ > 0) {
		GString* _tmp116_;
		gboolean first = FALSE;
		_tmp116_ = builder;
		g_string_append (_tmp116_, " throws ");
		first = TRUE;
		{
			BalaArrayList* _type_list = NULL;
			BalaArrayList* _tmp117_;
			BalaArrayList* _tmp118_;
			gint _type_size = 0;
			BalaArrayList* _tmp119_;
			gint _tmp120_;
			gint _tmp121_;
			gint _type_index = 0;
			_tmp117_ = error_types;
			_tmp118_ = _bala_iterable_ref0 (_tmp117_);
			_type_list = _tmp118_;
			_tmp119_ = _type_list;
			_tmp120_ = bala_collection_get_size ((BalaCollection*) _tmp119_);
			_tmp121_ = _tmp120_;
			_type_size = _tmp121_;
			_type_index = -1;
			while (TRUE) {
				gint _tmp122_;
				gint _tmp123_;
				BalaDataType* type = NULL;
				BalaArrayList* _tmp124_;
				gpointer _tmp125_;
				GString* _tmp127_;
				BalaDataType* _tmp128_;
				gchar* _tmp129_;
				gchar* _tmp130_;
				_type_index = _type_index + 1;
				_tmp122_ = _type_index;
				_tmp123_ = _type_size;
				if (!(_tmp122_ < _tmp123_)) {
					break;
				}
				_tmp124_ = _type_list;
				_tmp125_ = bala_list_get ((BalaList*) _tmp124_, _type_index);
				type = (BalaDataType*) _tmp125_;
				if (!first) {
					GString* _tmp126_;
					_tmp126_ = builder;
					g_string_append (_tmp126_, ", ");
				} else {
					first = FALSE;
				}
				_tmp127_ = builder;
				_tmp128_ = type;
				_tmp129_ = bala_code_node_to_string ((BalaCodeNode*) _tmp128_);
				_tmp130_ = _tmp129_;
				g_string_append (_tmp127_, _tmp130_);
				_g_free0 (_tmp130_);
				_bala_code_node_unref0 (type);
			}
			_bala_iterable_unref0 (_type_list);
		}
	}
	_tmp131_ = builder;
	_tmp132_ = _tmp131_->str;
	_tmp133_ = g_strdup (_tmp132_);
	result = _tmp133_;
	_bala_iterable_unref0 (error_types);
	_g_free0 (_tmp23_);
	_g_string_free0 (builder);
	return result;
}

static void
bala_callable_type_class_init (BalaCallableTypeClass * klass,
                               gpointer klass_data)
{
	bala_callable_type_parent_class = g_type_class_peek_parent (klass);
	((BalaDataTypeClass *) klass)->is_invokable = (gboolean (*) (BalaDataType*)) bala_callable_type_real_is_invokable;
	((BalaDataTypeClass *) klass)->get_return_type = (BalaDataType* (*) (BalaDataType*)) bala_callable_type_real_get_return_type;
	((BalaDataTypeClass *) klass)->get_parameters = (BalaList* (*) (BalaDataType*)) bala_callable_type_real_get_parameters;
	((BalaDataTypeClass *) klass)->to_prototype_string = (gchar* (*) (BalaDataType*, const gchar*)) bala_callable_type_real_to_prototype_string;
}

static void
bala_callable_type_instance_init (BalaCallableType * self,
                                  gpointer klass)
{
}

/**
 * A callable type, i.e. a delegate, method, or signal type.
 */
static GType
bala_callable_type_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (BalaCallableTypeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bala_callable_type_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BalaCallableType), 0, (GInstanceInitFunc) bala_callable_type_instance_init, NULL };
	GType bala_callable_type_type_id;
	bala_callable_type_type_id = g_type_register_static (BALA_TYPE_DATA_TYPE, "BalaCallableType", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
	return bala_callable_type_type_id;
}

GType
bala_callable_type_get_type (void)
{
	static volatile gsize bala_callable_type_type_id__volatile = 0;
	if (g_once_init_enter (&bala_callable_type_type_id__volatile)) {
		GType bala_callable_type_type_id;
		bala_callable_type_type_id = bala_callable_type_get_type_once ();
		g_once_init_leave (&bala_callable_type_type_id__volatile, bala_callable_type_type_id);
	}
	return bala_callable_type_type_id__volatile;
}

