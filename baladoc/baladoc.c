/* baladoc.c generated by balac, the Bala compiler
 * generated from baladoc.bala, do not modify */

/* baladoc.bala
 *
 * Copyright (C) 2008-2014 Florian Brosch
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Florian Brosch <flo.brosch@gmail.com>
 */

#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <stdio.h>
#include <baladoc.h>
#include <bala.h>
#include <balacodegen.h>
#include <locale.h>
#include <glib/gstdio.h>

#define TYPE_BALA_DOC (bala_doc_get_type ())
#define BALA_DOC(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BALA_DOC, BalaDoc))
#define BALA_DOC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BALA_DOC, BalaDocClass))
#define IS_BALA_DOC(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BALA_DOC))
#define IS_BALA_DOC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BALA_DOC))
#define BALA_DOC_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BALA_DOC, BalaDocClass))

typedef struct _BalaDoc BalaDoc;
typedef struct _BalaDocClass BalaDocClass;
typedef struct _BalaDocPrivate BalaDocPrivate;
enum  {
	BALA_DOC_0_PROPERTY,
	BALA_DOC_NUM_PROPERTIES
};
static GParamSpec* bala_doc_properties[BALA_DOC_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _bala_code_context_unref0(var) ((var == NULL) ? NULL : (var = (bala_code_context_unref (var), NULL)))

#define BALADOC_TYPE_TREE_BUILDER (baladoc_tree_builder_get_type ())
#define BALADOC_TREE_BUILDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BALADOC_TYPE_TREE_BUILDER, BaladocTreeBuilder))
#define BALADOC_TREE_BUILDER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BALADOC_TYPE_TREE_BUILDER, BaladocTreeBuilderClass))
#define BALADOC_IS_TREE_BUILDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BALADOC_TYPE_TREE_BUILDER))
#define BALADOC_IS_TREE_BUILDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BALADOC_TYPE_TREE_BUILDER))
#define BALADOC_TREE_BUILDER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BALADOC_TYPE_TREE_BUILDER, BaladocTreeBuilderClass))

typedef struct _BaladocTreeBuilder BaladocTreeBuilder;
typedef struct _BaladocTreeBuilderClass BaladocTreeBuilderClass;
#define _baladoc_api_tree_unref0(var) ((var == NULL) ? NULL : (var = (baladoc_api_tree_unref (var), NULL)))
#define _bala_code_visitor_unref0(var) ((var == NULL) ? NULL : (var = (bala_code_visitor_unref (var), NULL)))

#define BALADOC_TYPE_SYMBOL_RESOLVER (baladoc_symbol_resolver_get_type ())
#define BALADOC_SYMBOL_RESOLVER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BALADOC_TYPE_SYMBOL_RESOLVER, BaladocSymbolResolver))
#define BALADOC_SYMBOL_RESOLVER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BALADOC_TYPE_SYMBOL_RESOLVER, BaladocSymbolResolverClass))
#define BALADOC_IS_SYMBOL_RESOLVER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BALADOC_TYPE_SYMBOL_RESOLVER))
#define BALADOC_IS_SYMBOL_RESOLVER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BALADOC_TYPE_SYMBOL_RESOLVER))
#define BALADOC_SYMBOL_RESOLVER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BALADOC_TYPE_SYMBOL_RESOLVER, BaladocSymbolResolverClass))

typedef struct _BaladocSymbolResolver BaladocSymbolResolver;
typedef struct _BaladocSymbolResolverClass BaladocSymbolResolverClass;

#define BALADOC_TYPE_GIR_WRITER (baladoc_gir_writer_get_type ())
#define BALADOC_GIR_WRITER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), BALADOC_TYPE_GIR_WRITER, BaladocGirWriter))
#define BALADOC_GIR_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), BALADOC_TYPE_GIR_WRITER, BaladocGirWriterClass))
#define BALADOC_IS_GIR_WRITER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), BALADOC_TYPE_GIR_WRITER))
#define BALADOC_IS_GIR_WRITER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BALADOC_TYPE_GIR_WRITER))
#define BALADOC_GIR_WRITER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), BALADOC_TYPE_GIR_WRITER, BaladocGirWriterClass))

typedef struct _BaladocGirWriter BaladocGirWriter;
typedef struct _BaladocGirWriterClass BaladocGirWriterClass;
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _BalaDoc {
	GObject parent_instance;
	BalaDocPrivate * priv;
};

struct _BalaDocClass {
	GObjectClass parent_class;
};

static gpointer bala_doc_parent_class = NULL;
static gchar* bala_doc_directory;
static gchar* bala_doc_basedir;
static gchar** bala_doc_defines;
static gchar* bala_doc_profile;
static gboolean bala_doc_experimental;
static gboolean bala_doc_experimental_non_null;
static gchar** bala_doc_metadata_directories;
static gchar** bala_doc_gir_directories;
static gchar** bala_doc_bapi_directories;
static gchar** bala_doc_packages;
static gchar** bala_doc_import_directories;
static gchar** bala_doc_import_packages;
static gchar** bala_doc_alternative_resource_dirs;
static gchar* bala_doc_wikidirectory;
static gboolean bala_doc_with_deps;
static gchar* bala_doc_docletpath;
static gchar** bala_doc_pluginargs;
static gboolean bala_doc__protected;
static gboolean bala_doc__internal;
static gboolean bala_doc__private;
static gboolean bala_doc_use_svg_images;
static gchar* bala_doc_pkg_name;
static gchar* bala_doc_pkg_version;
static gchar* bala_doc_gir_name;
static gboolean bala_doc_version;
static gboolean bala_doc_force;
static gboolean bala_doc_fatal_warnings;
static gboolean bala_doc_verbose;
static gboolean bala_doc_disable_diagnostic_colors;
static gchar* bala_doc_target_glib;
static gchar** bala_doc_tsources;
static gchar* bala_doc_wikidirectory = NULL;
static gchar* bala_doc_pkg_version = NULL;
static gchar* bala_doc_docletpath = NULL;
static gchar** bala_doc_pluginargs = NULL;
static gchar* bala_doc_directory = NULL;
static gchar* bala_doc_pkg_name = NULL;
static gchar* bala_doc_gir_name = NULL;
static gchar* bala_doc_gir_namespace;
static gchar* bala_doc_gir_namespace = NULL;
static gchar* bala_doc_gir_version;
static gchar* bala_doc_gir_version = NULL;
static gboolean bala_doc_add_inherited;
static gboolean bala_doc_add_inherited = FALSE;
static gboolean bala_doc__protected = TRUE;
static gboolean bala_doc__internal = FALSE;
static gboolean bala_doc_with_deps = FALSE;
static gboolean bala_doc__private = FALSE;
static gboolean bala_doc_version = FALSE;
static gboolean bala_doc_use_svg_images = FALSE;
static gboolean bala_doc_disable_diagnostic_colors = FALSE;
static gboolean bala_doc_verbose = FALSE;
static gboolean bala_doc_force = FALSE;
static gboolean bala_doc_fatal_warnings = FALSE;
static gchar* bala_doc_basedir = NULL;
static gchar** bala_doc_defines = NULL;
static gboolean bala_doc_experimental = FALSE;
static gboolean bala_doc_experimental_non_null = FALSE;
static gchar* bala_doc_profile = NULL;
static gchar** bala_doc_import_packages = NULL;
static gchar** bala_doc_import_directories = NULL;
static gchar** bala_doc_bapi_directories = NULL;
static gchar** bala_doc_metadata_directories = NULL;
static gchar** bala_doc_gir_directories = NULL;
static gchar** bala_doc_tsources = NULL;
static gchar** bala_doc_packages = NULL;
static gchar** bala_doc_alternative_resource_dirs = NULL;
static gchar* bala_doc_target_glib = NULL;

GType bala_doc_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (BalaDoc, g_object_unref)
#define BALA_DOC_DEFAULT_COLORS "error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01"
static gboolean bala_doc_option_deprecated (const gchar* option_name,
                                     const gchar* val,
                                     void* data,
                                     GError** error);
static gint bala_doc_quit (BaladocErrorReporter* reporter,
                    gboolean pop_context);
static gboolean bala_doc_check_pkg_name (void);
static gchar* bala_doc_get_pkg_name (BalaDoc* self);
static BaladocModuleLoader* bala_doc_create_module_loader (BalaDoc* self,
                                                    BaladocErrorReporter* reporter,
                                                    BaladocDoclet* * doclet);
static gint bala_doc_run (BalaDoc* self,
                   BaladocErrorReporter* reporter);
static gchar** _bala_array_dup1 (gchar** self,
                          gint length);
static gchar** _bala_array_dup2 (gchar** self,
                          gint length);
static gchar** _bala_array_dup3 (gchar** self,
                          gint length);
static gchar** _bala_array_dup4 (gchar** self,
                          gint length);
static gchar** _bala_array_dup5 (gchar** self,
                          gint length);
static gchar** _bala_array_dup6 (gchar** self,
                          gint length);
static gchar** _bala_array_dup7 (gchar** self,
                          gint length);
static gchar** _bala_array_dup8 (gchar** self,
                          gint length);
GType baladoc_tree_builder_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (BaladocTreeBuilder, bala_code_visitor_unref)
BaladocTreeBuilder* baladoc_tree_builder_new (void);
BaladocTreeBuilder* baladoc_tree_builder_construct (GType object_type);
BaladocApiTree* baladoc_tree_builder_build (BaladocTreeBuilder* self,
                                            BaladocSettings* settings,
                                            BaladocErrorReporter* reporter);
GType baladoc_symbol_resolver_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (BaladocSymbolResolver, g_object_unref)
BaladocSymbolResolver* baladoc_symbol_resolver_new (BaladocTreeBuilder* builder);
BaladocSymbolResolver* baladoc_symbol_resolver_construct (GType object_type,
                                                          BaladocTreeBuilder* builder);
GType baladoc_gir_writer_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (BaladocGirWriter, bala_code_visitor_unref)
BaladocGirWriter* baladoc_gir_writer_new (BaladocSymbolResolver* resolver);
BaladocGirWriter* baladoc_gir_writer_construct (GType object_type,
                                                BaladocSymbolResolver* resolver);
static gint bala_doc_main (gchar** args,
                    gint args_length1);
BalaDoc* bala_doc_new (void);
BalaDoc* bala_doc_construct (GType object_type);
static void bala_doc_finalize (GObject * obj);
static GType bala_doc_get_type_once (void);
static void _bala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _bala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);
static gint _bala_array_length (gpointer array);

static const GOptionEntry BALA_DOC_options[33] = {{"directory", 'o', 0, G_OPTION_ARG_FILENAME, &bala_doc_directory, "Output directory", "DIRECTORY"}, {"basedir", 'b', 0, G_OPTION_ARG_FILENAME, &bala_doc_basedir, "Base source directory", "DIRECTORY"}, {"define", 'D', 0, G_OPTION_ARG_STRING_ARRAY, &bala_doc_defines, "Define SYMBOL", "SYMBOL..."}, {"profile", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_doc_profile, "Use the given profile instead of the default", "PROFILE"}, {"enable-experimental", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_doc_experimental, "Enable experimental features", NULL}, {"enable-experimental-non-null", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_doc_experimental_non_null, "Enable experimental enhancements for non-null types", NULL}, {"metadatadir", (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &bala_doc_metadata_directories, "Look for GIR .metadata files in DIRECTORY", "DIRECTORY..."}, {"girdir", (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &bala_doc_gir_directories, "Look for .gir files in DIRECTORY", "DIRECTORY..."}, {"bapidir", (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &bala_doc_bapi_directories, "Look for package bindings in DIRECTORY", "DIRECTORY..."}, {"pkg", (gchar) 0, 0, G_OPTION_ARG_STRING_ARRAY, &bala_doc_packages, "Include binding for PACKAGE", "PACKAGE..."}, {"driver", (gchar) 0, (gint) G_OPTION_FLAG_OPTIONAL_ARG, G_OPTION_ARG_CALLBACK, (void*) bala_doc_option_deprecated, "Name of an driver or path to a custom driver (DEPRECATED AND IGNORED)", NULL}, {"importdir", (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &bala_doc_import_directories, "Look for external documentation in DIRECTORY", "DIRECTORY..."}, {"import", (gchar) 0, 0, G_OPTION_ARG_STRING_ARRAY, &bala_doc_import_packages, "Include binding for PACKAGE", "PACKAGE..."}, {"alternative-resource-dir", (gchar) 0, 0, G_OPTION_ARG_STRING_ARRAY, &bala_doc_alternative_resource_dirs, "Alternative resource directories", "DIRECTORY..."}, {"wiki", (gchar) 0, 0, G_OPTION_ARG_FILENAME, &bala_doc_wikidirectory, "Wiki directory", "DIRECTORY"}, {"deps", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_doc_with_deps, "Adds packages to the documentation", NULL}, {"doclet", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_doc_docletpath, "Name of an included doclet or path to custom doclet", "PLUGIN"}, {"doclet-arg", 'X', 0, G_OPTION_ARG_STRING_ARRAY, &bala_doc_pluginargs, "Pass arguments to the doclet", "ARG"}, {"no-protected", (gchar) 0, (gint) G_OPTION_FLAG_REVERSE, G_OPTION_ARG_NONE, &bala_doc__protected, "Removes protected elements from documentation", NULL}, {"internal", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_doc__internal, "Adds internal elements to documentation", NULL}, {"private", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_doc__private, "Adds private elements to documentation", NULL}, {"use-svg-images", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_doc_use_svg_images, "Generate SVG image charts instead of PNG", NULL}, {"package-name", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_doc_pkg_name, "package name", "NAME"}, {"package-version", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_doc_pkg_version, "package version", "VERSION"}, {"gir", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_doc_gir_name, "GObject-Introspection repository file name", "NAME-VERSION.gir"}, {"version", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_doc_version, "Display version number", NULL}, {"force", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_doc_force, "force", NULL}, {"fatal-warnings", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_doc_fatal_warnings, "Treat warnings as fatal", NULL}, {"verbose", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_doc_verbose, "Show all warnings", NULL}, {"no-color", (gchar) 0, 0, G_OPTION_ARG_NONE, &bala_doc_disable_diagnostic_colors, "Disable colored output", NULL}, {"target-glib", (gchar) 0, 0, G_OPTION_ARG_STRING, &bala_doc_target_glib, "Target version of glib for code generation", "'MAJOR.MINOR', or 'auto'"}, {G_OPTION_REMAINING, (gchar) 0, 0, G_OPTION_ARG_FILENAME_ARRAY, &bala_doc_tsources, NULL, "FILE..."}, {NULL}};

static gboolean
bala_doc_option_deprecated (const gchar* option_name,
                            const gchar* val,
                            void* data,
                            GError** error)
{
	FILE* _tmp0_;
	gboolean result = FALSE;
	g_return_val_if_fail (option_name != NULL, FALSE);
	_tmp0_ = stdout;
	fprintf (_tmp0_, "Command-line option `%s` is deprecated and will be ignored\n", option_name);
	result = TRUE;
	return result;
}

static gint
bala_doc_quit (BaladocErrorReporter* reporter,
               gboolean pop_context)
{
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	gint _tmp2_;
	gint result = 0;
	g_return_val_if_fail (reporter != NULL, 0);
	_tmp1_ = baladoc_error_reporter_get_errors (reporter);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == 0) {
		gboolean _tmp3_ = FALSE;
		if (!bala_doc_fatal_warnings) {
			_tmp3_ = TRUE;
		} else {
			gint _tmp4_;
			gint _tmp5_;
			_tmp4_ = baladoc_error_reporter_get_warnings (reporter);
			_tmp5_ = _tmp4_;
			_tmp3_ = _tmp5_ == 0;
		}
		_tmp0_ = _tmp3_;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		FILE* _tmp6_;
		gint _tmp7_;
		gint _tmp8_;
		_tmp6_ = stdout;
		_tmp7_ = baladoc_error_reporter_get_warnings (reporter);
		_tmp8_ = _tmp7_;
		fprintf (_tmp6_, "Succeeded - %d warning(s)\n", _tmp8_);
		if (pop_context) {
			bala_code_context_pop ();
		}
		result = 0;
		return result;
	} else {
		FILE* _tmp9_;
		gint _tmp10_;
		gint _tmp11_;
		gint _tmp12_;
		gint _tmp13_;
		_tmp9_ = stdout;
		_tmp10_ = baladoc_error_reporter_get_errors (reporter);
		_tmp11_ = _tmp10_;
		_tmp12_ = baladoc_error_reporter_get_warnings (reporter);
		_tmp13_ = _tmp12_;
		fprintf (_tmp9_, "Failed: %d error(s), %d warning(s)\n", _tmp11_, _tmp13_);
		if (pop_context) {
			bala_code_context_pop ();
		}
		result = 1;
		return result;
	}
}

static gboolean
bala_doc_check_pkg_name (void)
{
	const gchar* _tmp0_;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_;
	gchar** _tmp4_;
	gint _tmp4__length1;
	gboolean result = FALSE;
	_tmp0_ = bala_doc_pkg_name;
	if (_tmp0_ == NULL) {
		result = TRUE;
		return result;
	}
	_tmp2_ = bala_doc_pkg_name;
	if (g_strcmp0 (_tmp2_, "glib-2.0") == 0) {
		_tmp1_ = TRUE;
	} else {
		const gchar* _tmp3_;
		_tmp3_ = bala_doc_pkg_name;
		_tmp1_ = g_strcmp0 (_tmp3_, "gobject-2.0") == 0;
	}
	if (_tmp1_) {
		result = FALSE;
		return result;
	}
	_tmp4_ = bala_doc_tsources;
	_tmp4__length1 = _bala_array_length (bala_doc_tsources);
	{
		gchar** package_collection = NULL;
		gint package_collection_length1 = 0;
		gint _package_collection_size_ = 0;
		gint package_it = 0;
		package_collection = _tmp4_;
		package_collection_length1 = _tmp4__length1;
		for (package_it = 0; package_it < package_collection_length1; package_it = package_it + 1) {
			gchar* _tmp5_;
			gchar* package = NULL;
			_tmp5_ = g_strdup (package_collection[package_it]);
			package = _tmp5_;
			{
				const gchar* _tmp6_;
				const gchar* _tmp7_;
				_tmp6_ = bala_doc_pkg_name;
				_tmp7_ = package;
				if (g_strcmp0 (_tmp6_, _tmp7_) == 0) {
					result = FALSE;
					_g_free0 (package);
					return result;
				}
				_g_free0 (package);
			}
		}
	}
	result = TRUE;
	return result;
}

static gchar*
bala_doc_get_pkg_name (BalaDoc* self)
{
	const gchar* _tmp0_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = bala_doc_pkg_name;
	if (_tmp0_ == NULL) {
		const gchar* _tmp1_;
		_tmp1_ = bala_doc_directory;
		if (g_str_has_suffix (_tmp1_, "/")) {
			const gchar* _tmp2_;
			gchar* _tmp3_;
			_tmp2_ = bala_doc_directory;
			_tmp3_ = g_path_get_dirname (_tmp2_);
			_g_free0 (bala_doc_pkg_name);
			bala_doc_pkg_name = _tmp3_;
		} else {
			const gchar* _tmp4_;
			gchar* _tmp5_;
			_tmp4_ = bala_doc_directory;
			_tmp5_ = g_path_get_basename (_tmp4_);
			_g_free0 (bala_doc_pkg_name);
			bala_doc_pkg_name = _tmp5_;
		}
	}
	_tmp6_ = bala_doc_pkg_name;
	_tmp7_ = g_strdup (_tmp6_);
	result = _tmp7_;
	return result;
}

static BaladocModuleLoader*
bala_doc_create_module_loader (BalaDoc* self,
                               BaladocErrorReporter* reporter,
                               BaladocDoclet* * doclet)
{
	BaladocDoclet* _bala_doclet = NULL;
	BaladocModuleLoader* modules = NULL;
	BaladocModuleLoader* _tmp0_;
	gchar* pluginpath = NULL;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	BaladocModuleLoader* _tmp4_;
	const gchar* _tmp5_;
	BaladocDoclet* _tmp6_;
	BaladocDoclet* _tmp7_;
	BaladocModuleLoader* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (reporter != NULL, NULL);
	_tmp0_ = baladoc_module_loader_get_instance ();
	modules = _tmp0_;
	_g_object_unref0 (_bala_doclet);
	_bala_doclet = NULL;
	_tmp1_ = bala_doc_docletpath;
	_tmp2_ = baladoc_module_loader_get_doclet_path (_tmp1_, reporter);
	pluginpath = _tmp2_;
	_tmp3_ = pluginpath;
	if (_tmp3_ == NULL) {
		result = NULL;
		_g_free0 (pluginpath);
		_g_object_unref0 (modules);
		if (doclet) {
			*doclet = _bala_doclet;
		} else {
			_g_object_unref0 (_bala_doclet);
		}
		return result;
	}
	_tmp4_ = modules;
	_tmp5_ = pluginpath;
	_tmp6_ = baladoc_module_loader_create_doclet (_tmp4_, _tmp5_);
	_g_object_unref0 (_bala_doclet);
	_bala_doclet = _tmp6_;
	_tmp7_ = _bala_doclet;
	if (_tmp7_ == NULL) {
		baladoc_error_reporter_simple_error (reporter, NULL, "failed to load doclet");
		result = NULL;
		_g_free0 (pluginpath);
		_g_object_unref0 (modules);
		if (doclet) {
			*doclet = _bala_doclet;
		} else {
			_g_object_unref0 (_bala_doclet);
		}
		return result;
	}
	result = modules;
	_g_free0 (pluginpath);
	if (doclet) {
		*doclet = _bala_doclet;
	} else {
		_g_object_unref0 (_bala_doclet);
	}
	return result;
}

static gchar**
_bala_array_dup1 (gchar** self,
                  gint length)
{
	if (length >= 0) {
		gchar** result;
		gint i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

static gchar**
_bala_array_dup2 (gchar** self,
                  gint length)
{
	if (length >= 0) {
		gchar** result;
		gint i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

static gchar**
_bala_array_dup3 (gchar** self,
                  gint length)
{
	if (length >= 0) {
		gchar** result;
		gint i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

static gchar**
_bala_array_dup4 (gchar** self,
                  gint length)
{
	if (length >= 0) {
		gchar** result;
		gint i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

static gchar**
_bala_array_dup5 (gchar** self,
                  gint length)
{
	if (length >= 0) {
		gchar** result;
		gint i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

static gchar**
_bala_array_dup6 (gchar** self,
                  gint length)
{
	if (length >= 0) {
		gchar** result;
		gint i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

static gchar**
_bala_array_dup7 (gchar** self,
                  gint length)
{
	if (length >= 0) {
		gchar** result;
		gint i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

static gchar**
_bala_array_dup8 (gchar** self,
                  gint length)
{
	if (length >= 0) {
		gchar** result;
		gint i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

static gint
bala_doc_run (BalaDoc* self,
              BaladocErrorReporter* reporter)
{
	BaladocSettings* settings = NULL;
	BaladocSettings* _tmp0_;
	BaladocSettings* _tmp1_;
	BaladocSettings* _tmp2_;
	gchar* _tmp3_;
	BaladocSettings* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	BaladocSettings* _tmp7_;
	const gchar* _tmp8_;
	gchar* _tmp9_;
	const gchar* _tmp10_;
	BaladocSettings* _tmp22_;
	const gchar* _tmp23_;
	gchar* _tmp24_;
	BaladocSettings* _tmp25_;
	BaladocSettings* _tmp26_;
	BaladocSettings* _tmp27_;
	BaladocSettings* _tmp28_;
	BaladocSettings* _tmp29_;
	BaladocSettings* _tmp30_;
	const gchar* _tmp31_;
	gchar* _tmp32_;
	BaladocSettings* _tmp33_;
	BaladocSettings* _tmp34_;
	const gchar* _tmp35_;
	gchar* _tmp36_;
	BaladocSettings* _tmp37_;
	gchar** _tmp38_;
	gint _tmp38__length1;
	gchar** _tmp39_;
	gint _tmp39__length1;
	BaladocSettings* _tmp40_;
	BaladocSettings* _tmp41_;
	BaladocSettings* _tmp42_;
	const gchar* _tmp43_;
	gchar* _tmp44_;
	BaladocSettings* _tmp45_;
	const gchar* _tmp46_;
	gchar* _tmp47_;
	BaladocSettings* _tmp48_;
	gchar** _tmp49_;
	gint _tmp49__length1;
	gchar** _tmp50_;
	gint _tmp50__length1;
	BaladocSettings* _tmp51_;
	gchar** _tmp52_;
	gint _tmp52__length1;
	gchar** _tmp53_;
	gint _tmp53__length1;
	BaladocSettings* _tmp54_;
	gchar** _tmp55_;
	gint _tmp55__length1;
	gchar** _tmp56_;
	gint _tmp56__length1;
	BaladocSettings* _tmp57_;
	const gchar* _tmp58_;
	gchar* _tmp59_;
	BaladocSettings* _tmp60_;
	BaladocSettings* _tmp61_;
	gchar** _tmp62_;
	gint _tmp62__length1;
	gchar** _tmp63_;
	gint _tmp63__length1;
	BaladocSettings* _tmp64_;
	gchar** _tmp65_;
	gint _tmp65__length1;
	gchar** _tmp66_;
	gint _tmp66__length1;
	BaladocSettings* _tmp67_;
	const gchar* _tmp68_;
	gchar* _tmp69_;
	BaladocSettings* _tmp70_;
	gchar** _tmp71_;
	gint _tmp71__length1;
	gchar** _tmp72_;
	gint _tmp72__length1;
	BaladocSettings* _tmp73_;
	gchar** _tmp74_;
	gint _tmp74__length1;
	gchar** _tmp75_;
	gint _tmp75__length1;
	BalaCodeContext* context = NULL;
	BalaCodeContext* _tmp76_;
	BalaCodeContext* _tmp77_;
	BaladocDoclet* doclet = NULL;
	BaladocModuleLoader* modules = NULL;
	BaladocDoclet* _tmp78_ = NULL;
	BaladocModuleLoader* _tmp79_;
	gboolean _tmp80_ = FALSE;
	gint _tmp81_;
	gint _tmp82_;
	BaladocTreeBuilder* builder = NULL;
	BaladocTreeBuilder* _tmp84_;
	BaladocApiTree* doctree = NULL;
	BaladocTreeBuilder* _tmp85_;
	BaladocSettings* _tmp86_;
	BaladocApiTree* _tmp87_;
	gint _tmp88_;
	gint _tmp89_;
	BaladocSymbolResolver* resolver = NULL;
	BaladocTreeBuilder* _tmp90_;
	BaladocSymbolResolver* _tmp91_;
	BaladocApiTree* _tmp92_;
	BaladocSymbolResolver* _tmp93_;
	BaladocApiChildSymbolRegistrar* registrar = NULL;
	BaladocApiChildSymbolRegistrar* _tmp94_;
	BaladocApiTree* _tmp95_;
	BaladocApiChildSymbolRegistrar* _tmp96_;
	BaladocDocumentationParser* docparser = NULL;
	BaladocSettings* _tmp97_;
	BaladocApiTree* _tmp98_;
	BaladocModuleLoader* _tmp99_;
	BaladocDocumentationParser* _tmp100_;
	BaladocApiTree* _tmp101_;
	BaladocImporterDocumentationImporter** importers = NULL;
	BaladocApiTree* _tmp102_;
	BaladocDocumentationParser* _tmp103_;
	BaladocModuleLoader* _tmp104_;
	BaladocSettings* _tmp105_;
	BaladocImporterBaladocDocumentationImporter* _tmp106_;
	BaladocApiTree* _tmp107_;
	BaladocDocumentationParser* _tmp108_;
	BaladocModuleLoader* _tmp109_;
	BaladocSettings* _tmp110_;
	BaladocImporterGirDocumentationImporter* _tmp111_;
	BaladocImporterDocumentationImporter** _tmp112_;
	gint importers_length1;
	gint _importers_size_;
	BaladocApiTree* _tmp113_;
	BaladocDocumentationParser* _tmp114_;
	gint _tmp115_;
	gint _tmp116_;
	BaladocApiTree* _tmp117_;
	BaladocImporterDocumentationImporter** _tmp118_;
	gint _tmp118__length1;
	gchar** _tmp119_;
	gint _tmp119__length1;
	gchar** _tmp120_;
	gint _tmp120__length1;
	gint _tmp121_;
	gint _tmp122_;
	BaladocApiTree* _tmp123_;
	BaladocDocumentationParser* _tmp124_;
	gint _tmp125_;
	gint _tmp126_;
	const gchar* _tmp127_;
	BaladocDoclet* _tmp150_;
	BaladocSettings* _tmp151_;
	BaladocApiTree* _tmp152_;
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (reporter != NULL, 0);
	_tmp0_ = baladoc_settings_new ();
	settings = _tmp0_;
	_tmp1_ = settings;
	baladoc_error_reporter_set_settings (reporter, _tmp1_);
	_tmp2_ = settings;
	_tmp3_ = bala_doc_get_pkg_name (self);
	_g_free0 (_tmp2_->pkg_name);
	_tmp2_->pkg_name = _tmp3_;
	_tmp4_ = settings;
	_tmp5_ = bala_doc_gir_namespace;
	_tmp6_ = g_strdup (_tmp5_);
	_g_free0 (_tmp4_->gir_namespace);
	_tmp4_->gir_namespace = _tmp6_;
	_tmp7_ = settings;
	_tmp8_ = bala_doc_gir_version;
	_tmp9_ = g_strdup (_tmp8_);
	_g_free0 (_tmp7_->gir_version);
	_tmp7_->gir_version = _tmp9_;
	_tmp10_ = bala_doc_gir_name;
	if (_tmp10_ != NULL) {
		BaladocSettings* _tmp11_;
		const gchar* _tmp12_;
		gchar* _tmp13_;
		BaladocSettings* _tmp14_;
		const gchar* _tmp15_;
		gchar* _tmp16_;
		BaladocSettings* _tmp17_;
		const gchar* _tmp18_;
		_tmp11_ = settings;
		_tmp12_ = bala_doc_gir_name;
		_tmp13_ = g_path_get_basename (_tmp12_);
		_g_free0 (_tmp11_->gir_name);
		_tmp11_->gir_name = _tmp13_;
		_tmp14_ = settings;
		_tmp15_ = bala_doc_gir_name;
		_tmp16_ = g_path_get_dirname (_tmp15_);
		_g_free0 (_tmp14_->gir_directory);
		_tmp14_->gir_directory = _tmp16_;
		_tmp17_ = settings;
		_tmp18_ = _tmp17_->gir_directory;
		if (g_strcmp0 (_tmp18_, "") == 0) {
			BaladocSettings* _tmp19_;
			const gchar* _tmp20_;
			gchar* _tmp21_;
			_tmp19_ = settings;
			_tmp20_ = bala_doc_directory;
			_tmp21_ = g_path_get_dirname (_tmp20_);
			_g_free0 (_tmp19_->gir_directory);
			_tmp19_->gir_directory = _tmp21_;
		}
	}
	_tmp22_ = settings;
	_tmp23_ = bala_doc_pkg_version;
	_tmp24_ = g_strdup (_tmp23_);
	_g_free0 (_tmp22_->pkg_version);
	_tmp22_->pkg_version = _tmp24_;
	_tmp25_ = settings;
	_tmp25_->add_inherited = bala_doc_add_inherited;
	_tmp26_ = settings;
	_tmp26_->_protected = bala_doc__protected;
	_tmp27_ = settings;
	_tmp27_->_internal = bala_doc__internal;
	_tmp28_ = settings;
	_tmp28_->with_deps = bala_doc_with_deps;
	_tmp29_ = settings;
	_tmp29_->_private = bala_doc__private;
	_tmp30_ = settings;
	_tmp31_ = bala_doc_directory;
	_tmp32_ = bala_code_context_realpath (_tmp31_);
	_g_free0 (_tmp30_->path);
	_tmp30_->path = _tmp32_;
	_tmp33_ = settings;
	_tmp33_->verbose = bala_doc_verbose;
	_tmp34_ = settings;
	_tmp35_ = bala_doc_wikidirectory;
	_tmp36_ = g_strdup (_tmp35_);
	_g_free0 (_tmp34_->wiki_directory);
	_tmp34_->wiki_directory = _tmp36_;
	_tmp37_ = settings;
	_tmp38_ = bala_doc_pluginargs;
	_tmp38__length1 = _bala_array_length (bala_doc_pluginargs);
	_tmp39_ = (_tmp38_ != NULL) ? _bala_array_dup1 (_tmp38_, _tmp38__length1) : ((gpointer) _tmp38_);
	_tmp39__length1 = _tmp38__length1;
	_tmp37_->pluginargs = (_bala_array_free (_tmp37_->pluginargs, _tmp37_->pluginargs_length1, (GDestroyNotify) g_free), NULL);
	_tmp37_->pluginargs = _tmp39_;
	_tmp37_->pluginargs_length1 = _tmp39__length1;
	_tmp40_ = settings;
	_tmp40_->experimental = bala_doc_experimental;
	_tmp41_ = settings;
	_tmp41_->experimental_non_null = bala_doc_experimental_non_null;
	_tmp42_ = settings;
	_tmp43_ = bala_doc_basedir;
	_tmp44_ = g_strdup (_tmp43_);
	_g_free0 (_tmp42_->basedir);
	_tmp42_->basedir = _tmp44_;
	_tmp45_ = settings;
	_tmp46_ = bala_doc_directory;
	_tmp47_ = g_strdup (_tmp46_);
	_g_free0 (_tmp45_->directory);
	_tmp45_->directory = _tmp47_;
	_tmp48_ = settings;
	_tmp49_ = bala_doc_bapi_directories;
	_tmp49__length1 = _bala_array_length (bala_doc_bapi_directories);
	_tmp50_ = (_tmp49_ != NULL) ? _bala_array_dup2 (_tmp49_, _tmp49__length1) : ((gpointer) _tmp49_);
	_tmp50__length1 = _tmp49__length1;
	_tmp48_->bapi_directories = (_bala_array_free (_tmp48_->bapi_directories, _tmp48_->bapi_directories_length1, (GDestroyNotify) g_free), NULL);
	_tmp48_->bapi_directories = _tmp50_;
	_tmp48_->bapi_directories_length1 = _tmp50__length1;
	_tmp51_ = settings;
	_tmp52_ = bala_doc_metadata_directories;
	_tmp52__length1 = _bala_array_length (bala_doc_metadata_directories);
	_tmp53_ = (_tmp52_ != NULL) ? _bala_array_dup3 (_tmp52_, _tmp52__length1) : ((gpointer) _tmp52_);
	_tmp53__length1 = _tmp52__length1;
	_tmp51_->metadata_directories = (_bala_array_free (_tmp51_->metadata_directories, _tmp51_->metadata_directories_length1, (GDestroyNotify) g_free), NULL);
	_tmp51_->metadata_directories = _tmp53_;
	_tmp51_->metadata_directories_length1 = _tmp53__length1;
	_tmp54_ = settings;
	_tmp55_ = bala_doc_gir_directories;
	_tmp55__length1 = _bala_array_length (bala_doc_gir_directories);
	_tmp56_ = (_tmp55_ != NULL) ? _bala_array_dup4 (_tmp55_, _tmp55__length1) : ((gpointer) _tmp55_);
	_tmp56__length1 = _tmp55__length1;
	_tmp54_->gir_directories = (_bala_array_free (_tmp54_->gir_directories, _tmp54_->gir_directories_length1, (GDestroyNotify) g_free), NULL);
	_tmp54_->gir_directories = _tmp56_;
	_tmp54_->gir_directories_length1 = _tmp56__length1;
	_tmp57_ = settings;
	_tmp58_ = bala_doc_target_glib;
	_tmp59_ = g_strdup (_tmp58_);
	_g_free0 (_tmp57_->target_glib);
	_tmp57_->target_glib = _tmp59_;
	_tmp60_ = settings;
	_tmp60_->use_svg_images = bala_doc_use_svg_images;
	_tmp61_ = settings;
	_tmp62_ = bala_doc_tsources;
	_tmp62__length1 = _bala_array_length (bala_doc_tsources);
	_tmp63_ = (_tmp62_ != NULL) ? _bala_array_dup5 (_tmp62_, _tmp62__length1) : ((gpointer) _tmp62_);
	_tmp63__length1 = _tmp62__length1;
	_tmp61_->source_files = (_bala_array_free (_tmp61_->source_files, _tmp61_->source_files_length1, (GDestroyNotify) g_free), NULL);
	_tmp61_->source_files = _tmp63_;
	_tmp61_->source_files_length1 = _tmp63__length1;
	_tmp64_ = settings;
	_tmp65_ = bala_doc_packages;
	_tmp65__length1 = _bala_array_length (bala_doc_packages);
	_tmp66_ = (_tmp65_ != NULL) ? _bala_array_dup6 (_tmp65_, _tmp65__length1) : ((gpointer) _tmp65_);
	_tmp66__length1 = _tmp65__length1;
	_tmp64_->packages = (_bala_array_free (_tmp64_->packages, _tmp64_->packages_length1, (GDestroyNotify) g_free), NULL);
	_tmp64_->packages = _tmp66_;
	_tmp64_->packages_length1 = _tmp66__length1;
	_tmp67_ = settings;
	_tmp68_ = bala_doc_profile;
	_tmp69_ = g_strdup (_tmp68_);
	_g_free0 (_tmp67_->profile);
	_tmp67_->profile = _tmp69_;
	_tmp70_ = settings;
	_tmp71_ = bala_doc_defines;
	_tmp71__length1 = _bala_array_length (bala_doc_defines);
	_tmp72_ = (_tmp71_ != NULL) ? _bala_array_dup7 (_tmp71_, _tmp71__length1) : ((gpointer) _tmp71_);
	_tmp72__length1 = _tmp71__length1;
	_tmp70_->defines = (_bala_array_free (_tmp70_->defines, _tmp70_->defines_length1, (GDestroyNotify) g_free), NULL);
	_tmp70_->defines = _tmp72_;
	_tmp70_->defines_length1 = _tmp72__length1;
	_tmp73_ = settings;
	_tmp74_ = bala_doc_alternative_resource_dirs;
	_tmp74__length1 = _bala_array_length (bala_doc_alternative_resource_dirs);
	_tmp75_ = (_tmp74_ != NULL) ? _bala_array_dup8 (_tmp74_, _tmp74__length1) : ((gpointer) _tmp74_);
	_tmp75__length1 = _tmp74__length1;
	_tmp73_->alternative_resource_dirs = (_bala_array_free (_tmp73_->alternative_resource_dirs, _tmp73_->alternative_resource_dirs_length1, (GDestroyNotify) g_free), NULL);
	_tmp73_->alternative_resource_dirs = _tmp75_;
	_tmp73_->alternative_resource_dirs_length1 = _tmp75__length1;
	_tmp76_ = bala_code_context_new ();
	context = _tmp76_;
	_tmp77_ = context;
	bala_code_context_push (_tmp77_);
	doclet = NULL;
	_tmp79_ = bala_doc_create_module_loader (self, reporter, &_tmp78_);
	_g_object_unref0 (doclet);
	doclet = _tmp78_;
	modules = _tmp79_;
	_tmp81_ = baladoc_error_reporter_get_errors (reporter);
	_tmp82_ = _tmp81_;
	if (_tmp82_ > 0) {
		_tmp80_ = TRUE;
	} else {
		BaladocModuleLoader* _tmp83_;
		_tmp83_ = modules;
		_tmp80_ = _tmp83_ == NULL;
	}
	if (_tmp80_) {
		result = bala_doc_quit (reporter, TRUE);
		_g_object_unref0 (modules);
		_g_object_unref0 (doclet);
		_bala_code_context_unref0 (context);
		_g_object_unref0 (settings);
		return result;
	}
	_tmp84_ = baladoc_tree_builder_new ();
	builder = _tmp84_;
	_tmp85_ = builder;
	_tmp86_ = settings;
	_tmp87_ = baladoc_tree_builder_build (_tmp85_, _tmp86_, reporter);
	doctree = _tmp87_;
	_tmp88_ = baladoc_error_reporter_get_errors (reporter);
	_tmp89_ = _tmp88_;
	if (_tmp89_ > 0) {
		_g_object_unref0 (doclet);
		doclet = NULL;
		result = bala_doc_quit (reporter, TRUE);
		_baladoc_api_tree_unref0 (doctree);
		_bala_code_visitor_unref0 (builder);
		_g_object_unref0 (modules);
		_g_object_unref0 (doclet);
		_bala_code_context_unref0 (context);
		_g_object_unref0 (settings);
		return result;
	}
	_tmp90_ = builder;
	_tmp91_ = baladoc_symbol_resolver_new (_tmp90_);
	resolver = _tmp91_;
	_tmp92_ = doctree;
	_tmp93_ = resolver;
	baladoc_api_tree_accept (_tmp92_, (BaladocApiVisitor*) _tmp93_);
	_tmp94_ = baladoc_api_child_symbol_registrar_new ();
	registrar = _tmp94_;
	_tmp95_ = doctree;
	_tmp96_ = registrar;
	baladoc_api_tree_accept (_tmp95_, (BaladocApiVisitor*) _tmp96_);
	_tmp97_ = settings;
	_tmp98_ = doctree;
	_tmp99_ = modules;
	_tmp100_ = baladoc_documentation_parser_new (_tmp97_, reporter, _tmp98_, _tmp99_);
	docparser = _tmp100_;
	_tmp101_ = doctree;
	if (!baladoc_api_tree_create_tree (_tmp101_)) {
		result = bala_doc_quit (reporter, TRUE);
		_g_object_unref0 (docparser);
		_g_object_unref0 (registrar);
		_g_object_unref0 (resolver);
		_baladoc_api_tree_unref0 (doctree);
		_bala_code_visitor_unref0 (builder);
		_g_object_unref0 (modules);
		_g_object_unref0 (doclet);
		_bala_code_context_unref0 (context);
		_g_object_unref0 (settings);
		return result;
	}
	_tmp102_ = doctree;
	_tmp103_ = docparser;
	_tmp104_ = modules;
	_tmp105_ = settings;
	_tmp106_ = baladoc_importer_baladoc_documentation_importer_new (_tmp102_, _tmp103_, _tmp104_, _tmp105_, reporter);
	_tmp107_ = doctree;
	_tmp108_ = docparser;
	_tmp109_ = modules;
	_tmp110_ = settings;
	_tmp111_ = baladoc_importer_gir_documentation_importer_new (_tmp107_, _tmp108_, _tmp109_, _tmp110_, reporter);
	_tmp112_ = g_new0 (BaladocImporterDocumentationImporter*, 2 + 1);
	_tmp112_[0] = (BaladocImporterDocumentationImporter*) _tmp106_;
	_tmp112_[1] = (BaladocImporterDocumentationImporter*) _tmp111_;
	importers = _tmp112_;
	importers_length1 = 2;
	_importers_size_ = importers_length1;
	_tmp113_ = doctree;
	_tmp114_ = docparser;
	baladoc_api_tree_parse_comments (_tmp113_, _tmp114_);
	_tmp115_ = baladoc_error_reporter_get_errors (reporter);
	_tmp116_ = _tmp115_;
	if (_tmp116_ > 0) {
		result = bala_doc_quit (reporter, TRUE);
		importers = (_bala_array_free (importers, importers_length1, (GDestroyNotify) g_object_unref), NULL);
		_g_object_unref0 (docparser);
		_g_object_unref0 (registrar);
		_g_object_unref0 (resolver);
		_baladoc_api_tree_unref0 (doctree);
		_bala_code_visitor_unref0 (builder);
		_g_object_unref0 (modules);
		_g_object_unref0 (doclet);
		_bala_code_context_unref0 (context);
		_g_object_unref0 (settings);
		return result;
	}
	_tmp117_ = doctree;
	_tmp118_ = importers;
	_tmp118__length1 = importers_length1;
	_tmp119_ = bala_doc_import_packages;
	_tmp119__length1 = _bala_array_length (bala_doc_import_packages);
	_tmp120_ = bala_doc_import_directories;
	_tmp120__length1 = _bala_array_length (bala_doc_import_directories);
	baladoc_api_tree_import_comments (_tmp117_, _tmp118_, (gint) _tmp118__length1, _tmp119_, (gint) _tmp119__length1, _tmp120_, (gint) _tmp120__length1);
	_tmp121_ = baladoc_error_reporter_get_errors (reporter);
	_tmp122_ = _tmp121_;
	if (_tmp122_ > 0) {
		result = bala_doc_quit (reporter, TRUE);
		importers = (_bala_array_free (importers, importers_length1, (GDestroyNotify) g_object_unref), NULL);
		_g_object_unref0 (docparser);
		_g_object_unref0 (registrar);
		_g_object_unref0 (resolver);
		_baladoc_api_tree_unref0 (doctree);
		_bala_code_visitor_unref0 (builder);
		_g_object_unref0 (modules);
		_g_object_unref0 (doclet);
		_bala_code_context_unref0 (context);
		_g_object_unref0 (settings);
		return result;
	}
	_tmp123_ = doctree;
	_tmp124_ = docparser;
	baladoc_api_tree_check_comments (_tmp123_, _tmp124_);
	_tmp125_ = baladoc_error_reporter_get_errors (reporter);
	_tmp126_ = _tmp125_;
	if (_tmp126_ > 0) {
		result = bala_doc_quit (reporter, TRUE);
		importers = (_bala_array_free (importers, importers_length1, (GDestroyNotify) g_object_unref), NULL);
		_g_object_unref0 (docparser);
		_g_object_unref0 (registrar);
		_g_object_unref0 (resolver);
		_baladoc_api_tree_unref0 (doctree);
		_bala_code_visitor_unref0 (builder);
		_g_object_unref0 (modules);
		_g_object_unref0 (doclet);
		_bala_code_context_unref0 (context);
		_g_object_unref0 (settings);
		return result;
	}
	_tmp127_ = bala_doc_gir_name;
	if (_tmp127_ != NULL) {
		BaladocGirWriter* gir_writer = NULL;
		BaladocSymbolResolver* _tmp128_;
		BaladocGirWriter* _tmp129_;
		BaladocGirWriter* _tmp130_;
		BaladocApiTree* _tmp131_;
		BalaCodeContext* _tmp132_;
		BalaCodeContext* _tmp133_;
		BaladocSettings* _tmp134_;
		const gchar* _tmp135_;
		BaladocSettings* _tmp136_;
		const gchar* _tmp137_;
		BaladocSettings* _tmp138_;
		const gchar* _tmp139_;
		gchar* _tmp140_;
		gchar* _tmp141_;
		BaladocSettings* _tmp142_;
		const gchar* _tmp143_;
		BaladocSettings* _tmp144_;
		const gchar* _tmp145_;
		BaladocSettings* _tmp146_;
		const gchar* _tmp147_;
		gint _tmp148_;
		gint _tmp149_;
		_tmp128_ = resolver;
		_tmp129_ = baladoc_gir_writer_new (_tmp128_);
		gir_writer = _tmp129_;
		_tmp130_ = gir_writer;
		_tmp131_ = doctree;
		_tmp132_ = baladoc_api_tree_get_context (_tmp131_);
		_tmp133_ = _tmp132_;
		_tmp134_ = settings;
		_tmp135_ = _tmp134_->gir_directory;
		_tmp136_ = settings;
		_tmp137_ = _tmp136_->gir_namespace;
		_tmp138_ = settings;
		_tmp139_ = _tmp138_->gir_version;
		_tmp140_ = g_strdup_printf ("%s-%s.gir", _tmp137_, _tmp139_);
		_tmp141_ = _tmp140_;
		_tmp142_ = settings;
		_tmp143_ = _tmp142_->gir_namespace;
		_tmp144_ = settings;
		_tmp145_ = _tmp144_->gir_version;
		_tmp146_ = settings;
		_tmp147_ = _tmp146_->pkg_name;
		bala_gir_writer_write_file ((BalaGIRWriter*) _tmp130_, _tmp133_, _tmp135_, _tmp141_, _tmp143_, _tmp145_, _tmp147_, NULL);
		_g_free0 (_tmp141_);
		_tmp148_ = baladoc_error_reporter_get_errors (reporter);
		_tmp149_ = _tmp148_;
		if (_tmp149_ > 0) {
			result = bala_doc_quit (reporter, TRUE);
			_bala_code_visitor_unref0 (gir_writer);
			importers = (_bala_array_free (importers, importers_length1, (GDestroyNotify) g_object_unref), NULL);
			_g_object_unref0 (docparser);
			_g_object_unref0 (registrar);
			_g_object_unref0 (resolver);
			_baladoc_api_tree_unref0 (doctree);
			_bala_code_visitor_unref0 (builder);
			_g_object_unref0 (modules);
			_g_object_unref0 (doclet);
			_bala_code_context_unref0 (context);
			_g_object_unref0 (settings);
			return result;
		}
		_bala_code_visitor_unref0 (gir_writer);
	}
	_tmp150_ = doclet;
	_tmp151_ = settings;
	_tmp152_ = doctree;
	baladoc_doclet_process (_tmp150_, _tmp151_, _tmp152_, reporter);
	result = bala_doc_quit (reporter, TRUE);
	importers = (_bala_array_free (importers, importers_length1, (GDestroyNotify) g_object_unref), NULL);
	_g_object_unref0 (docparser);
	_g_object_unref0 (registrar);
	_g_object_unref0 (resolver);
	_baladoc_api_tree_unref0 (doctree);
	_bala_code_visitor_unref0 (builder);
	_g_object_unref0 (modules);
	_g_object_unref0 (doclet);
	_bala_code_context_unref0 (context);
	_g_object_unref0 (settings);
	return result;
}

static gint
string_last_index_of_char (const gchar* self,
                           gunichar c,
                           gint start_index)
{
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gint result = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = g_utf8_strrchr (((gchar*) self) + start_index, (gssize) -1, c);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	if (_tmp1_ != NULL) {
		gchar* _tmp2_;
		_tmp2_ = _result_;
		result = (gint) (_tmp2_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}

static glong
string_strnlen (gchar* str,
                glong maxlen)
{
	gchar* end = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	glong result = 0L;
	_tmp0_ = memchr (str, 0, (gsize) maxlen);
	end = _tmp0_;
	_tmp1_ = end;
	if (_tmp1_ == NULL) {
		result = maxlen;
		return result;
	} else {
		gchar* _tmp2_;
		_tmp2_ = end;
		result = (glong) (_tmp2_ - str);
		return result;
	}
}

static gchar*
string_substring (const gchar* self,
                  glong offset,
                  glong len)
{
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	gchar* _tmp3_;
	gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	if (offset >= ((glong) 0)) {
		_tmp0_ = len >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		string_length = string_strnlen ((gchar*) self, offset + len);
	} else {
		gint _tmp1_;
		gint _tmp2_;
		_tmp1_ = strlen (self);
		_tmp2_ = _tmp1_;
		string_length = (glong) _tmp2_;
	}
	if (offset < ((glong) 0)) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= ((glong) 0), NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < ((glong) 0)) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	_tmp3_ = g_strndup (((gchar*) self) + offset, (gsize) len);
	result = _tmp3_;
	return result;
}

static gchar
string_get (const gchar* self,
            glong index)
{
	gchar _tmp0_;
	gchar result = '\0';
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = ((gchar*) self)[index];
	result = _tmp0_;
	return result;
}

static gboolean
string_contains (const gchar* self,
                 const gchar* needle)
{
	gchar* _tmp0_;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
	result = _tmp0_ != NULL;
	return result;
}

static gint
bala_doc_main (gchar** args,
               gint args_length1)
{
	BaladocErrorReporter* reporter = NULL;
	BaladocErrorReporter* _tmp0_;
	const gchar* _tmp19_;
	const gchar* _tmp24_;
	const gchar* _tmp30_;
	gchar** _tmp34_;
	gint _tmp34__length1;
	BaladocErrorReporter* _tmp41_;
	gint _tmp42_;
	gint _tmp43_;
	const gchar* _tmp45_;
	BalaDoc* baladoc = NULL;
	BalaDoc* _tmp77_;
	BalaDoc* _tmp78_;
	BaladocErrorReporter* _tmp79_;
	GError* _inner_error0_ = NULL;
	gint result = 0;
	setlocale (LC_ALL, "");
	_tmp0_ = baladoc_error_reporter_new (NULL);
	reporter = _tmp0_;
	{
		GOptionContext* opt_context = NULL;
		GOptionContext* _tmp1_;
		GOptionContext* _tmp2_;
		GOptionContext* _tmp3_;
		GOptionContext* _tmp4_;
		_tmp1_ = g_option_context_new ("- Bala Documentation Tool");
		opt_context = _tmp1_;
		_tmp2_ = opt_context;
		g_option_context_set_help_enabled (_tmp2_, TRUE);
		_tmp3_ = opt_context;
		g_option_context_add_main_entries (_tmp3_, BALA_DOC_options, NULL);
		_tmp4_ = opt_context;
		g_option_context_parse (_tmp4_, (gint*) (&args_length1), &args, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			gint _tmp5_ = -1;
			_g_option_context_free0 (opt_context);
			if (_inner_error0_->domain == G_OPTION_ERROR) {
				goto __catch0_g_option_error;
			}
			_g_object_unref0 (reporter);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return _tmp5_;
		}
		_g_option_context_free0 (opt_context);
	}
	goto __finally0;
	__catch0_g_option_error:
	{
		GError* e = NULL;
		BaladocErrorReporter* _tmp6_;
		GError* _tmp7_;
		const gchar* _tmp8_;
		FILE* _tmp9_;
		const gchar* _tmp10_;
		BaladocErrorReporter* _tmp11_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp6_ = reporter;
		_tmp7_ = e;
		_tmp8_ = _tmp7_->message;
		baladoc_error_reporter_simple_error (_tmp6_, NULL, "%s", _tmp8_);
		_tmp9_ = stdout;
		_tmp10_ = args[0];
		fprintf (_tmp9_, "Run '%s --help' to see a full list of available command line options.\n", _tmp10_);
		_tmp11_ = reporter;
		result = bala_doc_quit (_tmp11_, FALSE);
		_g_error_free0 (e);
		_g_object_unref0 (reporter);
		return result;
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		gint _tmp12_ = -1;
		_g_object_unref0 (reporter);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return _tmp12_;
	}
	if (bala_doc_disable_diagnostic_colors == FALSE) {
		const gchar* env_colors = NULL;
		const gchar* _tmp13_;
		const gchar* _tmp14_;
		_tmp13_ = g_getenv ("BALA_COLORS");
		env_colors = _tmp13_;
		_tmp14_ = env_colors;
		if (_tmp14_ != NULL) {
			BaladocErrorReporter* _tmp15_;
			const gchar* _tmp16_;
			_tmp15_ = reporter;
			_tmp16_ = env_colors;
			baladoc_error_reporter_set_colors (_tmp15_, _tmp16_);
		} else {
			BaladocErrorReporter* _tmp17_;
			_tmp17_ = reporter;
			baladoc_error_reporter_set_colors (_tmp17_, BALA_DOC_DEFAULT_COLORS);
		}
	}
	if (bala_doc_version) {
		FILE* _tmp18_;
		_tmp18_ = stdout;
		fprintf (_tmp18_, "Baladoc %s\n", BALA_BUILD_VERSION);
		result = 0;
		_g_object_unref0 (reporter);
		return result;
	}
	_tmp19_ = bala_doc_directory;
	if (_tmp19_ == NULL) {
		BaladocErrorReporter* _tmp20_;
		BaladocErrorReporter* _tmp21_;
		_tmp20_ = reporter;
		baladoc_error_reporter_simple_error (_tmp20_, NULL, "No output directory specified.");
		_tmp21_ = reporter;
		result = bala_doc_quit (_tmp21_, FALSE);
		_g_object_unref0 (reporter);
		return result;
	}
	if (!bala_doc_check_pkg_name ()) {
		BaladocErrorReporter* _tmp22_;
		BaladocErrorReporter* _tmp23_;
		_tmp22_ = reporter;
		baladoc_error_reporter_simple_error (_tmp22_, NULL, "File already exists");
		_tmp23_ = reporter;
		result = bala_doc_quit (_tmp23_, FALSE);
		_g_object_unref0 (reporter);
		return result;
	}
	_tmp24_ = bala_doc_directory;
	if (g_file_test (_tmp24_, G_FILE_TEST_EXISTS)) {
		if (bala_doc_force == TRUE) {
			gboolean tmp = FALSE;
			const gchar* _tmp25_;
			_tmp25_ = bala_doc_directory;
			tmp = baladoc_remove_directory (_tmp25_);
			if (tmp == FALSE) {
				BaladocErrorReporter* _tmp26_;
				BaladocErrorReporter* _tmp27_;
				_tmp26_ = reporter;
				baladoc_error_reporter_simple_error (_tmp26_, NULL, "Can't remove directory.");
				_tmp27_ = reporter;
				result = bala_doc_quit (_tmp27_, FALSE);
				_g_object_unref0 (reporter);
				return result;
			}
		} else {
			BaladocErrorReporter* _tmp28_;
			BaladocErrorReporter* _tmp29_;
			_tmp28_ = reporter;
			baladoc_error_reporter_simple_error (_tmp28_, NULL, "File already exists");
			_tmp29_ = reporter;
			result = bala_doc_quit (_tmp29_, FALSE);
			_g_object_unref0 (reporter);
			return result;
		}
	}
	_tmp30_ = bala_doc_wikidirectory;
	if (_tmp30_ != NULL) {
		const gchar* _tmp31_;
		_tmp31_ = bala_doc_wikidirectory;
		if (!g_file_test (_tmp31_, G_FILE_TEST_IS_DIR)) {
			BaladocErrorReporter* _tmp32_;
			BaladocErrorReporter* _tmp33_;
			_tmp32_ = reporter;
			baladoc_error_reporter_simple_error (_tmp32_, NULL, "Wiki-directory does not exist.");
			_tmp33_ = reporter;
			result = bala_doc_quit (_tmp33_, FALSE);
			_g_object_unref0 (reporter);
			return result;
		}
	}
	_tmp34_ = bala_doc_alternative_resource_dirs;
	_tmp34__length1 = _bala_array_length (bala_doc_alternative_resource_dirs);
	{
		gchar** dir_collection = NULL;
		gint dir_collection_length1 = 0;
		gint _dir_collection_size_ = 0;
		gint dir_it = 0;
		dir_collection = _tmp34_;
		dir_collection_length1 = _tmp34__length1;
		for (dir_it = 0; dir_it < dir_collection_length1; dir_it = dir_it + 1) {
			const gchar* dir = NULL;
			dir = dir_collection[dir_it];
			{
				const gchar* _tmp35_;
				_tmp35_ = dir;
				if (!g_file_test (_tmp35_, G_FILE_TEST_IS_DIR)) {
					BaladocErrorReporter* _tmp36_;
					const gchar* _tmp37_;
					gchar* _tmp38_;
					gchar* _tmp39_;
					BaladocErrorReporter* _tmp40_;
					_tmp36_ = reporter;
					_tmp37_ = dir;
					_tmp38_ = g_strdup_printf ("alternative resource directory '%s' does not exist.", _tmp37_);
					_tmp39_ = _tmp38_;
					baladoc_error_reporter_simple_error (_tmp36_, NULL, "%s", _tmp39_);
					_g_free0 (_tmp39_);
					_tmp40_ = reporter;
					result = bala_doc_quit (_tmp40_, FALSE);
					_g_object_unref0 (reporter);
					return result;
				}
			}
		}
	}
	_tmp41_ = reporter;
	_tmp42_ = baladoc_error_reporter_get_errors (_tmp41_);
	_tmp43_ = _tmp42_;
	if (_tmp43_ > 0) {
		BaladocErrorReporter* _tmp44_;
		_tmp44_ = reporter;
		result = bala_doc_quit (_tmp44_, FALSE);
		_g_object_unref0 (reporter);
		return result;
	}
	_tmp45_ = bala_doc_gir_name;
	if (_tmp45_ != NULL) {
		glong gir_len = 0L;
		const gchar* _tmp46_;
		gint _tmp47_;
		gint _tmp48_;
		gint last_hyphen = 0;
		const gchar* _tmp49_;
		gboolean _tmp50_ = FALSE;
		const gchar* _tmp55_;
		gchar* _tmp56_;
		const gchar* _tmp57_;
		gchar* _tmp58_;
		const gchar* _tmp59_;
		gboolean _tmp60_ = FALSE;
		gboolean _tmp61_ = FALSE;
		gboolean _tmp62_ = FALSE;
		const gchar* _tmp63_;
		gboolean report_warning = FALSE;
		gchar** _tmp70_;
		gint _tmp70__length1;
		_tmp46_ = bala_doc_gir_name;
		_tmp47_ = strlen (_tmp46_);
		_tmp48_ = _tmp47_;
		gir_len = (glong) _tmp48_;
		_tmp49_ = bala_doc_gir_name;
		last_hyphen = string_last_index_of_char (_tmp49_, (gunichar) '-', 0);
		if (last_hyphen == -1) {
			_tmp50_ = TRUE;
		} else {
			const gchar* _tmp51_;
			_tmp51_ = bala_doc_gir_name;
			_tmp50_ = !g_str_has_suffix (_tmp51_, ".gir");
		}
		if (_tmp50_) {
			BaladocErrorReporter* _tmp52_;
			const gchar* _tmp53_;
			BaladocErrorReporter* _tmp54_;
			_tmp52_ = reporter;
			_tmp53_ = bala_doc_gir_name;
			baladoc_error_reporter_simple_error (_tmp52_, NULL, "GIR file name '%s' is not well-formed, expected NAME-VERSION.gir", _tmp53_);
			_tmp54_ = reporter;
			result = bala_doc_quit (_tmp54_, FALSE);
			_g_object_unref0 (reporter);
			return result;
		}
		_tmp55_ = bala_doc_gir_name;
		_tmp56_ = string_substring (_tmp55_, (glong) 0, (glong) last_hyphen);
		_g_free0 (bala_doc_gir_namespace);
		bala_doc_gir_namespace = _tmp56_;
		_tmp57_ = bala_doc_gir_name;
		_tmp58_ = string_substring (_tmp57_, (glong) (last_hyphen + 1), (gir_len - last_hyphen) - 5);
		_g_free0 (bala_doc_gir_version);
		bala_doc_gir_version = _tmp58_;
		_tmp59_ = bala_doc_gir_version;
		g_strcanon (_tmp59_, "0123456789.", '?');
		_tmp63_ = bala_doc_gir_namespace;
		if (g_strcmp0 (_tmp63_, "") == 0) {
			_tmp62_ = TRUE;
		} else {
			const gchar* _tmp64_;
			_tmp64_ = bala_doc_gir_version;
			_tmp62_ = g_strcmp0 (_tmp64_, "") == 0;
		}
		if (_tmp62_) {
			_tmp61_ = TRUE;
		} else {
			const gchar* _tmp65_;
			_tmp65_ = bala_doc_gir_version;
			_tmp61_ = !g_ascii_isdigit (string_get (_tmp65_, (glong) 0));
		}
		if (_tmp61_) {
			_tmp60_ = TRUE;
		} else {
			const gchar* _tmp66_;
			_tmp66_ = bala_doc_gir_version;
			_tmp60_ = string_contains (_tmp66_, "?");
		}
		if (_tmp60_) {
			BaladocErrorReporter* _tmp67_;
			const gchar* _tmp68_;
			BaladocErrorReporter* _tmp69_;
			_tmp67_ = reporter;
			_tmp68_ = bala_doc_gir_name;
			baladoc_error_reporter_simple_error (_tmp67_, NULL, "GIR file name '%s' is not well-formed, expected NAME-VERSION.gir", _tmp68_);
			_tmp69_ = reporter;
			result = bala_doc_quit (_tmp69_, FALSE);
			_g_object_unref0 (reporter);
			return result;
		}
		report_warning = TRUE;
		_tmp70_ = bala_doc_tsources;
		_tmp70__length1 = _bala_array_length (bala_doc_tsources);
		{
			gchar** source_collection = NULL;
			gint source_collection_length1 = 0;
			gint _source_collection_size_ = 0;
			gint source_it = 0;
			source_collection = _tmp70_;
			source_collection_length1 = _tmp70__length1;
			for (source_it = 0; source_it < source_collection_length1; source_it = source_it + 1) {
				gchar* _tmp71_;
				gchar* source = NULL;
				_tmp71_ = g_strdup (source_collection[source_it]);
				source = _tmp71_;
				{
					gboolean _tmp72_ = FALSE;
					const gchar* _tmp73_;
					_tmp73_ = source;
					if (g_str_has_suffix (_tmp73_, ".bala")) {
						_tmp72_ = TRUE;
					} else {
						const gchar* _tmp74_;
						_tmp74_ = source;
						_tmp72_ = g_str_has_suffix (_tmp74_, ".gs");
					}
					if (_tmp72_) {
						report_warning = FALSE;
						_g_free0 (source);
						break;
					}
					_g_free0 (source);
				}
			}
		}
		if (report_warning == TRUE) {
			BaladocErrorReporter* _tmp75_;
			BaladocErrorReporter* _tmp76_;
			_tmp75_ = reporter;
			baladoc_error_reporter_simple_error (_tmp75_, NULL, "No source file specified to be compiled to gir.");
			_tmp76_ = reporter;
			result = bala_doc_quit (_tmp76_, FALSE);
			_g_object_unref0 (reporter);
			return result;
		}
	}
	_tmp77_ = bala_doc_new ();
	baladoc = _tmp77_;
	_tmp78_ = baladoc;
	_tmp79_ = reporter;
	result = bala_doc_run (_tmp78_, _tmp79_);
	_g_object_unref0 (baladoc);
	_g_object_unref0 (reporter);
	return result;
}

int
main (int argc,
      char ** argv)
{
	return bala_doc_main (argv, argc);
}

BalaDoc*
bala_doc_construct (GType object_type)
{
	BalaDoc * self = NULL;
	self = (BalaDoc*) g_object_new (object_type, NULL);
	return self;
}

BalaDoc*
bala_doc_new (void)
{
	return bala_doc_construct (TYPE_BALA_DOC);
}

static void
bala_doc_class_init (BalaDocClass * klass,
                     gpointer klass_data)
{
	bala_doc_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = bala_doc_finalize;
}

static void
bala_doc_instance_init (BalaDoc * self,
                        gpointer klass)
{
}

static void
bala_doc_finalize (GObject * obj)
{
	BalaDoc * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_BALA_DOC, BalaDoc);
	G_OBJECT_CLASS (bala_doc_parent_class)->finalize (obj);
}

static GType
bala_doc_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (BalaDocClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) bala_doc_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BalaDoc), 0, (GInstanceInitFunc) bala_doc_instance_init, NULL };
	GType bala_doc_type_id;
	bala_doc_type_id = g_type_register_static (G_TYPE_OBJECT, "BalaDoc", &g_define_type_info, 0);
	return bala_doc_type_id;
}

GType
bala_doc_get_type (void)
{
	static volatile gsize bala_doc_type_id__volatile = 0;
	if (g_once_init_enter (&bala_doc_type_id__volatile)) {
		GType bala_doc_type_id;
		bala_doc_type_id = bala_doc_get_type_once ();
		g_once_init_leave (&bala_doc_type_id__volatile, bala_doc_type_id);
	}
	return bala_doc_type_id__volatile;
}

static void
_bala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gint i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_bala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_bala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gint
_bala_array_length (gpointer array)
{
	gint length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

